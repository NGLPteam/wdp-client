import type { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = { [X in Exclude<keyof T, K>]?: T[X] } & { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO 8601-encoded date */
  ISO8601Date: string;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: string;
  /** Represents untyped JSON */
  JSON: any;
  /** A slug that can identify a record in context */
  Slug: string;
  /** An upload ID is used to refer to an upload within the tus infrastructure outside of the GraphQL API */
  UploadID: string;
};

/** An access control list */
export type AccessControlList = {
  __typename?: 'AccessControlList';
  permissions: Array<PermissionGrant>;
};

/**
 * An access grant is a combination of an Entity, a Role, and a Subject. It determines permissions for
 * said subject at the specific point in the hierarchy, and any child entities will inherit that role
 * as its accessControlList defines.
 */
export type AccessGrant = {
  /** The polymorphic entity to which access has been granted */
  entity: AnyEntity;
  /** The role the subject has been assigned */
  role: Role;
  /** The polymorphic subject that has been granted access */
  subject: AccessGrantSubject;
};

/** Filters a set of access grants by what type of entity they've granted access to */
export type AccessGrantEntityFilter =
  /** All entity types */
  | 'ALL'
  /** Communities only */
  | 'COMMUNITY'
  /** Collections only */
  | 'COLLECTION'
  /** Items only */
  | 'ITEM'
  | '%future added value';

/**
 * An access grant subject is a person or group to which access for a specific entity
 * (and all its children) has been granted.
 */
export type AccessGrantSubject = {
  /** A polymorphic connection for access grants from a subject */
  allAccessGrants: AnyAccessGrantConnection;
};


/**
 * An access grant subject is a person or group to which access for a specific entity
 * (and all its children) has been granted.
 */
export type AccessGrantSubjectAllAccessGrantsArgs = {
  entity?: Maybe<AccessGrantEntityFilter>;
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** Filters a set of access grants by what type of subject they've granted access to */
export type AccessGrantSubjectFilter =
  /** All subject types */
  | 'ALL'
  /** An individual user */
  | 'USER'
  /** A group of users. Not currently exposed */
  | 'GROUP'
  | '%future added value';

/** An accessible entity can be granted access directly */
export type Accessible = {
  /** A polymorphic connection for access grants from an entity */
  allAccessGrants: AnyAccessGrantConnection;
};


/** An accessible entity can be granted access directly */
export type AccessibleAllAccessGrantsArgs = {
  subject?: Maybe<AccessGrantSubjectFilter>;
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** Autogenerated input type of AlterSchemaVersion */
export type AlterSchemaVersionInput = {
  /** The entity that owns the attachment */
  entityId: Scalars['ID'];
  /** The slug for the new schema to apply */
  schemaVersionSlug: Scalars['String'];
  /**
   * An arbitrary set of property values. Owing to the dynamic nature, they do not have a specific GraphQL input type
   * associated with them. Validation will be performed within the application and returned as errors if not valid.
   */
  propertyValues: Scalars['JSON'];
  /**
   * This argument dictates how the mutation should handle received property values.
   * If set to `SKIP`, it will alter the schema version without setting any new properties.
   */
  strategy?: Maybe<PropertyApplicationStrategy>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of AlterSchemaVersion */
export type AlterSchemaVersionPayload = StandardMutationPayload & {
  __typename?: 'AlterSchemaVersionPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  collection?: Maybe<Collection>;
  community?: Maybe<Community>;
  entity?: Maybe<AnyEntity>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  item?: Maybe<Item>;
  schemaErrors: Array<SchemaValueError>;
};

/** Encompasses *all* possible access grant types */
export type AnyAccessGrant = UserCollectionAccessGrant | UserCommunityAccessGrant | UserGroupCollectionAccessGrant | UserGroupCommunityAccessGrant | UserGroupItemAccessGrant | UserItemAccessGrant | { __typename?: "%other" };

/** The connection type for AnyAccessGrant. */
export type AnyAccessGrantConnection = Paginated & {
  __typename?: 'AnyAccessGrantConnection';
  /** A list of edges. */
  edges: Array<AnyAccessGrantEdge>;
  /** A list of nodes. */
  nodes: Array<AnyAccessGrant>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AnyAccessGrantEdge = {
  __typename?: 'AnyAccessGrantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: AnyAccessGrant;
};

export type AnyAsset = AssetAudio | AssetDocument | AssetImage | AssetPdf | AssetUnknown | AssetVideo | { __typename?: "%other" };

/** The connection type for AnyAsset. */
export type AnyAssetConnection = Paginated & {
  __typename?: 'AnyAssetConnection';
  /** A list of edges. */
  edges: Array<AnyAssetEdge>;
  /** A list of nodes. */
  nodes: Array<AnyAsset>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AnyAssetEdge = {
  __typename?: 'AnyAssetEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: AnyAsset;
};

/** Something that can be attached to */
export type AnyAttachable = Collection | Community | Item | { __typename?: "%other" };

export type AnyCollectionAccessGrant = UserCollectionAccessGrant | UserGroupCollectionAccessGrant | { __typename?: "%other" };

/** The connection type for AnyCollectionAccessGrant. */
export type AnyCollectionAccessGrantConnection = Paginated & {
  __typename?: 'AnyCollectionAccessGrantConnection';
  /** A list of edges. */
  edges: Array<AnyCollectionAccessGrantEdge>;
  /** A list of nodes. */
  nodes: Array<AnyCollectionAccessGrant>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AnyCollectionAccessGrantEdge = {
  __typename?: 'AnyCollectionAccessGrantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: AnyCollectionAccessGrant;
};

export type AnyCommunityAccessGrant = UserCommunityAccessGrant | UserGroupCommunityAccessGrant | { __typename?: "%other" };

/** The connection type for AnyCommunityAccessGrant. */
export type AnyCommunityAccessGrantConnection = Paginated & {
  __typename?: 'AnyCommunityAccessGrantConnection';
  /** A list of edges. */
  edges: Array<AnyCommunityAccessGrantEdge>;
  /** A list of nodes. */
  nodes: Array<AnyCommunityAccessGrant>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AnyCommunityAccessGrantEdge = {
  __typename?: 'AnyCommunityAccessGrantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: AnyCommunityAccessGrant;
};

/** A union of possible contribution types */
export type AnyContribution = CollectionContribution | ItemContribution | { __typename?: "%other" };

export type AnyContributor = OrganizationContributor | PersonContributor | { __typename?: "%other" };

/** The connection type for AnyContributor. */
export type AnyContributorConnection = Paginated & {
  __typename?: 'AnyContributorConnection';
  /** A list of edges. */
  edges: Array<AnyContributorEdge>;
  /** A list of nodes. */
  nodes: Array<AnyContributor>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AnyContributorEdge = {
  __typename?: 'AnyContributorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: AnyContributor;
};

/** A hierarchical entity type */
export type AnyEntity = Collection | Community | Item | { __typename?: "%other" };

/** The various types an OrderingEntry can refer to */
export type AnyOrderingEntry = Collection | Community | EntityLink | Item | { __typename?: "%other" };

export type AnyScalarProperty = AssetProperty | AssetsProperty | BooleanProperty | ContributorProperty | ContributorsProperty | DateProperty | EmailProperty | FloatProperty | IntegerProperty | MarkdownProperty | MultiselectProperty | SelectProperty | StringProperty | TagsProperty | TimestampProperty | UnknownProperty | { __typename?: "%other" };

export type AnySchemaProperty = AssetProperty | AssetsProperty | BooleanProperty | ContributorProperty | ContributorsProperty | DateProperty | EmailProperty | FloatProperty | GroupProperty | IntegerProperty | MarkdownProperty | MultiselectProperty | SelectProperty | StringProperty | TagsProperty | TimestampProperty | UnknownProperty | { __typename?: "%other" };

/** Encompasses any access grant for a specific user. */
export type AnyUserAccessGrant = UserCollectionAccessGrant | UserCommunityAccessGrant | UserItemAccessGrant | { __typename?: "%other" };

/** The connection type for AnyUserAccessGrant. */
export type AnyUserAccessGrantConnection = Paginated & {
  __typename?: 'AnyUserAccessGrantConnection';
  /** A list of edges. */
  edges: Array<AnyUserAccessGrantEdge>;
  /** A list of nodes. */
  nodes: Array<AnyUserAccessGrant>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AnyUserAccessGrantEdge = {
  __typename?: 'AnyUserAccessGrantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: AnyUserAccessGrant;
};

/** Encompasses any access grant for a group of users. Not currently exposed. */
export type AnyUserGroupAccessGrant = UserGroupCollectionAccessGrant | UserGroupCommunityAccessGrant | UserGroupItemAccessGrant | { __typename?: "%other" };

/** The connection type for AnyUserGroupAccessGrant. */
export type AnyUserGroupAccessGrantConnection = Paginated & {
  __typename?: 'AnyUserGroupAccessGrantConnection';
  /** A list of edges. */
  edges: Array<AnyUserGroupAccessGrantEdge>;
  /** A list of nodes. */
  nodes: Array<AnyUserGroupAccessGrant>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AnyUserGroupAccessGrantEdge = {
  __typename?: 'AnyUserGroupAccessGrantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: AnyUserGroupAccessGrant;
};

/** Autogenerated input type of ApplySchemaProperties */
export type ApplySchemaPropertiesInput = {
  /** The entity that owns the attachment */
  entityId: Scalars['ID'];
  /**
   * An arbitrary set of property values. Owing to the dynamic nature, they do not have a specific GraphQL input type
   * associated with them. Validation will be performed within the application and returned as errors if not valid.
   */
  propertyValues: Scalars['JSON'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of ApplySchemaProperties */
export type ApplySchemaPropertiesPayload = StandardMutationPayload & {
  __typename?: 'ApplySchemaPropertiesPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  collection?: Maybe<Collection>;
  community?: Maybe<Community>;
  entity?: Maybe<AnyEntity>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  item?: Maybe<Item>;
  schemaErrors: Array<SchemaValueError>;
};

/** A generic asset type, implemented by all the more specific kinds */
export type Asset = {
  attachable: AnyAttachable;
  caption?: Maybe<Scalars['String']>;
  contentType: Scalars['String'];
  downloadUrl?: Maybe<Scalars['String']>;
  fileSize: Scalars['Int'];
  /** ID of the object. */
  id: Scalars['ID'];
  kind: AssetKind;
  name: Scalars['String'];
  preview?: Maybe<AssetPreview>;
  slug: Scalars['Slug'];
};

export type AssetAudio = Asset & Node & Sluggable & {
  __typename?: 'AssetAudio';
  attachable: AnyAttachable;
  caption?: Maybe<Scalars['String']>;
  contentType: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  downloadUrl?: Maybe<Scalars['String']>;
  fileSize: Scalars['Int'];
  /** ID of the object. */
  id: Scalars['ID'];
  kind: AssetKind;
  name: Scalars['String'];
  preview?: Maybe<AssetPreview>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type AssetDocument = Asset & Node & Sluggable & {
  __typename?: 'AssetDocument';
  attachable: AnyAttachable;
  caption?: Maybe<Scalars['String']>;
  contentType: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  downloadUrl?: Maybe<Scalars['String']>;
  fileSize: Scalars['Int'];
  /** ID of the object. */
  id: Scalars['ID'];
  kind: AssetKind;
  name: Scalars['String'];
  preview?: Maybe<AssetPreview>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type AssetImage = Asset & Node & Sluggable & {
  __typename?: 'AssetImage';
  attachable: AnyAttachable;
  caption?: Maybe<Scalars['String']>;
  contentType: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  downloadUrl?: Maybe<Scalars['String']>;
  fileSize: Scalars['Int'];
  /** ID of the object. */
  id: Scalars['ID'];
  kind: AssetKind;
  name: Scalars['String'];
  preview?: Maybe<AssetPreview>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The supported kinds of assets in the system */
export type AssetKind =
  | 'image'
  | 'video'
  | 'audio'
  | 'pdf'
  | 'document'
  | 'unknown'
  | '%future added value';

/** The type(s) of assets to retrieve */
export type AssetKindFilter =
  | 'ALL'
  /** An image, video, or audio file */
  | 'MEDIA'
  | 'AUDIO'
  | 'IMAGE'
  | 'VIDEO'
  | 'PDF'
  | 'DOCUMENT'
  | 'UNKNOWN'
  | '%future added value';

export type AssetPdf = Asset & Node & Sluggable & {
  __typename?: 'AssetPDF';
  attachable: AnyAttachable;
  caption?: Maybe<Scalars['String']>;
  contentType: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  downloadUrl?: Maybe<Scalars['String']>;
  fileSize: Scalars['Int'];
  /** ID of the object. */
  id: Scalars['ID'];
  kind: AssetKind;
  name: Scalars['String'];
  preview?: Maybe<AssetPreview>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type AssetPreview = {
  __typename?: 'AssetPreview';
  alt: Scalars['String'];
  large: PreviewImageMap;
  medium: PreviewImageMap;
  small: PreviewImageMap;
  thumb: PreviewImageMap;
};

export type AssetProperty = ScalarProperty & {
  __typename?: 'AssetProperty';
  asset?: Maybe<AnyAsset>;
  fullPath: Scalars['String'];
  label: Scalars['String'];
  path: Scalars['String'];
  required: Scalars['Boolean'];
  type: Scalars['String'];
};

/** A select option for a single asset */
export type AssetSelectOption = {
  __typename?: 'AssetSelectOption';
  kind: AssetKind;
  label: Scalars['String'];
  value: Scalars['String'];
};

export type AssetUnknown = Asset & Node & Sluggable & {
  __typename?: 'AssetUnknown';
  attachable: AnyAttachable;
  caption?: Maybe<Scalars['String']>;
  contentType: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  downloadUrl?: Maybe<Scalars['String']>;
  fileSize: Scalars['Int'];
  /** ID of the object. */
  id: Scalars['ID'];
  kind: AssetKind;
  name: Scalars['String'];
  preview?: Maybe<AssetPreview>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type AssetVideo = Asset & Node & Sluggable & {
  __typename?: 'AssetVideo';
  attachable: AnyAttachable;
  caption?: Maybe<Scalars['String']>;
  contentType: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  downloadUrl?: Maybe<Scalars['String']>;
  fileSize: Scalars['Int'];
  /** ID of the object. */
  id: Scalars['ID'];
  kind: AssetKind;
  name: Scalars['String'];
  preview?: Maybe<AssetPreview>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type AssetsProperty = ScalarProperty & {
  __typename?: 'AssetsProperty';
  assets: Array<AnyAsset>;
  fullPath: Scalars['String'];
  label: Scalars['String'];
  path: Scalars['String'];
  required: Scalars['Boolean'];
  type: Scalars['String'];
};

/** A model that has attached assets */
export type Attachable = {
  /** Assets owned by this entity */
  assets: AnyAssetConnection;
};


/** A model that has attached assets */
export type AttachableAssetsArgs = {
  order?: Maybe<SimpleOrder>;
  kind?: Maybe<AssetKindFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

export type BooleanProperty = ScalarProperty & {
  __typename?: 'BooleanProperty';
  checked?: Maybe<Scalars['Boolean']>;
  checkedByDefault?: Maybe<Scalars['Boolean']>;
  fullPath: Scalars['String'];
  label: Scalars['String'];
  path: Scalars['String'];
  required: Scalars['Boolean'];
  type: Scalars['String'];
};

/** A collection of items */
export type Collection = Accessible & Entity & HierarchicalEntry & Contributable & HasSchemaProperties & Attachable & SchemaInstance & Node & Sluggable & {
  __typename?: 'Collection';
  /** Derived access control list */
  accessControlList?: Maybe<AccessControlList>;
  accessGrants: AnyCollectionAccessGrantConnection;
  /** A polymorphic connection for access grants from an entity */
  allAccessGrants: AnyAccessGrantConnection;
  /** A list of allowed actions for the given user on this entity (and its descendants). */
  allowedActions: Array<Scalars['String']>;
  /** The role(s) that gave the permissions to access this resource, if any. */
  applicableRoles?: Maybe<Array<Role>>;
  /** Assets owned by this entity */
  assets: AnyAssetConnection;
  /** Retrieve a list of user & role assignments for this entity */
  assignedUsers: ContextualPermissionConnection;
  /** Previous entries in the hierarchy */
  breadcrumbs: Array<EntityBreadcrumb>;
  /** @deprecated Use Collection.collections */
  children: CollectionConnection;
  collections: CollectionConnection;
  community: Community;
  contributions: CollectionContributionConnection;
  /** Contributors to this element */
  contributors: AnyContributorConnection;
  createdAt: Scalars['ISO8601DateTime'];
  /** The Digital Object Identifier for this entity. See https://doi.org */
  doi?: Maybe<Scalars['String']>;
  hidden: Scalars['Boolean'];
  /** If present, this is the timestamp the entity was hidden at */
  hiddenAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** The depth of the hierarchical entity, taking into account any parent types */
  hierarchicalDepth: Scalars['Int'];
  id: Scalars['ID'];
  /** A machine-readable identifier for the entity. Not presently used, but will be necessary for synchronizing with upstream providers. */
  identifier: Scalars['String'];
  items: ItemConnection;
  leaf: Scalars['Boolean'];
  links: EntityLinkConnection;
  /** Look up an ordering for this entity by identifier */
  ordering?: Maybe<Ordering>;
  orderings: OrderingConnection;
  parent?: Maybe<CollectionParent>;
  /** An array of hashes that can be requested to load in a context */
  permissions: Array<PermissionGrant>;
  /** The date the entity was published on, if present */
  publishedOn?: Maybe<Scalars['ISO8601Date']>;
  root: Scalars['Boolean'];
  schemaDefinition: SchemaDefinition;
  /** The context for our schema instance. Includes form values and necessary referents. */
  schemaInstanceContext: SchemaInstanceContext;
  /** A list of schema properties associated with this instance or version. */
  schemaProperties: Array<AnySchemaProperty>;
  schemaVersion: SchemaVersion;
  slug: Scalars['Slug'];
  /** A description of the contents of the entity */
  summary?: Maybe<Scalars['String']>;
  /** A mapping of an entity's preview thumbnail */
  thumbnail?: Maybe<AssetPreview>;
  /** A human-readable title for the entity */
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
  /** Access grants for specific users */
  userAccessGrants: UserCollectionAccessGrantConnection;
  /** Not presently used */
  userGroupAccessGrants: UserGroupCollectionAccessGrantConnection;
  /** If an entity is available in the frontend */
  visibility: EntityVisibility;
  visible: Scalars['Boolean'];
  /** If present, this is the timestamp an entity is visible after */
  visibleAfterAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** If present, this is the timestamp an entity is visible until */
  visibleUntilAt?: Maybe<Scalars['ISO8601DateTime']>;
};


/** A collection of items */
export type CollectionAccessGrantsArgs = {
  subject?: Maybe<AccessGrantSubjectFilter>;
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionAllAccessGrantsArgs = {
  subject?: Maybe<AccessGrantSubjectFilter>;
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionAssetsArgs = {
  order?: Maybe<SimpleOrder>;
  kind?: Maybe<AssetKindFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionAssignedUsersArgs = {
  order?: Maybe<ContextualPermissionOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionChildrenArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A collection of items */
export type CollectionCollectionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionContributionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionContributorsArgs = {
  order?: Maybe<SimpleOrder>;
  kind?: Maybe<ContributorFilterKind>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionItemsArgs = {
  order?: Maybe<SimpleOrder>;
  schema?: Maybe<Array<Scalars['String']>>;
  nodeFilter?: Maybe<TreeNodeFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionLinksArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionOrderingArgs = {
  identifier: Scalars['String'];
};


/** A collection of items */
export type CollectionOrderingsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionUserAccessGrantsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionUserGroupAccessGrantsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** The connection type for Collection. */
export type CollectionConnection = Paginated & {
  __typename?: 'CollectionConnection';
  /** A list of edges. */
  edges: Array<CollectionEdge>;
  /** A list of nodes. */
  nodes: Array<Collection>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** A contribution to a collection */
export type CollectionContribution = Contribution & Node & Sluggable & {
  __typename?: 'CollectionContribution';
  /** A potentially-overridden value from person contributors */
  affiliation?: Maybe<Scalars['String']>;
  collection: Collection;
  contributor: AnyContributor;
  contributorKind: ContributorKind;
  createdAt: Scalars['ISO8601DateTime'];
  /** A potentially-overridden display name value for all contributor types */
  displayName: Scalars['String'];
  id: Scalars['ID'];
  /** A potentially-overridden value from organization contributors */
  location?: Maybe<Scalars['String']>;
  metadata: ContributionMetadata;
  /** An arbitrary text value describing the role the contributor had */
  role?: Maybe<Scalars['String']>;
  slug: Scalars['Slug'];
  /** A potentially-overridden value from person contributors */
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for CollectionContribution. */
export type CollectionContributionConnection = Paginated & {
  __typename?: 'CollectionContributionConnection';
  /** A list of edges. */
  edges: Array<CollectionContributionEdge>;
  /** A list of nodes. */
  nodes: Array<CollectionContribution>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CollectionContributionEdge = {
  __typename?: 'CollectionContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: CollectionContribution;
};

/** An edge in a connection. */
export type CollectionEdge = {
  __typename?: 'CollectionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Collection;
};

export type CollectionParent = Collection | Community | { __typename?: "%other" };

/** A community of users */
export type Community = Accessible & Entity & HasSchemaProperties & Attachable & SchemaInstance & Node & Sluggable & {
  __typename?: 'Community';
  /** Derived access control list */
  accessControlList?: Maybe<AccessControlList>;
  accessGrants: AnyCommunityAccessGrantConnection;
  /** A polymorphic connection for access grants from an entity */
  allAccessGrants: AnyAccessGrantConnection;
  /** A list of allowed actions for the given user on this entity (and its descendants). */
  allowedActions: Array<Scalars['String']>;
  /** The role(s) that gave the permissions to access this resource, if any. */
  applicableRoles?: Maybe<Array<Role>>;
  /** Assets owned by this entity */
  assets: AnyAssetConnection;
  /** Retrieve a list of user & role assignments for this entity */
  assignedUsers: ContextualPermissionConnection;
  /** Previous entries in the hierarchy */
  breadcrumbs: Array<EntityBreadcrumb>;
  collections: CollectionConnection;
  createdAt: Scalars['ISO8601DateTime'];
  /** The depth of the hierarchical entity, taking into account any parent types */
  hierarchicalDepth: Scalars['Int'];
  id: Scalars['ID'];
  links: EntityLinkConnection;
  metadata?: Maybe<Scalars['JSON']>;
  /** @deprecated Use Community.title */
  name: Scalars['String'];
  /** Look up an ordering for this entity by identifier */
  ordering?: Maybe<Ordering>;
  orderings: OrderingConnection;
  /** An array of hashes that can be requested to load in a context */
  permissions: Array<PermissionGrant>;
  position?: Maybe<Scalars['Int']>;
  schemaDefinition: SchemaDefinition;
  /** The context for our schema instance. Includes form values and necessary referents. */
  schemaInstanceContext: SchemaInstanceContext;
  /** A list of schema properties associated with this instance or version. */
  schemaProperties: Array<AnySchemaProperty>;
  schemaVersion: SchemaVersion;
  slug: Scalars['Slug'];
  /** A mapping of an entity's preview thumbnail */
  thumbnail?: Maybe<AssetPreview>;
  title: Scalars['String'];
  updatedAt: Scalars['ISO8601DateTime'];
  /** Access grants for specific users */
  userAccessGrants: UserCommunityAccessGrantConnection;
  /** Not presently used */
  userGroupAccessGrants: UserGroupCommunityAccessGrantConnection;
};


/** A community of users */
export type CommunityAccessGrantsArgs = {
  subject?: Maybe<AccessGrantSubjectFilter>;
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A community of users */
export type CommunityAllAccessGrantsArgs = {
  subject?: Maybe<AccessGrantSubjectFilter>;
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A community of users */
export type CommunityAssetsArgs = {
  order?: Maybe<SimpleOrder>;
  kind?: Maybe<AssetKindFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A community of users */
export type CommunityAssignedUsersArgs = {
  order?: Maybe<ContextualPermissionOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A community of users */
export type CommunityCollectionsArgs = {
  order?: Maybe<SimpleOrder>;
  schema?: Maybe<Array<Scalars['String']>>;
  nodeFilter?: Maybe<TreeNodeFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A community of users */
export type CommunityLinksArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A community of users */
export type CommunityOrderingArgs = {
  identifier: Scalars['String'];
};


/** A community of users */
export type CommunityOrderingsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A community of users */
export type CommunityUserAccessGrantsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A community of users */
export type CommunityUserGroupAccessGrantsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** The connection type for Community. */
export type CommunityConnection = Paginated & {
  __typename?: 'CommunityConnection';
  /** A list of edges. */
  edges: Array<CommunityEdge>;
  /** A list of nodes. */
  nodes: Array<Community>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CommunityEdge = {
  __typename?: 'CommunityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Community;
};

/** A contextual permission for a user, role, and entity */
export type ContextualPermission = ExposesPermissions & Node & Sluggable & {
  __typename?: 'ContextualPermission';
  /** Derived access control list */
  accessControlList?: Maybe<AccessControlList>;
  /** The access grants that correspond to this contextual permission */
  accessGrants: Array<AnyUserAccessGrant>;
  /** A list of allowed actions for the given user on this entity (and its descendants). */
  allowedActions: Array<Scalars['String']>;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  /** An array of hashes that can be requested to load in a context */
  permissions: Array<PermissionGrant>;
  /** The roles that correspond to this contextual permission */
  roles: Array<Role>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
  user: User;
};

/** The connection type for ContextualPermission. */
export type ContextualPermissionConnection = Paginated & {
  __typename?: 'ContextualPermissionConnection';
  /** A list of edges. */
  edges: Array<ContextualPermissionEdge>;
  /** A list of nodes. */
  nodes: Array<ContextualPermission>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ContextualPermissionEdge = {
  __typename?: 'ContextualPermissionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ContextualPermission;
};

/** A collection of options used to dictate how to order contextual permissions */
export type ContextualPermissionOrder =
  /** Order by the most recently granted permissions */
  | 'RECENT'
  /** Order by the oldest granted permissions */
  | 'OLDEST'
  /** Order by the user's name from A-Z */
  | 'USER_NAME_ASC'
  /** Order by the user's name from Z-A */
  | 'USER_NAME_DESC'
  | '%future added value';

/** Something that can be contributed to */
export type Contributable = {
  /** Contributors to this element */
  contributors: AnyContributorConnection;
};


/** Something that can be contributed to */
export type ContributableContributorsArgs = {
  order?: Maybe<SimpleOrder>;
  kind?: Maybe<ContributorFilterKind>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** A contribution from a certain contributor */
export type Contribution = {
  /** A potentially-overridden value from person contributors */
  affiliation?: Maybe<Scalars['String']>;
  contributor: AnyContributor;
  contributorKind: ContributorKind;
  /** A potentially-overridden display name value for all contributor types */
  displayName: Scalars['String'];
  /** A potentially-overridden value from organization contributors */
  location?: Maybe<Scalars['String']>;
  metadata: ContributionMetadata;
  /** An arbitrary text value describing the role the contributor had */
  role?: Maybe<Scalars['String']>;
  /** A potentially-overridden value from person contributors */
  title?: Maybe<Scalars['String']>;
};

/** Metadata for a contribution */
export type ContributionMetadata = {
  __typename?: 'ContributionMetadata';
  /** A value that can override a contribution's contributor's affiliation */
  affiliation?: Maybe<Scalars['String']>;
  /** A value that can oerride a contribution's contributor's displayed name */
  displayName?: Maybe<Scalars['String']>;
  /** An arbitrary field describing how the contributor contributed */
  role?: Maybe<Scalars['String']>;
  /** A value that can override a contribution's contributor's title */
  title?: Maybe<Scalars['String']>;
};

/** An input type that builds contribution metadata */
export type ContributionMetadataInput = {
  /** A value that can override a contribution's contributor's title */
  title?: Maybe<Scalars['String']>;
  /** A value that can override a contribution's contributor's affiliation */
  affiliation?: Maybe<Scalars['String']>;
  /** A value that can override a contribution's contributor's displayed name */
  displayName?: Maybe<Scalars['String']>;
  /** A value that can override a contribution's contributor's location */
  location?: Maybe<Scalars['String']>;
};

/** A contributor who has made a contribution */
export type Contributor = {
  bio?: Maybe<Scalars['String']>;
  collectionContributions: CollectionContributionConnection;
  email?: Maybe<Scalars['String']>;
  identifier: Scalars['String'];
  /** An optional image associated with the contributor */
  image?: Maybe<AssetPreview>;
  itemContributions: ItemContributionConnection;
  kind: ContributorKind;
  links: Array<ContributorLink>;
  prefix?: Maybe<Scalars['String']>;
  suffix?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
};


/** A contributor who has made a contribution */
export type ContributorCollectionContributionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A contributor who has made a contribution */
export type ContributorItemContributionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

export type ContributorFilterKind =
  | 'ALL'
  | 'ORGANIZATION'
  | 'PERSON'
  | '%future added value';

export type ContributorKind =
  | 'organization'
  | 'person'
  | '%future added value';

/** A link for a contributor */
export type ContributorLink = {
  __typename?: 'ContributorLink';
  title: Scalars['String'];
  url: Scalars['String'];
};

/** A mapping to build a contributor link */
export type ContributorLinkInput = {
  title: Scalars['String'];
  url: Scalars['String'];
};

export type ContributorProperty = ScalarProperty & {
  __typename?: 'ContributorProperty';
  contributor?: Maybe<AnyContributor>;
  fullPath: Scalars['String'];
  label: Scalars['String'];
  path: Scalars['String'];
  required: Scalars['Boolean'];
  type: Scalars['String'];
};

/** A select option for a single contributor */
export type ContributorSelectOption = {
  __typename?: 'ContributorSelectOption';
  kind: ContributorKind;
  label: Scalars['String'];
  value: Scalars['String'];
};

export type ContributorsProperty = ScalarProperty & {
  __typename?: 'ContributorsProperty';
  contributors: Array<AnyContributor>;
  fullPath: Scalars['String'];
  label: Scalars['String'];
  path: Scalars['String'];
  required: Scalars['Boolean'];
  type: Scalars['String'];
};

/** Autogenerated input type of CreateAsset */
export type CreateAssetInput = {
  /** The entity that owns the attachment */
  entityId: Scalars['ID'];
  /** A reference to an upload in Tus. */
  attachment: UploadedFileInput;
  /** A human readable name for the asset */
  name: Scalars['String'];
  /** The position the asset occupies amongst siblings */
  position?: Maybe<Scalars['Int']>;
  /** Alt text to display for the asset (if applicable) */
  altText?: Maybe<Scalars['String']>;
  /** A caption to display below the asset (if applicable) */
  caption?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateAsset */
export type CreateAssetPayload = StandardMutationPayload & {
  __typename?: 'CreateAssetPayload';
  asset?: Maybe<AnyAsset>;
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateCollection */
export type CreateCollectionInput = {
  /** The parent of the new collection. This can be the encoded ID of a community or another collection. */
  parentId: Scalars['ID'];
  schemaVersionSlug?: Maybe<Scalars['String']>;
  /** Human readable title for the entity */
  title: Scalars['String'];
  /** A reference to an uploaded image in Tus. */
  thumbnail?: Maybe<UploadedFileInput>;
  /** Digital Object Identifier (see: https://doi.org) */
  doi?: Maybe<Scalars['String']>;
  /** A brief description of the entity's contents */
  summary?: Maybe<Scalars['String']>;
  /** The date the entity was published */
  publishedOn?: Maybe<Scalars['ISO8601Date']>;
  /** What level of visibility the entity has */
  visibility: EntityVisibility;
  /** If present, this is the timestamp an entity is visible after */
  visibleAfterAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** If present, this is the timestamp an entity is visible until */
  visibleUntilAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateCollection */
export type CreateCollectionPayload = StandardMutationPayload & {
  __typename?: 'CreateCollectionPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  collection?: Maybe<Collection>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateCommunity */
export type CreateCommunityInput = {
  /** Human readable title for the entity */
  title: Scalars['String'];
  /** The position the community occupies in the list */
  position?: Maybe<Scalars['Int']>;
  schemaVersionSlug?: Maybe<Scalars['String']>;
  /** A reference to an uploaded image in Tus. */
  thumbnail?: Maybe<UploadedFileInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateCommunity */
export type CreateCommunityPayload = StandardMutationPayload & {
  __typename?: 'CreateCommunityPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A representation of a successfully created community */
  community?: Maybe<Community>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateItem */
export type CreateItemInput = {
  /** The parent of the item. This can be the encoded ID of a collection or another item. */
  parentId: Scalars['ID'];
  schemaVersionSlug?: Maybe<Scalars['String']>;
  /** Human readable title for the entity */
  title: Scalars['String'];
  /** A reference to an uploaded image in Tus. */
  thumbnail?: Maybe<UploadedFileInput>;
  /** Digital Object Identifier (see: https://doi.org) */
  doi?: Maybe<Scalars['String']>;
  /** A brief description of the entity's contents */
  summary?: Maybe<Scalars['String']>;
  /** The date the entity was published */
  publishedOn?: Maybe<Scalars['ISO8601Date']>;
  /** What level of visibility the entity has */
  visibility: EntityVisibility;
  /** If present, this is the timestamp an entity is visible after */
  visibleAfterAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** If present, this is the timestamp an entity is visible until */
  visibleUntilAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateItem */
export type CreateItemPayload = StandardMutationPayload & {
  __typename?: 'CreateItemPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  /** A representation of a successfully created item */
  item?: Maybe<Item>;
};

/** Autogenerated input type of CreateOrdering */
export type CreateOrderingInput = {
  /** The entity to create the ordering for. */
  entityId: Scalars['ID'];
  /** A unique (within the context of the entity) identifier. Cannot be changed */
  identifier: Scalars['String'];
  /** A human readable label for the ordering */
  name?: Maybe<Scalars['String']>;
  /** Optional markdown content to display before the ordering's children */
  header?: Maybe<Scalars['String']>;
  /** Optional markdown content to display after the ordering's children */
  footer?: Maybe<Scalars['String']>;
  filter?: Maybe<OrderingFilterDefinitionInput>;
  select?: Maybe<OrderingSelectDefinitionInput>;
  order: Array<OrderDefinitionInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateOrdering */
export type CreateOrderingPayload = StandardMutationPayload & {
  __typename?: 'CreateOrderingPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  /** The created ordering */
  ordering?: Maybe<Ordering>;
};

/** Autogenerated input type of CreateOrganizationContributor */
export type CreateOrganizationContributorInput = {
  /** An email associated with the contributor */
  email?: Maybe<Scalars['String']>;
  /** A url associated with the contributor */
  url?: Maybe<Scalars['String']>;
  /** A summary of the contributor */
  bio?: Maybe<Scalars['String']>;
  links?: Maybe<Array<ContributorLinkInput>>;
  /** A reference to an upload in Tus. */
  image?: Maybe<UploadedFileInput>;
  /** The legal name of the organization */
  legalName?: Maybe<Scalars['String']>;
  /** Where the organization is located (if applicable) */
  location?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateOrganizationContributor */
export type CreateOrganizationContributorPayload = StandardMutationPayload & {
  __typename?: 'CreateOrganizationContributorPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created organization */
  contributor?: Maybe<OrganizationContributor>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreatePersonContributor */
export type CreatePersonContributorInput = {
  /** An email associated with the contributor */
  email?: Maybe<Scalars['String']>;
  /** A url associated with the contributor */
  url?: Maybe<Scalars['String']>;
  /** A summary of the contributor */
  bio?: Maybe<Scalars['String']>;
  links?: Maybe<Array<ContributorLinkInput>>;
  /** A reference to an upload in Tus. */
  image?: Maybe<UploadedFileInput>;
  givenName?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  affiliation?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreatePersonContributor */
export type CreatePersonContributorPayload = StandardMutationPayload & {
  __typename?: 'CreatePersonContributorPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created person */
  contributor?: Maybe<PersonContributor>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateRole */
export type CreateRoleInput = {
  name: Scalars['String'];
  accessControlList: Scalars['JSON'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateRole */
export type CreateRolePayload = StandardMutationPayload & {
  __typename?: 'CreateRolePayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  role?: Maybe<Role>;
};

export type DateProperty = ScalarProperty & {
  __typename?: 'DateProperty';
  date?: Maybe<Scalars['ISO8601Date']>;
  default?: Maybe<Scalars['ISO8601Date']>;
  fullPath: Scalars['String'];
  label: Scalars['String'];
  path: Scalars['String'];
  required: Scalars['Boolean'];
  type: Scalars['String'];
};

/** Autogenerated input type of DestroyCollection */
export type DestroyCollectionInput = {
  /** The ID for the collection to destroy */
  collectionId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of DestroyCollection */
export type DestroyCollectionPayload = StandardMutationPayload & DestroyMutationPayload & {
  __typename?: 'DestroyCollectionPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether or not the model was successfully destroyed. If false, check globalErrors */
  destroyed?: Maybe<Scalars['Boolean']>;
  /** The ID of the deleted model */
  destroyedId?: Maybe<Scalars['ID']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DestroyCommunity */
export type DestroyCommunityInput = {
  /** The ID for the community to destroy */
  communityId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of DestroyCommunity */
export type DestroyCommunityPayload = StandardMutationPayload & DestroyMutationPayload & {
  __typename?: 'DestroyCommunityPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether or not the model was successfully destroyed. If false, check globalErrors */
  destroyed?: Maybe<Scalars['Boolean']>;
  /** The ID of the deleted model */
  destroyedId?: Maybe<Scalars['ID']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DestroyContribution */
export type DestroyContributionInput = {
  contributionId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of DestroyContribution */
export type DestroyContributionPayload = StandardMutationPayload & DestroyMutationPayload & {
  __typename?: 'DestroyContributionPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether or not the model was successfully destroyed. If false, check globalErrors */
  destroyed?: Maybe<Scalars['Boolean']>;
  /** The ID of the deleted model */
  destroyedId?: Maybe<Scalars['ID']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DestroyContributor */
export type DestroyContributorInput = {
  contributorId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of DestroyContributor */
export type DestroyContributorPayload = StandardMutationPayload & DestroyMutationPayload & {
  __typename?: 'DestroyContributorPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether or not the model was successfully destroyed. If false, check globalErrors */
  destroyed?: Maybe<Scalars['Boolean']>;
  /** The ID of the deleted model */
  destroyedId?: Maybe<Scalars['ID']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DestroyEntityLink */
export type DestroyEntityLinkInput = {
  /** The ID for the EntityLink to destroy */
  entityLinkId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of DestroyEntityLink */
export type DestroyEntityLinkPayload = StandardMutationPayload & DestroyMutationPayload & {
  __typename?: 'DestroyEntityLinkPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether or not the model was successfully destroyed. If false, check globalErrors */
  destroyed?: Maybe<Scalars['Boolean']>;
  /** The ID of the deleted model */
  destroyedId?: Maybe<Scalars['ID']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DestroyItem */
export type DestroyItemInput = {
  /** The ID for the item to destroy */
  itemId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of DestroyItem */
export type DestroyItemPayload = StandardMutationPayload & DestroyMutationPayload & {
  __typename?: 'DestroyItemPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether or not the model was successfully destroyed. If false, check globalErrors */
  destroyed?: Maybe<Scalars['Boolean']>;
  /** The ID of the deleted model */
  destroyedId?: Maybe<Scalars['ID']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** This mutation destroys a model */
export type DestroyMutationPayload = {
  attributeErrors: Array<MutationAttributeError>;
  /** Whether or not the model was successfully destroyed. If false, check globalErrors */
  destroyed?: Maybe<Scalars['Boolean']>;
  /** The ID of the deleted model */
  destroyedId?: Maybe<Scalars['ID']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DestroyOrdering */
export type DestroyOrderingInput = {
  orderingId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of DestroyOrdering */
export type DestroyOrderingPayload = StandardMutationPayload & DestroyMutationPayload & {
  __typename?: 'DestroyOrderingPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether or not the model was successfully destroyed. If false, check globalErrors */
  destroyed?: Maybe<Scalars['Boolean']>;
  /** The ID of the deleted model */
  destroyedId?: Maybe<Scalars['ID']>;
  disabled?: Maybe<Scalars['Boolean']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

export type Direction =
  | 'ASCENDING'
  | 'DESCENDING'
  | '%future added value';

export type EmailProperty = ScalarProperty & {
  __typename?: 'EmailProperty';
  address?: Maybe<Scalars['String']>;
  defaultAddress?: Maybe<Scalars['String']>;
  fullPath: Scalars['String'];
  label: Scalars['String'];
  path: Scalars['String'];
  required: Scalars['Boolean'];
  type: Scalars['String'];
};

/** An entity that exists in the hierarchy. */
export type Entity = {
  /** Derived access control list */
  accessControlList?: Maybe<AccessControlList>;
  /** A polymorphic connection for access grants from an entity */
  allAccessGrants: AnyAccessGrantConnection;
  /** A list of allowed actions for the given user on this entity (and its descendants). */
  allowedActions: Array<Scalars['String']>;
  /** The role(s) that gave the permissions to access this resource, if any. */
  applicableRoles?: Maybe<Array<Role>>;
  /** Retrieve a list of user & role assignments for this entity */
  assignedUsers: ContextualPermissionConnection;
  /** Previous entries in the hierarchy */
  breadcrumbs: Array<EntityBreadcrumb>;
  /** The depth of the hierarchical entity, taking into account any parent types */
  hierarchicalDepth: Scalars['Int'];
  links: EntityLinkConnection;
  /** Look up an ordering for this entity by identifier */
  ordering?: Maybe<Ordering>;
  orderings: OrderingConnection;
  /** An array of hashes that can be requested to load in a context */
  permissions: Array<PermissionGrant>;
  schemaDefinition: SchemaDefinition;
  /** A list of schema properties associated with this instance or version. */
  schemaProperties: Array<AnySchemaProperty>;
  schemaVersion: SchemaVersion;
  /** A mapping of an entity's preview thumbnail */
  thumbnail?: Maybe<AssetPreview>;
};


/** An entity that exists in the hierarchy. */
export type EntityAllAccessGrantsArgs = {
  subject?: Maybe<AccessGrantSubjectFilter>;
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An entity that exists in the hierarchy. */
export type EntityAssignedUsersArgs = {
  order?: Maybe<ContextualPermissionOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An entity that exists in the hierarchy. */
export type EntityLinksArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An entity that exists in the hierarchy. */
export type EntityOrderingArgs = {
  identifier: Scalars['String'];
};


/** An entity that exists in the hierarchy. */
export type EntityOrderingsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

export type EntityBreadcrumb = Node & {
  __typename?: 'EntityBreadcrumb';
  crumb: AnyEntity;
  depth: Scalars['Int'];
  id: Scalars['ID'];
  kind: EntityKind;
  label: Scalars['String'];
  slug: Scalars['String'];
};

/** An enumeration of the different kinds of hierarchical entities */
export type EntityKind =
  | 'COMMUNITY'
  | 'COLLECTION'
  | 'ITEM'
  | '%future added value';

/** A link between different entities */
export type EntityLink = Node & Sluggable & {
  __typename?: 'EntityLink';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  operator: EntityLinkOperator;
  scope: EntityLinkScope;
  slug: Scalars['Slug'];
  source: AnyEntity;
  sourceCollection?: Maybe<Collection>;
  sourceCommunity?: Maybe<Community>;
  sourceItem?: Maybe<Item>;
  target: AnyEntity;
  targetCollection?: Maybe<Collection>;
  targetCommunity?: Maybe<Community>;
  targetItem?: Maybe<Item>;
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for EntityLink. */
export type EntityLinkConnection = Paginated & {
  __typename?: 'EntityLinkConnection';
  /** A list of edges. */
  edges: Array<EntityLinkEdge>;
  /** A list of nodes. */
  nodes: Array<EntityLink>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EntityLinkEdge = {
  __typename?: 'EntityLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: EntityLink;
};

/** A link operator describes how a source is linked to its target */
export type EntityLinkOperator =
  | 'CONTAINS'
  | 'REFERENCES'
  | '%future added value';

/** A link scope succinctly describes the source and target types */
export type EntityLinkScope =
  /** A link to a community from another community */
  | 'COMMUNITY_LINKED_COMMUNITY'
  /** A link to a collection not directly owned by a community */
  | 'COMMUNITY_LINKED_COLLECTION'
  /** A link to an item from a community */
  | 'COMMUNITY_LINKED_ITEM'
  /** A link to a community from a collection */
  | 'COLLECTION_LINKED_COMMUNITY'
  /** A link to a collection from another collection */
  | 'COLLECTION_LINKED_COLLECTION'
  /** A link to an item from a community */
  | 'COLLECTION_LINKED_ITEM'
  /** A link to a community from an item */
  | 'ITEM_LINKED_COMMUNITY'
  /** A link to a collection from an item */
  | 'ITEM_LINKED_COLLECTION'
  /** A link to an item from another item */
  | 'ITEM_LINKED_ITEM'
  | '%future added value';

export type EntityPermissionFilter =
  | 'READ_ONLY'
  | 'CRUD'
  | '%future added value';

/** The level of visibility an entity can have */
export type EntityVisibility =
  | 'VISIBLE'
  | 'HIDDEN'
  | 'LIMITED'
  | '%future added value';

export type ExposesPermissions = {
  /** A list of allowed actions for the given user on this entity (and its descendants). */
  allowedActions: Array<Scalars['String']>;
  /** An array of hashes that can be requested to load in a context */
  permissions: Array<PermissionGrant>;
};

export type FloatProperty = ScalarProperty & {
  __typename?: 'FloatProperty';
  defaultFloat?: Maybe<Scalars['Float']>;
  floatValue?: Maybe<Scalars['Float']>;
  fullPath: Scalars['String'];
  label: Scalars['String'];
  path: Scalars['String'];
  required: Scalars['Boolean'];
  type: Scalars['String'];
};

/** Autogenerated input type of GrantAccess */
export type GrantAccessInput = {
  entityId: Scalars['ID'];
  roleId: Scalars['ID'];
  userId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of GrantAccess */
export type GrantAccessPayload = StandardMutationPayload & {
  __typename?: 'GrantAccessPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  entity?: Maybe<AnyEntity>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Whether or not access was granted */
  granted?: Maybe<Scalars['Boolean']>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

export type GroupProperty = SchemaProperty & {
  __typename?: 'GroupProperty';
  fullPath: Scalars['String'];
  legend?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  properties: Array<AnyScalarProperty>;
  required: Scalars['Boolean'];
  type: Scalars['String'];
};

export type HasSchemaProperties = {
  /** A list of schema properties associated with this instance or version. */
  schemaProperties: Array<AnySchemaProperty>;
};

/** A hierarchical entity, like a collection or an item. */
export type HierarchicalEntry = {
  createdAt: Scalars['ISO8601DateTime'];
  /** The Digital Object Identifier for this entity. See https://doi.org */
  doi?: Maybe<Scalars['String']>;
  hidden: Scalars['Boolean'];
  /** If present, this is the timestamp the entity was hidden at */
  hiddenAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** A machine-readable identifier for the entity. Not presently used, but will be necessary for synchronizing with upstream providers. */
  identifier: Scalars['String'];
  leaf: Scalars['Boolean'];
  /** The date the entity was published on, if present */
  publishedOn?: Maybe<Scalars['ISO8601Date']>;
  root: Scalars['Boolean'];
  /** A description of the contents of the entity */
  summary?: Maybe<Scalars['String']>;
  /** A human-readable title for the entity */
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
  /** If an entity is available in the frontend */
  visibility: EntityVisibility;
  visible: Scalars['Boolean'];
  /** If present, this is the timestamp an entity is visible after */
  visibleAfterAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** If present, this is the timestamp an entity is visible until */
  visibleUntilAt?: Maybe<Scalars['ISO8601DateTime']>;
};



export type IntegerProperty = ScalarProperty & {
  __typename?: 'IntegerProperty';
  defaultInteger?: Maybe<Scalars['Int']>;
  fullPath: Scalars['String'];
  integerValue?: Maybe<Scalars['Int']>;
  label: Scalars['String'];
  path: Scalars['String'];
  required: Scalars['Boolean'];
  type: Scalars['String'];
};

/** An item that belongs to a collection */
export type Item = Accessible & Entity & HierarchicalEntry & Contributable & HasSchemaProperties & Attachable & SchemaInstance & Node & Sluggable & {
  __typename?: 'Item';
  /** Derived access control list */
  accessControlList?: Maybe<AccessControlList>;
  accessGrants: AnyCollectionAccessGrantConnection;
  /** A polymorphic connection for access grants from an entity */
  allAccessGrants: AnyAccessGrantConnection;
  /** A list of allowed actions for the given user on this entity (and its descendants). */
  allowedActions: Array<Scalars['String']>;
  /** The role(s) that gave the permissions to access this resource, if any. */
  applicableRoles?: Maybe<Array<Role>>;
  /** Assets owned by this entity */
  assets: AnyAssetConnection;
  /** Retrieve a list of user & role assignments for this entity */
  assignedUsers: ContextualPermissionConnection;
  /** Previous entries in the hierarchy */
  breadcrumbs: Array<EntityBreadcrumb>;
  /** @deprecated Use Item.items */
  children: ItemConnection;
  collection: Collection;
  community: Community;
  contributions: ItemContributionConnection;
  /** Contributors to this element */
  contributors: AnyContributorConnection;
  createdAt: Scalars['ISO8601DateTime'];
  /** The Digital Object Identifier for this entity. See https://doi.org */
  doi?: Maybe<Scalars['String']>;
  hidden: Scalars['Boolean'];
  /** If present, this is the timestamp the entity was hidden at */
  hiddenAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** The depth of the hierarchical entity, taking into account any parent types */
  hierarchicalDepth: Scalars['Int'];
  id: Scalars['ID'];
  /** A machine-readable identifier for the entity. Not presently used, but will be necessary for synchronizing with upstream providers. */
  identifier: Scalars['String'];
  items: ItemConnection;
  leaf: Scalars['Boolean'];
  links: EntityLinkConnection;
  /** Look up an ordering for this entity by identifier */
  ordering?: Maybe<Ordering>;
  orderings: OrderingConnection;
  parent?: Maybe<ItemParent>;
  /** An array of hashes that can be requested to load in a context */
  permissions: Array<PermissionGrant>;
  /** The date the entity was published on, if present */
  publishedOn?: Maybe<Scalars['ISO8601Date']>;
  root: Scalars['Boolean'];
  schemaDefinition: SchemaDefinition;
  /** The context for our schema instance. Includes form values and necessary referents. */
  schemaInstanceContext: SchemaInstanceContext;
  /** A list of schema properties associated with this instance or version. */
  schemaProperties: Array<AnySchemaProperty>;
  schemaVersion: SchemaVersion;
  slug: Scalars['Slug'];
  /** A description of the contents of the entity */
  summary?: Maybe<Scalars['String']>;
  /** A mapping of an entity's preview thumbnail */
  thumbnail?: Maybe<AssetPreview>;
  /** A human-readable title for the entity */
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
  /** Access grants for specific users */
  userAccessGrants: UserCollectionAccessGrantConnection;
  /** Not presently used */
  userGroupAccessGrants: UserGroupCollectionAccessGrantConnection;
  /** If an entity is available in the frontend */
  visibility: EntityVisibility;
  visible: Scalars['Boolean'];
  /** If present, this is the timestamp an entity is visible after */
  visibleAfterAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** If present, this is the timestamp an entity is visible until */
  visibleUntilAt?: Maybe<Scalars['ISO8601DateTime']>;
};


/** An item that belongs to a collection */
export type ItemAccessGrantsArgs = {
  subject?: Maybe<AccessGrantSubjectFilter>;
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An item that belongs to a collection */
export type ItemAllAccessGrantsArgs = {
  subject?: Maybe<AccessGrantSubjectFilter>;
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An item that belongs to a collection */
export type ItemAssetsArgs = {
  order?: Maybe<SimpleOrder>;
  kind?: Maybe<AssetKindFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An item that belongs to a collection */
export type ItemAssignedUsersArgs = {
  order?: Maybe<ContextualPermissionOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An item that belongs to a collection */
export type ItemChildrenArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** An item that belongs to a collection */
export type ItemContributionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An item that belongs to a collection */
export type ItemContributorsArgs = {
  order?: Maybe<SimpleOrder>;
  kind?: Maybe<ContributorFilterKind>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An item that belongs to a collection */
export type ItemItemsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An item that belongs to a collection */
export type ItemLinksArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An item that belongs to a collection */
export type ItemOrderingArgs = {
  identifier: Scalars['String'];
};


/** An item that belongs to a collection */
export type ItemOrderingsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An item that belongs to a collection */
export type ItemUserAccessGrantsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An item that belongs to a collection */
export type ItemUserGroupAccessGrantsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** The connection type for Item. */
export type ItemConnection = Paginated & {
  __typename?: 'ItemConnection';
  /** A list of edges. */
  edges: Array<ItemEdge>;
  /** A list of nodes. */
  nodes: Array<Item>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** A contribution to an item */
export type ItemContribution = Contribution & Node & Sluggable & {
  __typename?: 'ItemContribution';
  /** A potentially-overridden value from person contributors */
  affiliation?: Maybe<Scalars['String']>;
  contributor: AnyContributor;
  contributorKind: ContributorKind;
  createdAt: Scalars['ISO8601DateTime'];
  /** A potentially-overridden display name value for all contributor types */
  displayName: Scalars['String'];
  id: Scalars['ID'];
  item: Item;
  /** A potentially-overridden value from organization contributors */
  location?: Maybe<Scalars['String']>;
  metadata: ContributionMetadata;
  /** An arbitrary text value describing the role the contributor had */
  role?: Maybe<Scalars['String']>;
  slug: Scalars['Slug'];
  /** A potentially-overridden value from person contributors */
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for ItemContribution. */
export type ItemContributionConnection = Paginated & {
  __typename?: 'ItemContributionConnection';
  /** A list of edges. */
  edges: Array<ItemContributionEdge>;
  /** A list of nodes. */
  nodes: Array<ItemContribution>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ItemContributionEdge = {
  __typename?: 'ItemContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ItemContribution;
};

/** An edge in a connection. */
export type ItemEdge = {
  __typename?: 'ItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Item;
};

export type ItemParent = Collection | Item | { __typename?: "%other" };


/** Autogenerated input type of LinkEntity */
export type LinkEntityInput = {
  /** The ID for the source entity */
  sourceId: Scalars['ID'];
  /** The ID for the target entity */
  targetId: Scalars['ID'];
  /** The 'type' of link */
  operator: EntityLinkOperator;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of LinkEntity */
export type LinkEntityPayload = StandardMutationPayload & {
  __typename?: 'LinkEntityPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  /** The created or updated link, if applicable */
  link?: Maybe<EntityLink>;
};

export type MarkdownProperty = ScalarProperty & {
  __typename?: 'MarkdownProperty';
  content?: Maybe<Scalars['String']>;
  default?: Maybe<Scalars['String']>;
  fullPath: Scalars['String'];
  label: Scalars['String'];
  path: Scalars['String'];
  required: Scalars['Boolean'];
  type: Scalars['String'];
};

export type MultiselectProperty = ScalarProperty & OptionableProperty & {
  __typename?: 'MultiselectProperty';
  defaultSelections?: Maybe<Array<Scalars['String']>>;
  fullPath: Scalars['String'];
  label: Scalars['String'];
  options: Array<SelectOption>;
  path: Scalars['String'];
  required: Scalars['Boolean'];
  selections?: Maybe<Array<Scalars['String']>>;
  type: Scalars['String'];
};

/** The entry point for making changes to the data within the WDP API. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Change a schema version for an entity. */
  alterSchemaVersion?: Maybe<AlterSchemaVersionPayload>;
  applySchemaProperties?: Maybe<ApplySchemaPropertiesPayload>;
  /** Associate an uploaded asset (already present in the Tus cache store) with an entity. */
  createAsset?: Maybe<CreateAssetPayload>;
  createCollection?: Maybe<CreateCollectionPayload>;
  /** Create a community */
  createCommunity?: Maybe<CreateCommunityPayload>;
  /** Create an item */
  createItem?: Maybe<CreateItemPayload>;
  /** Create an ordering for an entity */
  createOrdering?: Maybe<CreateOrderingPayload>;
  /** Create an organization contributor */
  createOrganizationContributor?: Maybe<CreateOrganizationContributorPayload>;
  /** Create a contributor */
  createPersonContributor?: Maybe<CreatePersonContributorPayload>;
  /**
   * Create a global role, with a set of permissions, that can be used to grant access to various parts of the hierarchy
   * in a granular fashion.
   */
  createRole?: Maybe<CreateRolePayload>;
  /** Destroy a collection by ID. */
  destroyCollection?: Maybe<DestroyCollectionPayload>;
  /** Destroy a community by ID. */
  destroyCommunity?: Maybe<DestroyCommunityPayload>;
  /** Destroy a Contribution by ID. */
  destroyContribution?: Maybe<DestroyContributionPayload>;
  /** Destroy a contributor by ID. */
  destroyContributor?: Maybe<DestroyContributorPayload>;
  /** Destroy an EntityLink by ID. */
  destroyEntityLink?: Maybe<DestroyEntityLinkPayload>;
  /** Destroy an item by ID. */
  destroyItem?: Maybe<DestroyItemPayload>;
  /** Destroy (or disable a schema-inherited) ordering. */
  destroyOrdering?: Maybe<DestroyOrderingPayload>;
  /** Grant access to a specific hierarchical entity */
  grantAccess?: Maybe<GrantAccessPayload>;
  /** Link two entities together */
  linkEntity?: Maybe<LinkEntityPayload>;
  /**
   * Reassign the collection to another point in the hierarchy.
   *
   * This will update all child collections and descended items, if need be.
   */
  reparentCollection?: Maybe<ReparentCollectionPayload>;
  /**
   * Reassign the item to another point in the hierarchy.
   *
   * This will also update any descendant items, if need be.
   */
  reparentItem?: Maybe<ReparentItemPayload>;
  /**
   * Reset an ordering to "factory" settings. For schema-inherited orderings,
   * this will reload its definition from the schema definition. For custom
   * orderings, this will load minimal defaults.
   */
  resetOrdering?: Maybe<ResetOrderingPayload>;
  /** Revoke access from a specific hierarchical entity */
  revokeAccess?: Maybe<RevokeAccessPayload>;
  /** Update a collection */
  updateCollection?: Maybe<UpdateCollectionPayload>;
  /** Update a community */
  updateCommunity?: Maybe<UpdateCommunityPayload>;
  /** Update a Contribution by ID. */
  updateContribution?: Maybe<UpdateContributionPayload>;
  /** Update an item */
  updateItem?: Maybe<UpdateItemPayload>;
  /** Update an ordering by ID */
  updateOrdering?: Maybe<UpdateOrderingPayload>;
  /** Update an organization contributor */
  updateOrganizationContributor?: Maybe<UpdateOrganizationContributorPayload>;
  /** Update a person contributor */
  updatePersonContributor?: Maybe<UpdatePersonContributorPayload>;
  /** Update the name or permissions for a given role. */
  updateRole?: Maybe<UpdateRolePayload>;
  /**
   * Upsert a Contribution by contributable & contributor ID. It will override any
   * existing contributions for the same contributor on the same entity.
   */
  upsertContribution?: Maybe<UpsertContributionPayload>;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationAlterSchemaVersionArgs = {
  input: AlterSchemaVersionInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationApplySchemaPropertiesArgs = {
  input: ApplySchemaPropertiesInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationCreateAssetArgs = {
  input: CreateAssetInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationCreateCollectionArgs = {
  input: CreateCollectionInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationCreateCommunityArgs = {
  input: CreateCommunityInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationCreateItemArgs = {
  input: CreateItemInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationCreateOrderingArgs = {
  input: CreateOrderingInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationCreateOrganizationContributorArgs = {
  input: CreateOrganizationContributorInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationCreatePersonContributorArgs = {
  input: CreatePersonContributorInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationCreateRoleArgs = {
  input: CreateRoleInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationDestroyCollectionArgs = {
  input: DestroyCollectionInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationDestroyCommunityArgs = {
  input: DestroyCommunityInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationDestroyContributionArgs = {
  input: DestroyContributionInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationDestroyContributorArgs = {
  input: DestroyContributorInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationDestroyEntityLinkArgs = {
  input: DestroyEntityLinkInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationDestroyItemArgs = {
  input: DestroyItemInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationDestroyOrderingArgs = {
  input: DestroyOrderingInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationGrantAccessArgs = {
  input: GrantAccessInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationLinkEntityArgs = {
  input: LinkEntityInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationReparentCollectionArgs = {
  input: ReparentCollectionInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationReparentItemArgs = {
  input: ReparentItemInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationResetOrderingArgs = {
  input: ResetOrderingInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationRevokeAccessArgs = {
  input: RevokeAccessInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpdateCollectionArgs = {
  input: UpdateCollectionInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpdateCommunityArgs = {
  input: UpdateCommunityInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpdateContributionArgs = {
  input: UpdateContributionInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpdateItemArgs = {
  input: UpdateItemInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpdateOrderingArgs = {
  input: UpdateOrderingInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpdateOrganizationContributorArgs = {
  input: UpdateOrganizationContributorInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpdatePersonContributorArgs = {
  input: UpdatePersonContributorInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpdateRoleArgs = {
  input: UpdateRoleInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpsertContributionArgs = {
  input: UpsertContributionInput;
};

/** An error for a specific attribute in a mutationintended for use with react-hook-form and similarly shaped structures */
export type MutationAttributeError = {
  __typename?: 'MutationAttributeError';
  /** The accumulated messages for this combination of path and type */
  messages: Array<Scalars['String']>;
  /** The attribute that should have the error */
  path: Scalars['String'];
  /** A grouping type for the attribute */
  type: Scalars['String'];
};

export type MutationErrorScope =
  | 'GLOBAL'
  | 'ATTRIBUTE'
  | '%future added value';

/** An error that encapsulates the entire mutation input and is not tied to a specific input field. */
export type MutationGlobalError = {
  __typename?: 'MutationGlobalError';
  /** The actual message */
  message: Scalars['String'];
  type: Scalars['String'];
};

/** An object with an ID. */
export type Node = {
  /** ID of the object. */
  id: Scalars['ID'];
};

/** The priority for NULL values when sorting */
export type NullOrderPriority =
  | 'LAST'
  | 'FIRST'
  | '%future added value';

export type OptionableProperty = {
  options: Array<SelectOption>;
};

/** Ordering for a specific column */
export type OrderDefinitionInput = {
  path: Scalars['String'];
  direction?: Maybe<Direction>;
  nulls?: Maybe<NullOrderPriority>;
};

/** An ordering that belongs to an entity and arranges its children in a pre-configured way */
export type Ordering = Node & Sluggable & {
  __typename?: 'Ordering';
  children: OrderingEntryConnection;
  createdAt: Scalars['ISO8601DateTime'];
  /** Whether the ordering has been disabledorderings inherited from schemas will be disabled if deleted. */
  disabled: Scalars['Boolean'];
  /** The time the ordering was disabled, if applicable */
  disabledAt?: Maybe<Scalars['ISO8601Date']>;
  /** The entity that owns the ordering */
  entity: AnyEntity;
  /** Optional markdown content to render after the children */
  footer?: Maybe<Scalars['String']>;
  /** Optional markdown content to render before the children */
  header?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** A unique identifier for the ordering within the context of its parent entity. */
  identifier: Scalars['String'];
  /** Whether the ordering was inherited from its entity's schema definition */
  inheritedFromSchema: Scalars['Boolean'];
  /** An optional, human-readable name for the ordering */
  name?: Maybe<Scalars['String']>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};


/** An ordering that belongs to an entity and arranges its children in a pre-configured way */
export type OrderingChildrenArgs = {
  order?: Maybe<PositionDirection>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** The connection type for Ordering. */
export type OrderingConnection = Paginated & {
  __typename?: 'OrderingConnection';
  /** A list of edges. */
  edges: Array<OrderingEdge>;
  /** A list of nodes. */
  nodes: Array<Ordering>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type OrderingDirectSelection =
  | 'NONE'
  | 'CHILDREN'
  | 'DESCENDANTS'
  | '%future added value';

/** An edge in a connection. */
export type OrderingEdge = {
  __typename?: 'OrderingEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Ordering;
};

/** An entry within an ordering, it can refer to an entity or an entity link */
export type OrderingEntry = Node & Sluggable & {
  __typename?: 'OrderingEntry';
  createdAt: Scalars['ISO8601DateTime'];
  entry: AnyOrderingEntry;
  id: Scalars['ID'];
  /** The parent ordering */
  ordering: Ordering;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for OrderingEntry. */
export type OrderingEntryConnection = Paginated & {
  __typename?: 'OrderingEntryConnection';
  /** A list of edges. */
  edges: Array<OrderingEntryEdge>;
  /** A list of nodes. */
  nodes: Array<OrderingEntry>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type OrderingEntryEdge = {
  __typename?: 'OrderingEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: OrderingEntry;
};

export type OrderingFilterDefinitionInput = {
  schemas?: Maybe<Array<Scalars['String']>>;
};

export type OrderingSelectDefinitionInput = {
  direct?: Maybe<OrderingDirectSelection>;
  links?: Maybe<OrderingSelectLinkDefinitionInput>;
};

export type OrderingSelectLinkDefinitionInput = {
  contains?: Maybe<Scalars['Boolean']>;
  references?: Maybe<Scalars['Boolean']>;
};

/** An organization that has made contributions */
export type OrganizationContributor = Contributor & Node & Sluggable & {
  __typename?: 'OrganizationContributor';
  bio?: Maybe<Scalars['String']>;
  collectionContributions: CollectionContributionConnection;
  createdAt: Scalars['ISO8601DateTime'];
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  identifier: Scalars['String'];
  /** An optional image associated with the contributor */
  image?: Maybe<AssetPreview>;
  itemContributions: ItemContributionConnection;
  kind: ContributorKind;
  legalName?: Maybe<Scalars['String']>;
  links: Array<ContributorLink>;
  location?: Maybe<Scalars['String']>;
  prefix?: Maybe<Scalars['String']>;
  slug: Scalars['Slug'];
  suffix?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
  url?: Maybe<Scalars['String']>;
};


/** An organization that has made contributions */
export type OrganizationContributorCollectionContributionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An organization that has made contributions */
export type OrganizationContributorItemContributionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** Determines the direction that page-number based pagination should flow */
export type PageDirection =
  | 'FORWARDS'
  | 'BACKWARDS'
  | '%future added value';

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** The page (if page-based pagination is supported and one was provided, does not introspect a value with cursor-based pagination) */
  page?: Maybe<Scalars['Int']>;
  /** The total number of pages available to the connection (if page-based pagination supported and a page was provided) */
  pageCount?: Maybe<Scalars['Int']>;
  /** The number of edges/nodes per page (if page-based pagination supported and a page was provided) */
  perPage?: Maybe<Scalars['Int']>;
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
  /** The total number of nodes available to this connection, constrained by applied filters (if any) */
  totalCount: Scalars['Int'];
  /** The total number of nodes available to this connection, independent of any filters */
  totalUnfilteredCount: Scalars['Int'];
};

/** Connections can be paginated by cursor or number. */
export type Paginated = {
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** A grant of a specific permission within a specific scope */
export type PermissionGrant = {
  __typename?: 'PermissionGrant';
  allowed: Scalars['Boolean'];
  name: Scalars['String'];
  scope?: Maybe<Scalars['String']>;
};

/** A person that has made contributions */
export type PersonContributor = Contributor & Node & Sluggable & {
  __typename?: 'PersonContributor';
  affiliation?: Maybe<Scalars['String']>;
  bio?: Maybe<Scalars['String']>;
  collectionContributions: CollectionContributionConnection;
  createdAt: Scalars['ISO8601DateTime'];
  email?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  givenName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  identifier: Scalars['String'];
  /** An optional image associated with the contributor */
  image?: Maybe<AssetPreview>;
  itemContributions: ItemContributionConnection;
  kind: ContributorKind;
  links: Array<ContributorLink>;
  prefix?: Maybe<Scalars['String']>;
  slug: Scalars['Slug'];
  suffix?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
  url?: Maybe<Scalars['String']>;
};


/** A person that has made contributions */
export type PersonContributorCollectionContributionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A person that has made contributions */
export type PersonContributorItemContributionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** An enum that describes sorting nodes by position in ascending or descending order. */
export type PositionDirection =
  | 'ASCENDING'
  | 'DESCENDING'
  | '%future added value';

export type PreviewImage = {
  __typename?: 'PreviewImage';
  alt: Scalars['String'];
  dimensions: Array<Scalars['Int']>;
  height: Scalars['Int'];
  url: Scalars['String'];
  width: Scalars['Int'];
};

export type PreviewImageMap = {
  __typename?: 'PreviewImageMap';
  alt: Scalars['String'];
  dimensions: Array<Scalars['Int']>;
  height: Scalars['Int'];
  png?: Maybe<PreviewImage>;
  webp?: Maybe<PreviewImage>;
  width: Scalars['Int'];
};

/** When altering a schema version for an entity, there are various strategies that can be used to determine how to handle the provided properties. */
export type PropertyApplicationStrategy =
  /** If set to this value, property values will be validated and applied */
  | 'APPLY'
  /** If set to this value, property values will not be applied, and the entity will likely exist in an invalid state. */
  | 'SKIP'
  | '%future added value';

/** The entry point for retrieving data from within the WDP API. */
export type Query = {
  __typename?: 'Query';
  /** Retrieve all access grants */
  accessGrants: AnyAccessGrantConnection;
  /** Look up a collection by slug */
  collection?: Maybe<Collection>;
  /** Look up a collection contribution by slug */
  collectionContribution?: Maybe<CollectionContribution>;
  /** List all communities */
  communities: CommunityConnection;
  /** Look up a community by slug */
  community?: Maybe<Community>;
  /** Look up a contributor by slug */
  contributor?: Maybe<AnyContributor>;
  /** A list of all contributors in the system */
  contributors: AnyContributorConnection;
  /** Look up an item by slug */
  item?: Maybe<Item>;
  /** Look up an item contribution by slug */
  itemContribution?: Maybe<ItemContribution>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Fetches a list of objects given a list of IDs. */
  nodes: Array<Maybe<Node>>;
  /** List all roles */
  roles: RoleConnection;
  /** Look up a schema definition by slug */
  schemaDefinition?: Maybe<SchemaDefinition>;
  /** List all schema definitions */
  schemaDefinitions: SchemaDefinitionConnection;
  /** Look up a schema version by slug */
  schemaVersion?: Maybe<SchemaVersion>;
  /** List all options for schema versions */
  schemaVersionOptions: Array<SchemaVersionOption>;
  /** List all schema versions */
  schemaVersions: SchemaVersionConnection;
  /** Look up a user by slug */
  user?: Maybe<User>;
  /** A list of all users in the system */
  users: UserConnection;
  /** The currently authenticated user. AKA: you */
  viewer: User;
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryAccessGrantsArgs = {
  entity?: Maybe<AccessGrantEntityFilter>;
  subject?: Maybe<AccessGrantSubjectFilter>;
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryCollectionArgs = {
  slug: Scalars['Slug'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryCollectionContributionArgs = {
  slug: Scalars['Slug'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryCommunitiesArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryCommunityArgs = {
  slug: Scalars['Slug'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryContributorArgs = {
  slug: Scalars['Slug'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryContributorsArgs = {
  order?: Maybe<SimpleOrder>;
  kind?: Maybe<ContributorFilterKind>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryItemArgs = {
  slug: Scalars['Slug'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryItemContributionArgs = {
  slug: Scalars['Slug'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryNodeArgs = {
  id: Scalars['ID'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryRolesArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** The entry point for retrieving data from within the WDP API. */
export type QuerySchemaDefinitionArgs = {
  slug: Scalars['Slug'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QuerySchemaDefinitionsArgs = {
  order?: Maybe<SimpleOrder>;
  namespace?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QuerySchemaVersionArgs = {
  slug: Scalars['Slug'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QuerySchemaVersionOptionsArgs = {
  kind?: Maybe<SchemaKind>;
  namespace?: Maybe<Scalars['String']>;
};


/** The entry point for retrieving data from within the WDP API. */
export type QuerySchemaVersionsArgs = {
  namespace?: Maybe<Scalars['String']>;
  order?: Maybe<SchemaVersionOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryUserArgs = {
  slug: Scalars['Slug'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryUsersArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** Autogenerated input type of ReparentCollection */
export type ReparentCollectionInput = {
  /** The collection in need of a new parent */
  collectionId: Scalars['ID'];
  /** The id for the collection's new parent. This can be a community or another collection. */
  parentId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of ReparentCollection */
export type ReparentCollectionPayload = StandardMutationPayload & {
  __typename?: 'ReparentCollectionPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  collection?: Maybe<Collection>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ReparentItem */
export type ReparentItemInput = {
  /** The collection in need of a new parent */
  itemId: Scalars['ID'];
  /** The id for the item's new parent. This can be a collection or another item. */
  parentId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of ReparentItem */
export type ReparentItemPayload = StandardMutationPayload & {
  __typename?: 'ReparentItemPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  item?: Maybe<Item>;
};

/** Autogenerated input type of ResetOrdering */
export type ResetOrderingInput = {
  orderingId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of ResetOrdering */
export type ResetOrderingPayload = StandardMutationPayload & {
  __typename?: 'ResetOrderingPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  ordering?: Maybe<Ordering>;
};

/** Autogenerated input type of RevokeAccess */
export type RevokeAccessInput = {
  entityId: Scalars['ID'];
  roleId: Scalars['ID'];
  userId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of RevokeAccess */
export type RevokeAccessPayload = StandardMutationPayload & {
  __typename?: 'RevokeAccessPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  entity?: Maybe<AnyEntity>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  /** Whether or not access was revoked */
  revoked?: Maybe<Scalars['Boolean']>;
};

/** A named role in the WDP API */
export type Role = Node & Sluggable & {
  __typename?: 'Role';
  /** The access control list for this specific role */
  accessControlList: AccessControlList;
  /** A list of action names that have been granted to this role */
  allowedActions: Array<Scalars['String']>;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  /** The human readable name of the role within the system */
  name: Scalars['String'];
  /**
   * Surfaced from the accessControlList for convenience, these are returned as
   * an array that allows a user to check for the state of all possible roles
   * without having to specify them explicitly in the GraphQL request
   */
  permissions: Array<PermissionGrant>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for Role. */
export type RoleConnection = Paginated & {
  __typename?: 'RoleConnection';
  /** A list of edges. */
  edges: Array<RoleEdge>;
  /** A list of nodes. */
  nodes: Array<Role>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RoleEdge = {
  __typename?: 'RoleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Role;
};

export type ScalarProperty = {
  fullPath: Scalars['String'];
  label: Scalars['String'];
  path: Scalars['String'];
  required: Scalars['Boolean'];
  type: Scalars['String'];
};

export type SchemaDefinition = Node & Sluggable & {
  __typename?: 'SchemaDefinition';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  identifier: Scalars['String'];
  kind: SchemaKind;
  name: Scalars['String'];
  namespace: Scalars['String'];
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for SchemaDefinition. */
export type SchemaDefinitionConnection = Paginated & {
  __typename?: 'SchemaDefinitionConnection';
  /** A list of edges. */
  edges: Array<SchemaDefinitionEdge>;
  /** A list of nodes. */
  nodes: Array<SchemaDefinition>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SchemaDefinitionEdge = {
  __typename?: 'SchemaDefinitionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: SchemaDefinition;
};

/**
 * Being an instance that implements a schema version with strongly-typed properties.
 * Overlaps with Entity, but intended for focused access to just the properties
 * and the necessary context.
 */
export type SchemaInstance = {
  /** The context for our schema instance. Includes form values and necessary referents. */
  schemaInstanceContext: SchemaInstanceContext;
  /** A list of schema properties associated with this instance or version. */
  schemaProperties: Array<AnySchemaProperty>;
};

/** A context that describes the current state of the form */
export type SchemaInstanceContext = {
  __typename?: 'SchemaInstanceContext';
  assets: Array<AssetSelectOption>;
  contributors: Array<ContributorSelectOption>;
  /** Not yet populated. May be used in the future. */
  defaultValues: Scalars['JSON'];
  /** The entity ID for this schema instance. */
  entityId: Scalars['ID'];
  /** The values for the schema form on this instance */
  fieldValues: Scalars['JSON'];
  /** The slug for the current schema version */
  schemaVersionSlug: Scalars['String'];
  /** Information about the validity of the schema instance */
  validity?: Maybe<SchemaInstanceValidation>;
};

export type SchemaInstanceValidation = {
  __typename?: 'SchemaInstanceValidation';
  errors: Array<SchemaValueError>;
  valid: Scalars['Boolean'];
  validatedAt: Scalars['ISO8601DateTime'];
};

export type SchemaKind =
  | 'COMMUNITY'
  | 'COLLECTION'
  | 'ITEM'
  /** Presently unused */
  | 'METADATA'
  | '%future added value';

export type SchemaProperty = {
  fullPath: Scalars['String'];
  path: Scalars['String'];
  type: Scalars['String'];
};

/** An error that stems from trying to apply an invalid schema value. */
export type SchemaValueError = {
  __typename?: 'SchemaValueError';
  /**
   * An error with the entire set of values
   * @deprecated Not presently used: see globalErrors
   */
  base: Scalars['Boolean'];
  /** Whether this is a hint */
  hint: Scalars['Boolean'];
  /** A human-readable description of the error */
  message: Scalars['String'];
  /** Additional metadata attached to the error */
  metadata?: Maybe<Scalars['JSON']>;
  /** Which input value this error came from */
  path: Scalars['String'];
};

/** A specific version of a schema definition */
export type SchemaVersion = HasSchemaProperties & Node & Sluggable & {
  __typename?: 'SchemaVersion';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  identifier: Scalars['String'];
  kind: SchemaKind;
  name: Scalars['String'];
  namespace: Scalars['String'];
  number: Scalars['String'];
  schemaDefinition: SchemaDefinition;
  /** A list of schema properties associated with this instance or version. */
  schemaProperties: Array<AnySchemaProperty>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for SchemaVersion. */
export type SchemaVersionConnection = Paginated & {
  __typename?: 'SchemaVersionConnection';
  /** A list of edges. */
  edges: Array<SchemaVersionEdge>;
  /** A list of nodes. */
  nodes: Array<SchemaVersion>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SchemaVersionEdge = {
  __typename?: 'SchemaVersionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: SchemaVersion;
};

export type SchemaVersionOption = {
  __typename?: 'SchemaVersionOption';
  identifier: Scalars['String'];
  kind: SchemaKind;
  /** The label to display in a select box */
  label: Scalars['String'];
  name: Scalars['String'];
  namespace: Scalars['String'];
  schemaDefinition: SchemaDefinition;
  schemaVersion: SchemaVersion;
  /** The value to use in a select box */
  value: Scalars['String'];
};

/** Order schema versions by various factors */
export type SchemaVersionOrder =
  /** Order with newest versions at the top */
  | 'LATEST'
  /** Order with oldest versions at the top */
  | 'OLDEST'
  | '%future added value';

export type SelectOption = {
  __typename?: 'SelectOption';
  label: Scalars['String'];
  value: Scalars['String'];
};

export type SelectProperty = ScalarProperty & OptionableProperty & {
  __typename?: 'SelectProperty';
  defaultSelection?: Maybe<Scalars['String']>;
  fullPath: Scalars['String'];
  label: Scalars['String'];
  options: Array<SelectOption>;
  path: Scalars['String'];
  required: Scalars['Boolean'];
  selection?: Maybe<Scalars['String']>;
  type: Scalars['String'];
};

export type SimpleOrder =
  | 'RECENT'
  | 'OLDEST'
  | '%future added value';


/** Objects have a serialized slug for looking them up in the system and generating links without UUIDs */
export type Sluggable = {
  slug: Scalars['Slug'];
};

/** Most mutations implement this interface in their payload in order to offer a standardize response value */
export type StandardMutationPayload = {
  attributeErrors: Array<MutationAttributeError>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

export type StringProperty = ScalarProperty & {
  __typename?: 'StringProperty';
  content?: Maybe<Scalars['String']>;
  default?: Maybe<Scalars['String']>;
  fullPath: Scalars['String'];
  label: Scalars['String'];
  path: Scalars['String'];
  required: Scalars['Boolean'];
  type: Scalars['String'];
};

export type TagsProperty = ScalarProperty & {
  __typename?: 'TagsProperty';
  fullPath: Scalars['String'];
  label: Scalars['String'];
  path: Scalars['String'];
  required: Scalars['Boolean'];
  tags: Array<Scalars['String']>;
  type: Scalars['String'];
};

export type TimestampProperty = ScalarProperty & {
  __typename?: 'TimestampProperty';
  default?: Maybe<Scalars['ISO8601DateTime']>;
  fullPath: Scalars['String'];
  label: Scalars['String'];
  path: Scalars['String'];
  required: Scalars['Boolean'];
  timestamp?: Maybe<Scalars['ISO8601DateTime']>;
  type: Scalars['String'];
};

/** When retrieving a paginated connection of tree-like entities, this enum is used to delineate which class of nodes to retrieve. Usually, you only want roots, but two other possibilities are exposed. */
export type TreeNodeFilter =
  /** Fetch only nodes that are "roots": nodes that do not have a parent of the same type */
  | 'ROOTS_ONLY'
  /** Fetch all nodes that match other filters passed to the resolver */
  | 'ROOTS_AND_LEAVES'
  /** Fetch only nodes that are "leaves"; nodes that have a parent of the same type */
  | 'LEAVES_ONLY'
  | '%future added value';

export type UnknownProperty = ScalarProperty & {
  __typename?: 'UnknownProperty';
  default?: Maybe<Scalars['JSON']>;
  fullPath: Scalars['String'];
  label: Scalars['String'];
  path: Scalars['String'];
  required: Scalars['Boolean'];
  type: Scalars['String'];
  unknownValue?: Maybe<Scalars['JSON']>;
};

/** Autogenerated input type of UpdateCollection */
export type UpdateCollectionInput = {
  collectionId: Scalars['ID'];
  /** Human readable title for the entity */
  title: Scalars['String'];
  /** A reference to an uploaded image in Tus. */
  thumbnail?: Maybe<UploadedFileInput>;
  /** Digital Object Identifier (see: https://doi.org) */
  doi?: Maybe<Scalars['String']>;
  /** A brief description of the entity's contents */
  summary?: Maybe<Scalars['String']>;
  /** The date the entity was published */
  publishedOn?: Maybe<Scalars['ISO8601Date']>;
  /** What level of visibility the entity has */
  visibility: EntityVisibility;
  /** If present, this is the timestamp an entity is visible after */
  visibleAfterAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** If present, this is the timestamp an entity is visible until */
  visibleUntilAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** If set to true, this will clear the attachment thumbnail on this model. */
  clearThumbnail?: Maybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateCollection */
export type UpdateCollectionPayload = StandardMutationPayload & {
  __typename?: 'UpdateCollectionPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A new representation of the collection, on a successful update */
  collection?: Maybe<Collection>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateCommunity */
export type UpdateCommunityInput = {
  communityId: Scalars['ID'];
  /** The position the community occupies in the list */
  position?: Maybe<Scalars['Int']>;
  /** Human readable title for the entity */
  title: Scalars['String'];
  /** A reference to an uploaded image in Tus. */
  thumbnail?: Maybe<UploadedFileInput>;
  /** If set to true, this will clear the attachment thumbnail on this model. */
  clearThumbnail?: Maybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateCommunity */
export type UpdateCommunityPayload = StandardMutationPayload & {
  __typename?: 'UpdateCommunityPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A new representation of the community, on a succesful update */
  community?: Maybe<Community>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateContribution */
export type UpdateContributionInput = {
  contributionId: Scalars['ID'];
  /** An arbitrary text value that describes the kind of contribution */
  role?: Maybe<Scalars['String']>;
  metadata?: Maybe<ContributionMetadataInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateContribution */
export type UpdateContributionPayload = StandardMutationPayload & {
  __typename?: 'UpdateContributionPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contribution?: Maybe<AnyContribution>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateItem */
export type UpdateItemInput = {
  /** The item to update */
  itemId: Scalars['ID'];
  /** Human readable title for the entity */
  title: Scalars['String'];
  /** A reference to an uploaded image in Tus. */
  thumbnail?: Maybe<UploadedFileInput>;
  /** Digital Object Identifier (see: https://doi.org) */
  doi?: Maybe<Scalars['String']>;
  /** A brief description of the entity's contents */
  summary?: Maybe<Scalars['String']>;
  /** The date the entity was published */
  publishedOn?: Maybe<Scalars['ISO8601Date']>;
  /** What level of visibility the entity has */
  visibility: EntityVisibility;
  /** If present, this is the timestamp an entity is visible after */
  visibleAfterAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** If present, this is the timestamp an entity is visible until */
  visibleUntilAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** If set to true, this will clear the attachment thumbnail on this model. */
  clearThumbnail?: Maybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateItem */
export type UpdateItemPayload = StandardMutationPayload & {
  __typename?: 'UpdateItemPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  /** A new representation of the item, on a succesful update */
  item?: Maybe<Item>;
};

/** Autogenerated input type of UpdateOrdering */
export type UpdateOrderingInput = {
  /** The ID for the ordering to update */
  orderingId: Scalars['ID'];
  /** A human readable label for the ordering */
  name?: Maybe<Scalars['String']>;
  /** Optional markdown content to display before the ordering's children */
  header?: Maybe<Scalars['String']>;
  /** Optional markdown content to display after the ordering's children */
  footer?: Maybe<Scalars['String']>;
  filter?: Maybe<OrderingFilterDefinitionInput>;
  select?: Maybe<OrderingSelectDefinitionInput>;
  order: Array<OrderDefinitionInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateOrdering */
export type UpdateOrderingPayload = StandardMutationPayload & {
  __typename?: 'UpdateOrderingPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  /** The updated ordering */
  ordering?: Maybe<Ordering>;
};

/** Autogenerated input type of UpdateOrganizationContributor */
export type UpdateOrganizationContributorInput = {
  /** An email associated with the contributor */
  email?: Maybe<Scalars['String']>;
  /** A url associated with the contributor */
  url?: Maybe<Scalars['String']>;
  /** A summary of the contributor */
  bio?: Maybe<Scalars['String']>;
  links?: Maybe<Array<ContributorLinkInput>>;
  /** A reference to an upload in Tus. */
  image?: Maybe<UploadedFileInput>;
  /** The legal name of the organization */
  legalName?: Maybe<Scalars['String']>;
  /** Where the organization is located (if applicable) */
  location?: Maybe<Scalars['String']>;
  contributorId: Scalars['ID'];
  /** If set to true, this will clear the attachment image on this model. */
  clearImage?: Maybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateOrganizationContributor */
export type UpdateOrganizationContributorPayload = StandardMutationPayload & {
  __typename?: 'UpdateOrganizationContributorPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated organization */
  contributor?: Maybe<OrganizationContributor>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdatePersonContributor */
export type UpdatePersonContributorInput = {
  /** An email associated with the contributor */
  email?: Maybe<Scalars['String']>;
  /** A url associated with the contributor */
  url?: Maybe<Scalars['String']>;
  /** A summary of the contributor */
  bio?: Maybe<Scalars['String']>;
  links?: Maybe<Array<ContributorLinkInput>>;
  /** A reference to an upload in Tus. */
  image?: Maybe<UploadedFileInput>;
  givenName?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  affiliation?: Maybe<Scalars['String']>;
  contributorId: Scalars['ID'];
  /** If set to true, this will clear the attachment image on this model. */
  clearImage?: Maybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdatePersonContributor */
export type UpdatePersonContributorPayload = StandardMutationPayload & {
  __typename?: 'UpdatePersonContributorPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created person */
  contributor?: Maybe<PersonContributor>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateRole */
export type UpdateRoleInput = {
  roleId: Scalars['ID'];
  name: Scalars['String'];
  accessControlList: Scalars['JSON'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateRole */
export type UpdateRolePayload = StandardMutationPayload & {
  __typename?: 'UpdateRolePayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  role?: Maybe<Role>;
};


/** The name of a storage that can contain user uploads. There's only one option at present. */
export type UploadStorage =
  /** Temporary storage. Cleaned on a regular basis if uploads are not attached anywhere. */
  | 'CACHE'
  | '%future added value';

/** A definition for a file upload */
export type UploadedFileInput = {
  id: Scalars['UploadID'];
  /** The storage that contains the input. */
  storage?: Maybe<UploadStorage>;
  metadata?: Maybe<UploadedFileMetadataInput>;
};

/** File metadata to attach to the upload. */
export type UploadedFileMetadataInput = {
  /** The original filename, since Tus mangles them. */
  filename?: Maybe<Scalars['String']>;
  /**
   * The original content type. WDP will detect a real content type, so this can't be spoofed, but it can be helpful with generating
   * an initial asset with the correct kind.
   */
  mimeType?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpsertContribution */
export type UpsertContributionInput = {
  contributableId: Scalars['ID'];
  contributorId: Scalars['ID'];
  /** An arbitrary text value that describes the kind of contribution */
  role?: Maybe<Scalars['String']>;
  metadata?: Maybe<ContributionMetadataInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpsertContribution */
export type UpsertContributionPayload = StandardMutationPayload & {
  __typename?: 'UpsertContributionPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contribution?: Maybe<AnyContribution>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** A known or anonymous user in the system. Registration and management is primarily handled through the WDP Keycloak instance. */
export type User = AccessGrantSubject & ExposesPermissions & Node & Sluggable & {
  __typename?: 'User';
  /** All access grants for this user */
  accessGrants: AnyUserAccessGrantConnection;
  /** A polymorphic connection for access grants from a subject */
  allAccessGrants: AnyAccessGrantConnection;
  /** A list of allowed actions for the given user on this entity (and its descendants). */
  allowedActions: Array<Scalars['String']>;
  /** Is this an anonymous / unauthenticated user? */
  anonymous: Scalars['Boolean'];
  /** All access grants for this user on a collection */
  collectionAccessGrants: UserCollectionAccessGrantConnection;
  /** Query the collections this user has access to */
  collections: CollectionConnection;
  /** Query the communities this user has access to */
  communities: CommunityConnection;
  /** All access grants for this user on a community */
  communityAccessGrants: UserCommunityAccessGrantConnection;
  createdAt: Scalars['ISO8601DateTime'];
  /** A user's email. Depending on the upstream provider, this may not be set. */
  email?: Maybe<Scalars['String']>;
  /** Has this user's email been verified to work through Keycloak? */
  emailVerified: Scalars['Boolean'];
  /** Does this user have access to administer the entire instance? */
  globalAdmin: Scalars['Boolean'];
  id: Scalars['ID'];
  /** All access grants for this user on an item */
  itemAccessGrants: UserItemAccessGrantConnection;
  /** Query the items this user has access to */
  items: ItemConnection;
  /** The user's full provided name. Depending on the upstream provider, this may not be set. */
  name?: Maybe<Scalars['String']>;
  /** An array of hashes that can be requested to load in a context */
  permissions: Array<PermissionGrant>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
  /** Can this user upload anything at all? */
  uploadAccess: Scalars['Boolean'];
  /** If a user has any upload access, this token will allow them to do so. */
  uploadToken?: Maybe<Scalars['String']>;
  /** A unique username for the user. Depending on the upstream provider, this may not be set. */
  username?: Maybe<Scalars['String']>;
};


/** A known or anonymous user in the system. Registration and management is primarily handled through the WDP Keycloak instance. */
export type UserAccessGrantsArgs = {
  entity?: Maybe<AccessGrantEntityFilter>;
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A known or anonymous user in the system. Registration and management is primarily handled through the WDP Keycloak instance. */
export type UserAllAccessGrantsArgs = {
  entity?: Maybe<AccessGrantEntityFilter>;
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A known or anonymous user in the system. Registration and management is primarily handled through the WDP Keycloak instance. */
export type UserCollectionAccessGrantsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A known or anonymous user in the system. Registration and management is primarily handled through the WDP Keycloak instance. */
export type UserCollectionsArgs = {
  access?: Maybe<EntityPermissionFilter>;
  order?: Maybe<SimpleOrder>;
  schema?: Maybe<Array<Scalars['String']>>;
  nodeFilter?: Maybe<TreeNodeFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A known or anonymous user in the system. Registration and management is primarily handled through the WDP Keycloak instance. */
export type UserCommunitiesArgs = {
  access?: Maybe<EntityPermissionFilter>;
  order?: Maybe<SimpleOrder>;
  schema?: Maybe<Array<Scalars['String']>>;
  nodeFilter?: Maybe<TreeNodeFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A known or anonymous user in the system. Registration and management is primarily handled through the WDP Keycloak instance. */
export type UserCommunityAccessGrantsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A known or anonymous user in the system. Registration and management is primarily handled through the WDP Keycloak instance. */
export type UserItemAccessGrantsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A known or anonymous user in the system. Registration and management is primarily handled through the WDP Keycloak instance. */
export type UserItemsArgs = {
  access?: Maybe<EntityPermissionFilter>;
  order?: Maybe<SimpleOrder>;
  schema?: Maybe<Array<Scalars['String']>>;
  nodeFilter?: Maybe<TreeNodeFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** An access grant for a user */
export type UserAccessGrant = {
  /** The polymorphic entity to which access has been granted */
  entity: AnyEntity;
  /** The role the subject has been assigned */
  role: Role;
  /** The polymorphic subject that has been granted access */
  subject: AccessGrantSubject;
  /** The user which has been granted access */
  user: User;
};

/** An access grant for a user to a collection. */
export type UserCollectionAccessGrant = AccessGrant & UserAccessGrant & Node & Sluggable & {
  __typename?: 'UserCollectionAccessGrant';
  /** The collection to which a user has been granted access */
  collection: Collection;
  createdAt: Scalars['ISO8601DateTime'];
  /** The polymorphic entity to which access has been granted */
  entity: AnyEntity;
  id: Scalars['ID'];
  /** The role the subject has been assigned */
  role: Role;
  slug: Scalars['Slug'];
  /** The polymorphic subject that has been granted access */
  subject: AccessGrantSubject;
  updatedAt: Scalars['ISO8601DateTime'];
  /** The user which has been granted access */
  user: User;
};

/** The connection type for UserCollectionAccessGrant. */
export type UserCollectionAccessGrantConnection = Paginated & {
  __typename?: 'UserCollectionAccessGrantConnection';
  /** A list of edges. */
  edges: Array<UserCollectionAccessGrantEdge>;
  /** A list of nodes. */
  nodes: Array<UserCollectionAccessGrant>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UserCollectionAccessGrantEdge = {
  __typename?: 'UserCollectionAccessGrantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: UserCollectionAccessGrant;
};

/** An access grant for a user to a community. */
export type UserCommunityAccessGrant = AccessGrant & UserAccessGrant & Node & Sluggable & {
  __typename?: 'UserCommunityAccessGrant';
  /** The community to which a user has been granted access */
  community: Community;
  createdAt: Scalars['ISO8601DateTime'];
  /** The polymorphic entity to which access has been granted */
  entity: AnyEntity;
  id: Scalars['ID'];
  /** The role the subject has been assigned */
  role: Role;
  slug: Scalars['Slug'];
  /** The polymorphic subject that has been granted access */
  subject: AccessGrantSubject;
  updatedAt: Scalars['ISO8601DateTime'];
  /** The user which has been granted access */
  user: User;
};

/** The connection type for UserCommunityAccessGrant. */
export type UserCommunityAccessGrantConnection = Paginated & {
  __typename?: 'UserCommunityAccessGrantConnection';
  /** A list of edges. */
  edges: Array<UserCommunityAccessGrantEdge>;
  /** A list of nodes. */
  nodes: Array<UserCommunityAccessGrant>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UserCommunityAccessGrantEdge = {
  __typename?: 'UserCommunityAccessGrantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: UserCommunityAccessGrant;
};

/** The connection type for User. */
export type UserConnection = Paginated & {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges: Array<UserEdge>;
  /** A list of nodes. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: User;
};

/** A user-readable error. Somewhat deprecated now, but may be repurposed */
export type UserError = {
  __typename?: 'UserError';
  /** The attribute path to this error, if applicable */
  attributePath?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  /** A description of the error */
  message: Scalars['String'];
  /** Which input value this error came from */
  path?: Maybe<Array<Scalars['String']>>;
  /** Whether this error applies to a single attribute, or globally to the entire form */
  scope: MutationErrorScope;
};

/** Not presently exposed through the API. */
export type UserGroup = AccessGrantSubject & Node & Sluggable & {
  __typename?: 'UserGroup';
  /** All access grants for this group */
  accessGrants: AnyUserGroupAccessGrantConnection;
  /** A polymorphic connection for access grants from a subject */
  allAccessGrants: AnyAccessGrantConnection;
  /** All access grants for this group on a collection */
  collectionAccessGrants: UserGroupCollectionAccessGrantConnection;
  /** All access grants for this group on a community */
  communityAccessGrants: UserGroupCommunityAccessGrantConnection;
  createdAt: Scalars['ISO8601DateTime'];
  description: Scalars['String'];
  id: Scalars['ID'];
  /** All access grants for this group on an item */
  itemAccessGrants: UserGroupItemAccessGrantConnection;
  name: Scalars['String'];
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
  users: UserConnection;
};


/** Not presently exposed through the API. */
export type UserGroupAccessGrantsArgs = {
  entity?: Maybe<AccessGrantEntityFilter>;
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** Not presently exposed through the API. */
export type UserGroupAllAccessGrantsArgs = {
  entity?: Maybe<AccessGrantEntityFilter>;
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** Not presently exposed through the API. */
export type UserGroupCollectionAccessGrantsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** Not presently exposed through the API. */
export type UserGroupCommunityAccessGrantsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** Not presently exposed through the API. */
export type UserGroupItemAccessGrantsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** Not presently exposed through the API. */
export type UserGroupUsersArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** An access grant for a user group */
export type UserGroupAccessGrant = {
  /** The polymorphic entity to which access has been granted */
  entity: AnyEntity;
  /** The role the subject has been assigned */
  role: Role;
  /** The polymorphic subject that has been granted access */
  subject: AccessGrantSubject;
  /** The group which has been granted access */
  userGroup: UserGroup;
};

/** An access grant for a group to a collection. */
export type UserGroupCollectionAccessGrant = AccessGrant & UserGroupAccessGrant & Node & Sluggable & {
  __typename?: 'UserGroupCollectionAccessGrant';
  /** The collection to which a group has been granted access */
  collection: Collection;
  createdAt: Scalars['ISO8601DateTime'];
  /** The polymorphic entity to which access has been granted */
  entity: AnyEntity;
  id: Scalars['ID'];
  /** The role the subject has been assigned */
  role: Role;
  slug: Scalars['Slug'];
  /** The polymorphic subject that has been granted access */
  subject: AccessGrantSubject;
  updatedAt: Scalars['ISO8601DateTime'];
  /** The group which has been granted access */
  userGroup: UserGroup;
};

/** The connection type for UserGroupCollectionAccessGrant. */
export type UserGroupCollectionAccessGrantConnection = Paginated & {
  __typename?: 'UserGroupCollectionAccessGrantConnection';
  /** A list of edges. */
  edges: Array<UserGroupCollectionAccessGrantEdge>;
  /** A list of nodes. */
  nodes: Array<UserGroupCollectionAccessGrant>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UserGroupCollectionAccessGrantEdge = {
  __typename?: 'UserGroupCollectionAccessGrantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: UserGroupCollectionAccessGrant;
};

/** An access grant for a group to a community. */
export type UserGroupCommunityAccessGrant = AccessGrant & UserGroupAccessGrant & Node & Sluggable & {
  __typename?: 'UserGroupCommunityAccessGrant';
  /** The community to which a group has been granted access */
  community: Community;
  createdAt: Scalars['ISO8601DateTime'];
  /** The polymorphic entity to which access has been granted */
  entity: AnyEntity;
  id: Scalars['ID'];
  /** The role the subject has been assigned */
  role: Role;
  slug: Scalars['Slug'];
  /** The polymorphic subject that has been granted access */
  subject: AccessGrantSubject;
  updatedAt: Scalars['ISO8601DateTime'];
  /** The group which has been granted access */
  userGroup: UserGroup;
};

/** The connection type for UserGroupCommunityAccessGrant. */
export type UserGroupCommunityAccessGrantConnection = Paginated & {
  __typename?: 'UserGroupCommunityAccessGrantConnection';
  /** A list of edges. */
  edges: Array<UserGroupCommunityAccessGrantEdge>;
  /** A list of nodes. */
  nodes: Array<UserGroupCommunityAccessGrant>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UserGroupCommunityAccessGrantEdge = {
  __typename?: 'UserGroupCommunityAccessGrantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: UserGroupCommunityAccessGrant;
};

/** An access grant for a group to a item. */
export type UserGroupItemAccessGrant = AccessGrant & UserGroupAccessGrant & Node & Sluggable & {
  __typename?: 'UserGroupItemAccessGrant';
  createdAt: Scalars['ISO8601DateTime'];
  /** The polymorphic entity to which access has been granted */
  entity: AnyEntity;
  id: Scalars['ID'];
  /** The item to which a group has been granted access */
  item: Item;
  /** The role the subject has been assigned */
  role: Role;
  slug: Scalars['Slug'];
  /** The polymorphic subject that has been granted access */
  subject: AccessGrantSubject;
  updatedAt: Scalars['ISO8601DateTime'];
  /** The group which has been granted access */
  userGroup: UserGroup;
};

/** The connection type for UserGroupItemAccessGrant. */
export type UserGroupItemAccessGrantConnection = Paginated & {
  __typename?: 'UserGroupItemAccessGrantConnection';
  /** A list of edges. */
  edges: Array<UserGroupItemAccessGrantEdge>;
  /** A list of nodes. */
  nodes: Array<UserGroupItemAccessGrant>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UserGroupItemAccessGrantEdge = {
  __typename?: 'UserGroupItemAccessGrantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: UserGroupItemAccessGrant;
};

/** An access grant for a user to a collection. */
export type UserItemAccessGrant = AccessGrant & UserAccessGrant & Node & Sluggable & {
  __typename?: 'UserItemAccessGrant';
  createdAt: Scalars['ISO8601DateTime'];
  /** The polymorphic entity to which access has been granted */
  entity: AnyEntity;
  id: Scalars['ID'];
  /** The item to which a user has been granted access */
  item: Item;
  /** The role the subject has been assigned */
  role: Role;
  slug: Scalars['Slug'];
  /** The polymorphic subject that has been granted access */
  subject: AccessGrantSubject;
  updatedAt: Scalars['ISO8601DateTime'];
  /** The user which has been granted access */
  user: User;
};

/** The connection type for UserItemAccessGrant. */
export type UserItemAccessGrantConnection = Paginated & {
  __typename?: 'UserItemAccessGrantConnection';
  /** A list of edges. */
  edges: Array<UserItemAccessGrantEdge>;
  /** A list of nodes. */
  nodes: Array<UserItemAccessGrant>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UserItemAccessGrantEdge = {
  __typename?: 'UserItemAccessGrantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: UserItemAccessGrant;
};



export type ResolverTypeWrapper<T> = Promise<T> | T;


export type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
  fragment: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
  selectionSet: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  AccessControlList: ResolverTypeWrapper<AccessControlList>;
  AccessGrant: ResolversTypes['UserCollectionAccessGrant'] | ResolversTypes['UserCommunityAccessGrant'] | ResolversTypes['UserGroupCollectionAccessGrant'] | ResolversTypes['UserGroupCommunityAccessGrant'] | ResolversTypes['UserGroupItemAccessGrant'] | ResolversTypes['UserItemAccessGrant'];
  AccessGrantEntityFilter: AccessGrantEntityFilter;
  AccessGrantSubject: ResolversTypes['User'] | ResolversTypes['UserGroup'];
  String: ResolverTypeWrapper<Scalars['String']>;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  AccessGrantSubjectFilter: AccessGrantSubjectFilter;
  Accessible: ResolversTypes['Collection'] | ResolversTypes['Community'] | ResolversTypes['Item'];
  AlterSchemaVersionInput: AlterSchemaVersionInput;
  ID: ResolverTypeWrapper<Scalars['ID']>;
  AlterSchemaVersionPayload: ResolverTypeWrapper<Omit<AlterSchemaVersionPayload, 'entity'> & { entity?: Maybe<ResolversTypes['AnyEntity']> }>;
  AnyAccessGrant: ResolversTypes['UserCollectionAccessGrant'] | ResolversTypes['UserCommunityAccessGrant'] | ResolversTypes['UserGroupCollectionAccessGrant'] | ResolversTypes['UserGroupCommunityAccessGrant'] | ResolversTypes['UserGroupItemAccessGrant'] | ResolversTypes['UserItemAccessGrant'];
  AnyAccessGrantConnection: ResolverTypeWrapper<Omit<AnyAccessGrantConnection, 'nodes'> & { nodes: Array<ResolversTypes['AnyAccessGrant']> }>;
  AnyAccessGrantEdge: ResolverTypeWrapper<Omit<AnyAccessGrantEdge, 'node'> & { node: ResolversTypes['AnyAccessGrant'] }>;
  AnyAsset: ResolversTypes['AssetAudio'] | ResolversTypes['AssetDocument'] | ResolversTypes['AssetImage'] | ResolversTypes['AssetPDF'] | ResolversTypes['AssetUnknown'] | ResolversTypes['AssetVideo'];
  AnyAssetConnection: ResolverTypeWrapper<Omit<AnyAssetConnection, 'nodes'> & { nodes: Array<ResolversTypes['AnyAsset']> }>;
  AnyAssetEdge: ResolverTypeWrapper<Omit<AnyAssetEdge, 'node'> & { node: ResolversTypes['AnyAsset'] }>;
  AnyAttachable: ResolversTypes['Collection'] | ResolversTypes['Community'] | ResolversTypes['Item'];
  AnyCollectionAccessGrant: ResolversTypes['UserCollectionAccessGrant'] | ResolversTypes['UserGroupCollectionAccessGrant'];
  AnyCollectionAccessGrantConnection: ResolverTypeWrapper<Omit<AnyCollectionAccessGrantConnection, 'nodes'> & { nodes: Array<ResolversTypes['AnyCollectionAccessGrant']> }>;
  AnyCollectionAccessGrantEdge: ResolverTypeWrapper<Omit<AnyCollectionAccessGrantEdge, 'node'> & { node: ResolversTypes['AnyCollectionAccessGrant'] }>;
  AnyCommunityAccessGrant: ResolversTypes['UserCommunityAccessGrant'] | ResolversTypes['UserGroupCommunityAccessGrant'];
  AnyCommunityAccessGrantConnection: ResolverTypeWrapper<Omit<AnyCommunityAccessGrantConnection, 'nodes'> & { nodes: Array<ResolversTypes['AnyCommunityAccessGrant']> }>;
  AnyCommunityAccessGrantEdge: ResolverTypeWrapper<Omit<AnyCommunityAccessGrantEdge, 'node'> & { node: ResolversTypes['AnyCommunityAccessGrant'] }>;
  AnyContribution: ResolversTypes['CollectionContribution'] | ResolversTypes['ItemContribution'];
  AnyContributor: ResolversTypes['OrganizationContributor'] | ResolversTypes['PersonContributor'];
  AnyContributorConnection: ResolverTypeWrapper<Omit<AnyContributorConnection, 'nodes'> & { nodes: Array<ResolversTypes['AnyContributor']> }>;
  AnyContributorEdge: ResolverTypeWrapper<Omit<AnyContributorEdge, 'node'> & { node: ResolversTypes['AnyContributor'] }>;
  AnyEntity: ResolversTypes['Collection'] | ResolversTypes['Community'] | ResolversTypes['Item'];
  AnyOrderingEntry: ResolversTypes['Collection'] | ResolversTypes['Community'] | ResolversTypes['EntityLink'] | ResolversTypes['Item'];
  AnyScalarProperty: ResolversTypes['AssetProperty'] | ResolversTypes['AssetsProperty'] | ResolversTypes['BooleanProperty'] | ResolversTypes['ContributorProperty'] | ResolversTypes['ContributorsProperty'] | ResolversTypes['DateProperty'] | ResolversTypes['EmailProperty'] | ResolversTypes['FloatProperty'] | ResolversTypes['IntegerProperty'] | ResolversTypes['MarkdownProperty'] | ResolversTypes['MultiselectProperty'] | ResolversTypes['SelectProperty'] | ResolversTypes['StringProperty'] | ResolversTypes['TagsProperty'] | ResolversTypes['TimestampProperty'] | ResolversTypes['UnknownProperty'];
  AnySchemaProperty: ResolversTypes['AssetProperty'] | ResolversTypes['AssetsProperty'] | ResolversTypes['BooleanProperty'] | ResolversTypes['ContributorProperty'] | ResolversTypes['ContributorsProperty'] | ResolversTypes['DateProperty'] | ResolversTypes['EmailProperty'] | ResolversTypes['FloatProperty'] | ResolversTypes['GroupProperty'] | ResolversTypes['IntegerProperty'] | ResolversTypes['MarkdownProperty'] | ResolversTypes['MultiselectProperty'] | ResolversTypes['SelectProperty'] | ResolversTypes['StringProperty'] | ResolversTypes['TagsProperty'] | ResolversTypes['TimestampProperty'] | ResolversTypes['UnknownProperty'];
  AnyUserAccessGrant: ResolversTypes['UserCollectionAccessGrant'] | ResolversTypes['UserCommunityAccessGrant'] | ResolversTypes['UserItemAccessGrant'];
  AnyUserAccessGrantConnection: ResolverTypeWrapper<Omit<AnyUserAccessGrantConnection, 'nodes'> & { nodes: Array<ResolversTypes['AnyUserAccessGrant']> }>;
  AnyUserAccessGrantEdge: ResolverTypeWrapper<Omit<AnyUserAccessGrantEdge, 'node'> & { node: ResolversTypes['AnyUserAccessGrant'] }>;
  AnyUserGroupAccessGrant: ResolversTypes['UserGroupCollectionAccessGrant'] | ResolversTypes['UserGroupCommunityAccessGrant'] | ResolversTypes['UserGroupItemAccessGrant'];
  AnyUserGroupAccessGrantConnection: ResolverTypeWrapper<Omit<AnyUserGroupAccessGrantConnection, 'nodes'> & { nodes: Array<ResolversTypes['AnyUserGroupAccessGrant']> }>;
  AnyUserGroupAccessGrantEdge: ResolverTypeWrapper<Omit<AnyUserGroupAccessGrantEdge, 'node'> & { node: ResolversTypes['AnyUserGroupAccessGrant'] }>;
  ApplySchemaPropertiesInput: ApplySchemaPropertiesInput;
  ApplySchemaPropertiesPayload: ResolverTypeWrapper<Omit<ApplySchemaPropertiesPayload, 'entity'> & { entity?: Maybe<ResolversTypes['AnyEntity']> }>;
  Asset: ResolversTypes['AssetAudio'] | ResolversTypes['AssetDocument'] | ResolversTypes['AssetImage'] | ResolversTypes['AssetPDF'] | ResolversTypes['AssetUnknown'] | ResolversTypes['AssetVideo'];
  AssetAudio: ResolverTypeWrapper<Omit<AssetAudio, 'attachable'> & { attachable: ResolversTypes['AnyAttachable'] }>;
  AssetDocument: ResolverTypeWrapper<Omit<AssetDocument, 'attachable'> & { attachable: ResolversTypes['AnyAttachable'] }>;
  AssetImage: ResolverTypeWrapper<Omit<AssetImage, 'attachable'> & { attachable: ResolversTypes['AnyAttachable'] }>;
  AssetKind: AssetKind;
  AssetKindFilter: AssetKindFilter;
  AssetPDF: ResolverTypeWrapper<Omit<AssetPdf, 'attachable'> & { attachable: ResolversTypes['AnyAttachable'] }>;
  AssetPreview: ResolverTypeWrapper<AssetPreview>;
  AssetProperty: ResolverTypeWrapper<Omit<AssetProperty, 'asset'> & { asset?: Maybe<ResolversTypes['AnyAsset']> }>;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  AssetSelectOption: ResolverTypeWrapper<AssetSelectOption>;
  AssetUnknown: ResolverTypeWrapper<Omit<AssetUnknown, 'attachable'> & { attachable: ResolversTypes['AnyAttachable'] }>;
  AssetVideo: ResolverTypeWrapper<Omit<AssetVideo, 'attachable'> & { attachable: ResolversTypes['AnyAttachable'] }>;
  AssetsProperty: ResolverTypeWrapper<Omit<AssetsProperty, 'assets'> & { assets: Array<ResolversTypes['AnyAsset']> }>;
  Attachable: ResolversTypes['Collection'] | ResolversTypes['Community'] | ResolversTypes['Item'];
  BooleanProperty: ResolverTypeWrapper<BooleanProperty>;
  Collection: ResolverTypeWrapper<Omit<Collection, 'parent' | 'schemaProperties'> & { parent?: Maybe<ResolversTypes['CollectionParent']>, schemaProperties: Array<ResolversTypes['AnySchemaProperty']> }>;
  CollectionConnection: ResolverTypeWrapper<CollectionConnection>;
  CollectionContribution: ResolverTypeWrapper<Omit<CollectionContribution, 'contributor'> & { contributor: ResolversTypes['AnyContributor'] }>;
  CollectionContributionConnection: ResolverTypeWrapper<CollectionContributionConnection>;
  CollectionContributionEdge: ResolverTypeWrapper<CollectionContributionEdge>;
  CollectionEdge: ResolverTypeWrapper<CollectionEdge>;
  CollectionParent: ResolversTypes['Collection'] | ResolversTypes['Community'];
  Community: ResolverTypeWrapper<Omit<Community, 'schemaProperties'> & { schemaProperties: Array<ResolversTypes['AnySchemaProperty']> }>;
  CommunityConnection: ResolverTypeWrapper<CommunityConnection>;
  CommunityEdge: ResolverTypeWrapper<CommunityEdge>;
  ContextualPermission: ResolverTypeWrapper<Omit<ContextualPermission, 'accessGrants'> & { accessGrants: Array<ResolversTypes['AnyUserAccessGrant']> }>;
  ContextualPermissionConnection: ResolverTypeWrapper<ContextualPermissionConnection>;
  ContextualPermissionEdge: ResolverTypeWrapper<ContextualPermissionEdge>;
  ContextualPermissionOrder: ContextualPermissionOrder;
  Contributable: ResolversTypes['Collection'] | ResolversTypes['Item'];
  Contribution: ResolversTypes['CollectionContribution'] | ResolversTypes['ItemContribution'];
  ContributionMetadata: ResolverTypeWrapper<ContributionMetadata>;
  ContributionMetadataInput: ContributionMetadataInput;
  Contributor: ResolversTypes['OrganizationContributor'] | ResolversTypes['PersonContributor'];
  ContributorFilterKind: ContributorFilterKind;
  ContributorKind: ContributorKind;
  ContributorLink: ResolverTypeWrapper<ContributorLink>;
  ContributorLinkInput: ContributorLinkInput;
  ContributorProperty: ResolverTypeWrapper<Omit<ContributorProperty, 'contributor'> & { contributor?: Maybe<ResolversTypes['AnyContributor']> }>;
  ContributorSelectOption: ResolverTypeWrapper<ContributorSelectOption>;
  ContributorsProperty: ResolverTypeWrapper<Omit<ContributorsProperty, 'contributors'> & { contributors: Array<ResolversTypes['AnyContributor']> }>;
  CreateAssetInput: CreateAssetInput;
  CreateAssetPayload: ResolverTypeWrapper<Omit<CreateAssetPayload, 'asset'> & { asset?: Maybe<ResolversTypes['AnyAsset']> }>;
  CreateCollectionInput: CreateCollectionInput;
  CreateCollectionPayload: ResolverTypeWrapper<CreateCollectionPayload>;
  CreateCommunityInput: CreateCommunityInput;
  CreateCommunityPayload: ResolverTypeWrapper<CreateCommunityPayload>;
  CreateItemInput: CreateItemInput;
  CreateItemPayload: ResolverTypeWrapper<CreateItemPayload>;
  CreateOrderingInput: CreateOrderingInput;
  CreateOrderingPayload: ResolverTypeWrapper<CreateOrderingPayload>;
  CreateOrganizationContributorInput: CreateOrganizationContributorInput;
  CreateOrganizationContributorPayload: ResolverTypeWrapper<CreateOrganizationContributorPayload>;
  CreatePersonContributorInput: CreatePersonContributorInput;
  CreatePersonContributorPayload: ResolverTypeWrapper<CreatePersonContributorPayload>;
  CreateRoleInput: CreateRoleInput;
  CreateRolePayload: ResolverTypeWrapper<CreateRolePayload>;
  DateProperty: ResolverTypeWrapper<DateProperty>;
  DestroyCollectionInput: DestroyCollectionInput;
  DestroyCollectionPayload: ResolverTypeWrapper<DestroyCollectionPayload>;
  DestroyCommunityInput: DestroyCommunityInput;
  DestroyCommunityPayload: ResolverTypeWrapper<DestroyCommunityPayload>;
  DestroyContributionInput: DestroyContributionInput;
  DestroyContributionPayload: ResolverTypeWrapper<DestroyContributionPayload>;
  DestroyContributorInput: DestroyContributorInput;
  DestroyContributorPayload: ResolverTypeWrapper<DestroyContributorPayload>;
  DestroyEntityLinkInput: DestroyEntityLinkInput;
  DestroyEntityLinkPayload: ResolverTypeWrapper<DestroyEntityLinkPayload>;
  DestroyItemInput: DestroyItemInput;
  DestroyItemPayload: ResolverTypeWrapper<DestroyItemPayload>;
  DestroyMutationPayload: ResolversTypes['DestroyCollectionPayload'] | ResolversTypes['DestroyCommunityPayload'] | ResolversTypes['DestroyContributionPayload'] | ResolversTypes['DestroyContributorPayload'] | ResolversTypes['DestroyEntityLinkPayload'] | ResolversTypes['DestroyItemPayload'] | ResolversTypes['DestroyOrderingPayload'];
  DestroyOrderingInput: DestroyOrderingInput;
  DestroyOrderingPayload: ResolverTypeWrapper<DestroyOrderingPayload>;
  Direction: Direction;
  EmailProperty: ResolverTypeWrapper<EmailProperty>;
  Entity: ResolversTypes['Collection'] | ResolversTypes['Community'] | ResolversTypes['Item'];
  EntityBreadcrumb: ResolverTypeWrapper<Omit<EntityBreadcrumb, 'crumb'> & { crumb: ResolversTypes['AnyEntity'] }>;
  EntityKind: EntityKind;
  EntityLink: ResolverTypeWrapper<Omit<EntityLink, 'source' | 'target'> & { source: ResolversTypes['AnyEntity'], target: ResolversTypes['AnyEntity'] }>;
  EntityLinkConnection: ResolverTypeWrapper<EntityLinkConnection>;
  EntityLinkEdge: ResolverTypeWrapper<EntityLinkEdge>;
  EntityLinkOperator: EntityLinkOperator;
  EntityLinkScope: EntityLinkScope;
  EntityPermissionFilter: EntityPermissionFilter;
  EntityVisibility: EntityVisibility;
  ExposesPermissions: ResolversTypes['ContextualPermission'] | ResolversTypes['User'];
  FloatProperty: ResolverTypeWrapper<FloatProperty>;
  Float: ResolverTypeWrapper<Scalars['Float']>;
  GrantAccessInput: GrantAccessInput;
  GrantAccessPayload: ResolverTypeWrapper<Omit<GrantAccessPayload, 'entity'> & { entity?: Maybe<ResolversTypes['AnyEntity']> }>;
  GroupProperty: ResolverTypeWrapper<Omit<GroupProperty, 'properties'> & { properties: Array<ResolversTypes['AnyScalarProperty']> }>;
  HasSchemaProperties: ResolversTypes['Collection'] | ResolversTypes['Community'] | ResolversTypes['Item'] | ResolversTypes['SchemaVersion'];
  HierarchicalEntry: ResolversTypes['Collection'] | ResolversTypes['Item'];
  ISO8601Date: ResolverTypeWrapper<Scalars['ISO8601Date']>;
  ISO8601DateTime: ResolverTypeWrapper<Scalars['ISO8601DateTime']>;
  IntegerProperty: ResolverTypeWrapper<IntegerProperty>;
  Item: ResolverTypeWrapper<Omit<Item, 'parent' | 'schemaProperties'> & { parent?: Maybe<ResolversTypes['ItemParent']>, schemaProperties: Array<ResolversTypes['AnySchemaProperty']> }>;
  ItemConnection: ResolverTypeWrapper<ItemConnection>;
  ItemContribution: ResolverTypeWrapper<Omit<ItemContribution, 'contributor'> & { contributor: ResolversTypes['AnyContributor'] }>;
  ItemContributionConnection: ResolverTypeWrapper<ItemContributionConnection>;
  ItemContributionEdge: ResolverTypeWrapper<ItemContributionEdge>;
  ItemEdge: ResolverTypeWrapper<ItemEdge>;
  ItemParent: ResolversTypes['Collection'] | ResolversTypes['Item'];
  JSON: ResolverTypeWrapper<Scalars['JSON']>;
  LinkEntityInput: LinkEntityInput;
  LinkEntityPayload: ResolverTypeWrapper<LinkEntityPayload>;
  MarkdownProperty: ResolverTypeWrapper<MarkdownProperty>;
  MultiselectProperty: ResolverTypeWrapper<MultiselectProperty>;
  Mutation: ResolverTypeWrapper<{}>;
  MutationAttributeError: ResolverTypeWrapper<MutationAttributeError>;
  MutationErrorScope: MutationErrorScope;
  MutationGlobalError: ResolverTypeWrapper<MutationGlobalError>;
  Node: ResolversTypes['AssetAudio'] | ResolversTypes['AssetDocument'] | ResolversTypes['AssetImage'] | ResolversTypes['AssetPDF'] | ResolversTypes['AssetUnknown'] | ResolversTypes['AssetVideo'] | ResolversTypes['Collection'] | ResolversTypes['CollectionContribution'] | ResolversTypes['Community'] | ResolversTypes['ContextualPermission'] | ResolversTypes['EntityBreadcrumb'] | ResolversTypes['EntityLink'] | ResolversTypes['Item'] | ResolversTypes['ItemContribution'] | ResolversTypes['Ordering'] | ResolversTypes['OrderingEntry'] | ResolversTypes['OrganizationContributor'] | ResolversTypes['PersonContributor'] | ResolversTypes['Role'] | ResolversTypes['SchemaDefinition'] | ResolversTypes['SchemaVersion'] | ResolversTypes['User'] | ResolversTypes['UserCollectionAccessGrant'] | ResolversTypes['UserCommunityAccessGrant'] | ResolversTypes['UserGroup'] | ResolversTypes['UserGroupCollectionAccessGrant'] | ResolversTypes['UserGroupCommunityAccessGrant'] | ResolversTypes['UserGroupItemAccessGrant'] | ResolversTypes['UserItemAccessGrant'];
  NullOrderPriority: NullOrderPriority;
  OptionableProperty: ResolversTypes['MultiselectProperty'] | ResolversTypes['SelectProperty'];
  OrderDefinitionInput: OrderDefinitionInput;
  Ordering: ResolverTypeWrapper<Omit<Ordering, 'entity'> & { entity: ResolversTypes['AnyEntity'] }>;
  OrderingConnection: ResolverTypeWrapper<OrderingConnection>;
  OrderingDirectSelection: OrderingDirectSelection;
  OrderingEdge: ResolverTypeWrapper<OrderingEdge>;
  OrderingEntry: ResolverTypeWrapper<Omit<OrderingEntry, 'entry'> & { entry: ResolversTypes['AnyOrderingEntry'] }>;
  OrderingEntryConnection: ResolverTypeWrapper<OrderingEntryConnection>;
  OrderingEntryEdge: ResolverTypeWrapper<OrderingEntryEdge>;
  OrderingFilterDefinitionInput: OrderingFilterDefinitionInput;
  OrderingSelectDefinitionInput: OrderingSelectDefinitionInput;
  OrderingSelectLinkDefinitionInput: OrderingSelectLinkDefinitionInput;
  OrganizationContributor: ResolverTypeWrapper<OrganizationContributor>;
  PageDirection: PageDirection;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  Paginated: ResolversTypes['AnyAccessGrantConnection'] | ResolversTypes['AnyAssetConnection'] | ResolversTypes['AnyCollectionAccessGrantConnection'] | ResolversTypes['AnyCommunityAccessGrantConnection'] | ResolversTypes['AnyContributorConnection'] | ResolversTypes['AnyUserAccessGrantConnection'] | ResolversTypes['AnyUserGroupAccessGrantConnection'] | ResolversTypes['CollectionConnection'] | ResolversTypes['CollectionContributionConnection'] | ResolversTypes['CommunityConnection'] | ResolversTypes['ContextualPermissionConnection'] | ResolversTypes['EntityLinkConnection'] | ResolversTypes['ItemConnection'] | ResolversTypes['ItemContributionConnection'] | ResolversTypes['OrderingConnection'] | ResolversTypes['OrderingEntryConnection'] | ResolversTypes['RoleConnection'] | ResolversTypes['SchemaDefinitionConnection'] | ResolversTypes['SchemaVersionConnection'] | ResolversTypes['UserCollectionAccessGrantConnection'] | ResolversTypes['UserCommunityAccessGrantConnection'] | ResolversTypes['UserConnection'] | ResolversTypes['UserGroupCollectionAccessGrantConnection'] | ResolversTypes['UserGroupCommunityAccessGrantConnection'] | ResolversTypes['UserGroupItemAccessGrantConnection'] | ResolversTypes['UserItemAccessGrantConnection'];
  PermissionGrant: ResolverTypeWrapper<PermissionGrant>;
  PersonContributor: ResolverTypeWrapper<PersonContributor>;
  PositionDirection: PositionDirection;
  PreviewImage: ResolverTypeWrapper<PreviewImage>;
  PreviewImageMap: ResolverTypeWrapper<PreviewImageMap>;
  PropertyApplicationStrategy: PropertyApplicationStrategy;
  Query: ResolverTypeWrapper<{}>;
  ReparentCollectionInput: ReparentCollectionInput;
  ReparentCollectionPayload: ResolverTypeWrapper<ReparentCollectionPayload>;
  ReparentItemInput: ReparentItemInput;
  ReparentItemPayload: ResolverTypeWrapper<ReparentItemPayload>;
  ResetOrderingInput: ResetOrderingInput;
  ResetOrderingPayload: ResolverTypeWrapper<ResetOrderingPayload>;
  RevokeAccessInput: RevokeAccessInput;
  RevokeAccessPayload: ResolverTypeWrapper<Omit<RevokeAccessPayload, 'entity'> & { entity?: Maybe<ResolversTypes['AnyEntity']> }>;
  Role: ResolverTypeWrapper<Role>;
  RoleConnection: ResolverTypeWrapper<RoleConnection>;
  RoleEdge: ResolverTypeWrapper<RoleEdge>;
  ScalarProperty: ResolversTypes['AssetProperty'] | ResolversTypes['AssetsProperty'] | ResolversTypes['BooleanProperty'] | ResolversTypes['ContributorProperty'] | ResolversTypes['ContributorsProperty'] | ResolversTypes['DateProperty'] | ResolversTypes['EmailProperty'] | ResolversTypes['FloatProperty'] | ResolversTypes['IntegerProperty'] | ResolversTypes['MarkdownProperty'] | ResolversTypes['MultiselectProperty'] | ResolversTypes['SelectProperty'] | ResolversTypes['StringProperty'] | ResolversTypes['TagsProperty'] | ResolversTypes['TimestampProperty'] | ResolversTypes['UnknownProperty'];
  SchemaDefinition: ResolverTypeWrapper<SchemaDefinition>;
  SchemaDefinitionConnection: ResolverTypeWrapper<SchemaDefinitionConnection>;
  SchemaDefinitionEdge: ResolverTypeWrapper<SchemaDefinitionEdge>;
  SchemaInstance: ResolversTypes['Collection'] | ResolversTypes['Community'] | ResolversTypes['Item'];
  SchemaInstanceContext: ResolverTypeWrapper<SchemaInstanceContext>;
  SchemaInstanceValidation: ResolverTypeWrapper<SchemaInstanceValidation>;
  SchemaKind: SchemaKind;
  SchemaProperty: ResolversTypes['GroupProperty'];
  SchemaValueError: ResolverTypeWrapper<SchemaValueError>;
  SchemaVersion: ResolverTypeWrapper<Omit<SchemaVersion, 'schemaProperties'> & { schemaProperties: Array<ResolversTypes['AnySchemaProperty']> }>;
  SchemaVersionConnection: ResolverTypeWrapper<SchemaVersionConnection>;
  SchemaVersionEdge: ResolverTypeWrapper<SchemaVersionEdge>;
  SchemaVersionOption: ResolverTypeWrapper<SchemaVersionOption>;
  SchemaVersionOrder: SchemaVersionOrder;
  SelectOption: ResolverTypeWrapper<SelectOption>;
  SelectProperty: ResolverTypeWrapper<SelectProperty>;
  SimpleOrder: SimpleOrder;
  Slug: ResolverTypeWrapper<Scalars['Slug']>;
  Sluggable: ResolversTypes['AssetAudio'] | ResolversTypes['AssetDocument'] | ResolversTypes['AssetImage'] | ResolversTypes['AssetPDF'] | ResolversTypes['AssetUnknown'] | ResolversTypes['AssetVideo'] | ResolversTypes['Collection'] | ResolversTypes['CollectionContribution'] | ResolversTypes['Community'] | ResolversTypes['ContextualPermission'] | ResolversTypes['EntityLink'] | ResolversTypes['Item'] | ResolversTypes['ItemContribution'] | ResolversTypes['Ordering'] | ResolversTypes['OrderingEntry'] | ResolversTypes['OrganizationContributor'] | ResolversTypes['PersonContributor'] | ResolversTypes['Role'] | ResolversTypes['SchemaDefinition'] | ResolversTypes['SchemaVersion'] | ResolversTypes['User'] | ResolversTypes['UserCollectionAccessGrant'] | ResolversTypes['UserCommunityAccessGrant'] | ResolversTypes['UserGroup'] | ResolversTypes['UserGroupCollectionAccessGrant'] | ResolversTypes['UserGroupCommunityAccessGrant'] | ResolversTypes['UserGroupItemAccessGrant'] | ResolversTypes['UserItemAccessGrant'];
  StandardMutationPayload: ResolversTypes['AlterSchemaVersionPayload'] | ResolversTypes['ApplySchemaPropertiesPayload'] | ResolversTypes['CreateAssetPayload'] | ResolversTypes['CreateCollectionPayload'] | ResolversTypes['CreateCommunityPayload'] | ResolversTypes['CreateItemPayload'] | ResolversTypes['CreateOrderingPayload'] | ResolversTypes['CreateOrganizationContributorPayload'] | ResolversTypes['CreatePersonContributorPayload'] | ResolversTypes['CreateRolePayload'] | ResolversTypes['DestroyCollectionPayload'] | ResolversTypes['DestroyCommunityPayload'] | ResolversTypes['DestroyContributionPayload'] | ResolversTypes['DestroyContributorPayload'] | ResolversTypes['DestroyEntityLinkPayload'] | ResolversTypes['DestroyItemPayload'] | ResolversTypes['DestroyOrderingPayload'] | ResolversTypes['GrantAccessPayload'] | ResolversTypes['LinkEntityPayload'] | ResolversTypes['ReparentCollectionPayload'] | ResolversTypes['ReparentItemPayload'] | ResolversTypes['ResetOrderingPayload'] | ResolversTypes['RevokeAccessPayload'] | ResolversTypes['UpdateCollectionPayload'] | ResolversTypes['UpdateCommunityPayload'] | ResolversTypes['UpdateContributionPayload'] | ResolversTypes['UpdateItemPayload'] | ResolversTypes['UpdateOrderingPayload'] | ResolversTypes['UpdateOrganizationContributorPayload'] | ResolversTypes['UpdatePersonContributorPayload'] | ResolversTypes['UpdateRolePayload'] | ResolversTypes['UpsertContributionPayload'];
  StringProperty: ResolverTypeWrapper<StringProperty>;
  TagsProperty: ResolverTypeWrapper<TagsProperty>;
  TimestampProperty: ResolverTypeWrapper<TimestampProperty>;
  TreeNodeFilter: TreeNodeFilter;
  UnknownProperty: ResolverTypeWrapper<UnknownProperty>;
  UpdateCollectionInput: UpdateCollectionInput;
  UpdateCollectionPayload: ResolverTypeWrapper<UpdateCollectionPayload>;
  UpdateCommunityInput: UpdateCommunityInput;
  UpdateCommunityPayload: ResolverTypeWrapper<UpdateCommunityPayload>;
  UpdateContributionInput: UpdateContributionInput;
  UpdateContributionPayload: ResolverTypeWrapper<Omit<UpdateContributionPayload, 'contribution'> & { contribution?: Maybe<ResolversTypes['AnyContribution']> }>;
  UpdateItemInput: UpdateItemInput;
  UpdateItemPayload: ResolverTypeWrapper<UpdateItemPayload>;
  UpdateOrderingInput: UpdateOrderingInput;
  UpdateOrderingPayload: ResolverTypeWrapper<UpdateOrderingPayload>;
  UpdateOrganizationContributorInput: UpdateOrganizationContributorInput;
  UpdateOrganizationContributorPayload: ResolverTypeWrapper<UpdateOrganizationContributorPayload>;
  UpdatePersonContributorInput: UpdatePersonContributorInput;
  UpdatePersonContributorPayload: ResolverTypeWrapper<UpdatePersonContributorPayload>;
  UpdateRoleInput: UpdateRoleInput;
  UpdateRolePayload: ResolverTypeWrapper<UpdateRolePayload>;
  UploadID: ResolverTypeWrapper<Scalars['UploadID']>;
  UploadStorage: UploadStorage;
  UploadedFileInput: UploadedFileInput;
  UploadedFileMetadataInput: UploadedFileMetadataInput;
  UpsertContributionInput: UpsertContributionInput;
  UpsertContributionPayload: ResolverTypeWrapper<Omit<UpsertContributionPayload, 'contribution'> & { contribution?: Maybe<ResolversTypes['AnyContribution']> }>;
  User: ResolverTypeWrapper<User>;
  UserAccessGrant: ResolversTypes['UserCollectionAccessGrant'] | ResolversTypes['UserCommunityAccessGrant'] | ResolversTypes['UserItemAccessGrant'];
  UserCollectionAccessGrant: ResolverTypeWrapper<Omit<UserCollectionAccessGrant, 'entity'> & { entity: ResolversTypes['AnyEntity'] }>;
  UserCollectionAccessGrantConnection: ResolverTypeWrapper<UserCollectionAccessGrantConnection>;
  UserCollectionAccessGrantEdge: ResolverTypeWrapper<UserCollectionAccessGrantEdge>;
  UserCommunityAccessGrant: ResolverTypeWrapper<Omit<UserCommunityAccessGrant, 'entity'> & { entity: ResolversTypes['AnyEntity'] }>;
  UserCommunityAccessGrantConnection: ResolverTypeWrapper<UserCommunityAccessGrantConnection>;
  UserCommunityAccessGrantEdge: ResolverTypeWrapper<UserCommunityAccessGrantEdge>;
  UserConnection: ResolverTypeWrapper<UserConnection>;
  UserEdge: ResolverTypeWrapper<UserEdge>;
  UserError: ResolverTypeWrapper<UserError>;
  UserGroup: ResolverTypeWrapper<UserGroup>;
  UserGroupAccessGrant: ResolversTypes['UserGroupCollectionAccessGrant'] | ResolversTypes['UserGroupCommunityAccessGrant'] | ResolversTypes['UserGroupItemAccessGrant'];
  UserGroupCollectionAccessGrant: ResolverTypeWrapper<Omit<UserGroupCollectionAccessGrant, 'entity'> & { entity: ResolversTypes['AnyEntity'] }>;
  UserGroupCollectionAccessGrantConnection: ResolverTypeWrapper<UserGroupCollectionAccessGrantConnection>;
  UserGroupCollectionAccessGrantEdge: ResolverTypeWrapper<UserGroupCollectionAccessGrantEdge>;
  UserGroupCommunityAccessGrant: ResolverTypeWrapper<Omit<UserGroupCommunityAccessGrant, 'entity'> & { entity: ResolversTypes['AnyEntity'] }>;
  UserGroupCommunityAccessGrantConnection: ResolverTypeWrapper<UserGroupCommunityAccessGrantConnection>;
  UserGroupCommunityAccessGrantEdge: ResolverTypeWrapper<UserGroupCommunityAccessGrantEdge>;
  UserGroupItemAccessGrant: ResolverTypeWrapper<Omit<UserGroupItemAccessGrant, 'entity'> & { entity: ResolversTypes['AnyEntity'] }>;
  UserGroupItemAccessGrantConnection: ResolverTypeWrapper<UserGroupItemAccessGrantConnection>;
  UserGroupItemAccessGrantEdge: ResolverTypeWrapper<UserGroupItemAccessGrantEdge>;
  UserItemAccessGrant: ResolverTypeWrapper<Omit<UserItemAccessGrant, 'entity'> & { entity: ResolversTypes['AnyEntity'] }>;
  UserItemAccessGrantConnection: ResolverTypeWrapper<UserItemAccessGrantConnection>;
  UserItemAccessGrantEdge: ResolverTypeWrapper<UserItemAccessGrantEdge>;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  AccessControlList: AccessControlList;
  AccessGrant: ResolversParentTypes['UserCollectionAccessGrant'] | ResolversParentTypes['UserCommunityAccessGrant'] | ResolversParentTypes['UserGroupCollectionAccessGrant'] | ResolversParentTypes['UserGroupCommunityAccessGrant'] | ResolversParentTypes['UserGroupItemAccessGrant'] | ResolversParentTypes['UserItemAccessGrant'];
  AccessGrantSubject: ResolversParentTypes['User'] | ResolversParentTypes['UserGroup'];
  String: Scalars['String'];
  Int: Scalars['Int'];
  Accessible: ResolversParentTypes['Collection'] | ResolversParentTypes['Community'] | ResolversParentTypes['Item'];
  AlterSchemaVersionInput: AlterSchemaVersionInput;
  ID: Scalars['ID'];
  AlterSchemaVersionPayload: Omit<AlterSchemaVersionPayload, 'entity'> & { entity?: Maybe<ResolversParentTypes['AnyEntity']> };
  AnyAccessGrant: ResolversParentTypes['UserCollectionAccessGrant'] | ResolversParentTypes['UserCommunityAccessGrant'] | ResolversParentTypes['UserGroupCollectionAccessGrant'] | ResolversParentTypes['UserGroupCommunityAccessGrant'] | ResolversParentTypes['UserGroupItemAccessGrant'] | ResolversParentTypes['UserItemAccessGrant'];
  AnyAccessGrantConnection: Omit<AnyAccessGrantConnection, 'nodes'> & { nodes: Array<ResolversParentTypes['AnyAccessGrant']> };
  AnyAccessGrantEdge: Omit<AnyAccessGrantEdge, 'node'> & { node: ResolversParentTypes['AnyAccessGrant'] };
  AnyAsset: ResolversParentTypes['AssetAudio'] | ResolversParentTypes['AssetDocument'] | ResolversParentTypes['AssetImage'] | ResolversParentTypes['AssetPDF'] | ResolversParentTypes['AssetUnknown'] | ResolversParentTypes['AssetVideo'];
  AnyAssetConnection: Omit<AnyAssetConnection, 'nodes'> & { nodes: Array<ResolversParentTypes['AnyAsset']> };
  AnyAssetEdge: Omit<AnyAssetEdge, 'node'> & { node: ResolversParentTypes['AnyAsset'] };
  AnyAttachable: ResolversParentTypes['Collection'] | ResolversParentTypes['Community'] | ResolversParentTypes['Item'];
  AnyCollectionAccessGrant: ResolversParentTypes['UserCollectionAccessGrant'] | ResolversParentTypes['UserGroupCollectionAccessGrant'];
  AnyCollectionAccessGrantConnection: Omit<AnyCollectionAccessGrantConnection, 'nodes'> & { nodes: Array<ResolversParentTypes['AnyCollectionAccessGrant']> };
  AnyCollectionAccessGrantEdge: Omit<AnyCollectionAccessGrantEdge, 'node'> & { node: ResolversParentTypes['AnyCollectionAccessGrant'] };
  AnyCommunityAccessGrant: ResolversParentTypes['UserCommunityAccessGrant'] | ResolversParentTypes['UserGroupCommunityAccessGrant'];
  AnyCommunityAccessGrantConnection: Omit<AnyCommunityAccessGrantConnection, 'nodes'> & { nodes: Array<ResolversParentTypes['AnyCommunityAccessGrant']> };
  AnyCommunityAccessGrantEdge: Omit<AnyCommunityAccessGrantEdge, 'node'> & { node: ResolversParentTypes['AnyCommunityAccessGrant'] };
  AnyContribution: ResolversParentTypes['CollectionContribution'] | ResolversParentTypes['ItemContribution'];
  AnyContributor: ResolversParentTypes['OrganizationContributor'] | ResolversParentTypes['PersonContributor'];
  AnyContributorConnection: Omit<AnyContributorConnection, 'nodes'> & { nodes: Array<ResolversParentTypes['AnyContributor']> };
  AnyContributorEdge: Omit<AnyContributorEdge, 'node'> & { node: ResolversParentTypes['AnyContributor'] };
  AnyEntity: ResolversParentTypes['Collection'] | ResolversParentTypes['Community'] | ResolversParentTypes['Item'];
  AnyOrderingEntry: ResolversParentTypes['Collection'] | ResolversParentTypes['Community'] | ResolversParentTypes['EntityLink'] | ResolversParentTypes['Item'];
  AnyScalarProperty: ResolversParentTypes['AssetProperty'] | ResolversParentTypes['AssetsProperty'] | ResolversParentTypes['BooleanProperty'] | ResolversParentTypes['ContributorProperty'] | ResolversParentTypes['ContributorsProperty'] | ResolversParentTypes['DateProperty'] | ResolversParentTypes['EmailProperty'] | ResolversParentTypes['FloatProperty'] | ResolversParentTypes['IntegerProperty'] | ResolversParentTypes['MarkdownProperty'] | ResolversParentTypes['MultiselectProperty'] | ResolversParentTypes['SelectProperty'] | ResolversParentTypes['StringProperty'] | ResolversParentTypes['TagsProperty'] | ResolversParentTypes['TimestampProperty'] | ResolversParentTypes['UnknownProperty'];
  AnySchemaProperty: ResolversParentTypes['AssetProperty'] | ResolversParentTypes['AssetsProperty'] | ResolversParentTypes['BooleanProperty'] | ResolversParentTypes['ContributorProperty'] | ResolversParentTypes['ContributorsProperty'] | ResolversParentTypes['DateProperty'] | ResolversParentTypes['EmailProperty'] | ResolversParentTypes['FloatProperty'] | ResolversParentTypes['GroupProperty'] | ResolversParentTypes['IntegerProperty'] | ResolversParentTypes['MarkdownProperty'] | ResolversParentTypes['MultiselectProperty'] | ResolversParentTypes['SelectProperty'] | ResolversParentTypes['StringProperty'] | ResolversParentTypes['TagsProperty'] | ResolversParentTypes['TimestampProperty'] | ResolversParentTypes['UnknownProperty'];
  AnyUserAccessGrant: ResolversParentTypes['UserCollectionAccessGrant'] | ResolversParentTypes['UserCommunityAccessGrant'] | ResolversParentTypes['UserItemAccessGrant'];
  AnyUserAccessGrantConnection: Omit<AnyUserAccessGrantConnection, 'nodes'> & { nodes: Array<ResolversParentTypes['AnyUserAccessGrant']> };
  AnyUserAccessGrantEdge: Omit<AnyUserAccessGrantEdge, 'node'> & { node: ResolversParentTypes['AnyUserAccessGrant'] };
  AnyUserGroupAccessGrant: ResolversParentTypes['UserGroupCollectionAccessGrant'] | ResolversParentTypes['UserGroupCommunityAccessGrant'] | ResolversParentTypes['UserGroupItemAccessGrant'];
  AnyUserGroupAccessGrantConnection: Omit<AnyUserGroupAccessGrantConnection, 'nodes'> & { nodes: Array<ResolversParentTypes['AnyUserGroupAccessGrant']> };
  AnyUserGroupAccessGrantEdge: Omit<AnyUserGroupAccessGrantEdge, 'node'> & { node: ResolversParentTypes['AnyUserGroupAccessGrant'] };
  ApplySchemaPropertiesInput: ApplySchemaPropertiesInput;
  ApplySchemaPropertiesPayload: Omit<ApplySchemaPropertiesPayload, 'entity'> & { entity?: Maybe<ResolversParentTypes['AnyEntity']> };
  Asset: ResolversParentTypes['AssetAudio'] | ResolversParentTypes['AssetDocument'] | ResolversParentTypes['AssetImage'] | ResolversParentTypes['AssetPDF'] | ResolversParentTypes['AssetUnknown'] | ResolversParentTypes['AssetVideo'];
  AssetAudio: Omit<AssetAudio, 'attachable'> & { attachable: ResolversParentTypes['AnyAttachable'] };
  AssetDocument: Omit<AssetDocument, 'attachable'> & { attachable: ResolversParentTypes['AnyAttachable'] };
  AssetImage: Omit<AssetImage, 'attachable'> & { attachable: ResolversParentTypes['AnyAttachable'] };
  AssetPDF: Omit<AssetPdf, 'attachable'> & { attachable: ResolversParentTypes['AnyAttachable'] };
  AssetPreview: AssetPreview;
  AssetProperty: Omit<AssetProperty, 'asset'> & { asset?: Maybe<ResolversParentTypes['AnyAsset']> };
  Boolean: Scalars['Boolean'];
  AssetSelectOption: AssetSelectOption;
  AssetUnknown: Omit<AssetUnknown, 'attachable'> & { attachable: ResolversParentTypes['AnyAttachable'] };
  AssetVideo: Omit<AssetVideo, 'attachable'> & { attachable: ResolversParentTypes['AnyAttachable'] };
  AssetsProperty: Omit<AssetsProperty, 'assets'> & { assets: Array<ResolversParentTypes['AnyAsset']> };
  Attachable: ResolversParentTypes['Collection'] | ResolversParentTypes['Community'] | ResolversParentTypes['Item'];
  BooleanProperty: BooleanProperty;
  Collection: Omit<Collection, 'parent' | 'schemaProperties'> & { parent?: Maybe<ResolversParentTypes['CollectionParent']>, schemaProperties: Array<ResolversParentTypes['AnySchemaProperty']> };
  CollectionConnection: CollectionConnection;
  CollectionContribution: Omit<CollectionContribution, 'contributor'> & { contributor: ResolversParentTypes['AnyContributor'] };
  CollectionContributionConnection: CollectionContributionConnection;
  CollectionContributionEdge: CollectionContributionEdge;
  CollectionEdge: CollectionEdge;
  CollectionParent: ResolversParentTypes['Collection'] | ResolversParentTypes['Community'];
  Community: Omit<Community, 'schemaProperties'> & { schemaProperties: Array<ResolversParentTypes['AnySchemaProperty']> };
  CommunityConnection: CommunityConnection;
  CommunityEdge: CommunityEdge;
  ContextualPermission: Omit<ContextualPermission, 'accessGrants'> & { accessGrants: Array<ResolversParentTypes['AnyUserAccessGrant']> };
  ContextualPermissionConnection: ContextualPermissionConnection;
  ContextualPermissionEdge: ContextualPermissionEdge;
  Contributable: ResolversParentTypes['Collection'] | ResolversParentTypes['Item'];
  Contribution: ResolversParentTypes['CollectionContribution'] | ResolversParentTypes['ItemContribution'];
  ContributionMetadata: ContributionMetadata;
  ContributionMetadataInput: ContributionMetadataInput;
  Contributor: ResolversParentTypes['OrganizationContributor'] | ResolversParentTypes['PersonContributor'];
  ContributorLink: ContributorLink;
  ContributorLinkInput: ContributorLinkInput;
  ContributorProperty: Omit<ContributorProperty, 'contributor'> & { contributor?: Maybe<ResolversParentTypes['AnyContributor']> };
  ContributorSelectOption: ContributorSelectOption;
  ContributorsProperty: Omit<ContributorsProperty, 'contributors'> & { contributors: Array<ResolversParentTypes['AnyContributor']> };
  CreateAssetInput: CreateAssetInput;
  CreateAssetPayload: Omit<CreateAssetPayload, 'asset'> & { asset?: Maybe<ResolversParentTypes['AnyAsset']> };
  CreateCollectionInput: CreateCollectionInput;
  CreateCollectionPayload: CreateCollectionPayload;
  CreateCommunityInput: CreateCommunityInput;
  CreateCommunityPayload: CreateCommunityPayload;
  CreateItemInput: CreateItemInput;
  CreateItemPayload: CreateItemPayload;
  CreateOrderingInput: CreateOrderingInput;
  CreateOrderingPayload: CreateOrderingPayload;
  CreateOrganizationContributorInput: CreateOrganizationContributorInput;
  CreateOrganizationContributorPayload: CreateOrganizationContributorPayload;
  CreatePersonContributorInput: CreatePersonContributorInput;
  CreatePersonContributorPayload: CreatePersonContributorPayload;
  CreateRoleInput: CreateRoleInput;
  CreateRolePayload: CreateRolePayload;
  DateProperty: DateProperty;
  DestroyCollectionInput: DestroyCollectionInput;
  DestroyCollectionPayload: DestroyCollectionPayload;
  DestroyCommunityInput: DestroyCommunityInput;
  DestroyCommunityPayload: DestroyCommunityPayload;
  DestroyContributionInput: DestroyContributionInput;
  DestroyContributionPayload: DestroyContributionPayload;
  DestroyContributorInput: DestroyContributorInput;
  DestroyContributorPayload: DestroyContributorPayload;
  DestroyEntityLinkInput: DestroyEntityLinkInput;
  DestroyEntityLinkPayload: DestroyEntityLinkPayload;
  DestroyItemInput: DestroyItemInput;
  DestroyItemPayload: DestroyItemPayload;
  DestroyMutationPayload: ResolversParentTypes['DestroyCollectionPayload'] | ResolversParentTypes['DestroyCommunityPayload'] | ResolversParentTypes['DestroyContributionPayload'] | ResolversParentTypes['DestroyContributorPayload'] | ResolversParentTypes['DestroyEntityLinkPayload'] | ResolversParentTypes['DestroyItemPayload'] | ResolversParentTypes['DestroyOrderingPayload'];
  DestroyOrderingInput: DestroyOrderingInput;
  DestroyOrderingPayload: DestroyOrderingPayload;
  EmailProperty: EmailProperty;
  Entity: ResolversParentTypes['Collection'] | ResolversParentTypes['Community'] | ResolversParentTypes['Item'];
  EntityBreadcrumb: Omit<EntityBreadcrumb, 'crumb'> & { crumb: ResolversParentTypes['AnyEntity'] };
  EntityLink: Omit<EntityLink, 'source' | 'target'> & { source: ResolversParentTypes['AnyEntity'], target: ResolversParentTypes['AnyEntity'] };
  EntityLinkConnection: EntityLinkConnection;
  EntityLinkEdge: EntityLinkEdge;
  ExposesPermissions: ResolversParentTypes['ContextualPermission'] | ResolversParentTypes['User'];
  FloatProperty: FloatProperty;
  Float: Scalars['Float'];
  GrantAccessInput: GrantAccessInput;
  GrantAccessPayload: Omit<GrantAccessPayload, 'entity'> & { entity?: Maybe<ResolversParentTypes['AnyEntity']> };
  GroupProperty: Omit<GroupProperty, 'properties'> & { properties: Array<ResolversParentTypes['AnyScalarProperty']> };
  HasSchemaProperties: ResolversParentTypes['Collection'] | ResolversParentTypes['Community'] | ResolversParentTypes['Item'] | ResolversParentTypes['SchemaVersion'];
  HierarchicalEntry: ResolversParentTypes['Collection'] | ResolversParentTypes['Item'];
  ISO8601Date: Scalars['ISO8601Date'];
  ISO8601DateTime: Scalars['ISO8601DateTime'];
  IntegerProperty: IntegerProperty;
  Item: Omit<Item, 'parent' | 'schemaProperties'> & { parent?: Maybe<ResolversParentTypes['ItemParent']>, schemaProperties: Array<ResolversParentTypes['AnySchemaProperty']> };
  ItemConnection: ItemConnection;
  ItemContribution: Omit<ItemContribution, 'contributor'> & { contributor: ResolversParentTypes['AnyContributor'] };
  ItemContributionConnection: ItemContributionConnection;
  ItemContributionEdge: ItemContributionEdge;
  ItemEdge: ItemEdge;
  ItemParent: ResolversParentTypes['Collection'] | ResolversParentTypes['Item'];
  JSON: Scalars['JSON'];
  LinkEntityInput: LinkEntityInput;
  LinkEntityPayload: LinkEntityPayload;
  MarkdownProperty: MarkdownProperty;
  MultiselectProperty: MultiselectProperty;
  Mutation: {};
  MutationAttributeError: MutationAttributeError;
  MutationGlobalError: MutationGlobalError;
  Node: ResolversParentTypes['AssetAudio'] | ResolversParentTypes['AssetDocument'] | ResolversParentTypes['AssetImage'] | ResolversParentTypes['AssetPDF'] | ResolversParentTypes['AssetUnknown'] | ResolversParentTypes['AssetVideo'] | ResolversParentTypes['Collection'] | ResolversParentTypes['CollectionContribution'] | ResolversParentTypes['Community'] | ResolversParentTypes['ContextualPermission'] | ResolversParentTypes['EntityBreadcrumb'] | ResolversParentTypes['EntityLink'] | ResolversParentTypes['Item'] | ResolversParentTypes['ItemContribution'] | ResolversParentTypes['Ordering'] | ResolversParentTypes['OrderingEntry'] | ResolversParentTypes['OrganizationContributor'] | ResolversParentTypes['PersonContributor'] | ResolversParentTypes['Role'] | ResolversParentTypes['SchemaDefinition'] | ResolversParentTypes['SchemaVersion'] | ResolversParentTypes['User'] | ResolversParentTypes['UserCollectionAccessGrant'] | ResolversParentTypes['UserCommunityAccessGrant'] | ResolversParentTypes['UserGroup'] | ResolversParentTypes['UserGroupCollectionAccessGrant'] | ResolversParentTypes['UserGroupCommunityAccessGrant'] | ResolversParentTypes['UserGroupItemAccessGrant'] | ResolversParentTypes['UserItemAccessGrant'];
  OptionableProperty: ResolversParentTypes['MultiselectProperty'] | ResolversParentTypes['SelectProperty'];
  OrderDefinitionInput: OrderDefinitionInput;
  Ordering: Omit<Ordering, 'entity'> & { entity: ResolversParentTypes['AnyEntity'] };
  OrderingConnection: OrderingConnection;
  OrderingEdge: OrderingEdge;
  OrderingEntry: Omit<OrderingEntry, 'entry'> & { entry: ResolversParentTypes['AnyOrderingEntry'] };
  OrderingEntryConnection: OrderingEntryConnection;
  OrderingEntryEdge: OrderingEntryEdge;
  OrderingFilterDefinitionInput: OrderingFilterDefinitionInput;
  OrderingSelectDefinitionInput: OrderingSelectDefinitionInput;
  OrderingSelectLinkDefinitionInput: OrderingSelectLinkDefinitionInput;
  OrganizationContributor: OrganizationContributor;
  PageInfo: PageInfo;
  Paginated: ResolversParentTypes['AnyAccessGrantConnection'] | ResolversParentTypes['AnyAssetConnection'] | ResolversParentTypes['AnyCollectionAccessGrantConnection'] | ResolversParentTypes['AnyCommunityAccessGrantConnection'] | ResolversParentTypes['AnyContributorConnection'] | ResolversParentTypes['AnyUserAccessGrantConnection'] | ResolversParentTypes['AnyUserGroupAccessGrantConnection'] | ResolversParentTypes['CollectionConnection'] | ResolversParentTypes['CollectionContributionConnection'] | ResolversParentTypes['CommunityConnection'] | ResolversParentTypes['ContextualPermissionConnection'] | ResolversParentTypes['EntityLinkConnection'] | ResolversParentTypes['ItemConnection'] | ResolversParentTypes['ItemContributionConnection'] | ResolversParentTypes['OrderingConnection'] | ResolversParentTypes['OrderingEntryConnection'] | ResolversParentTypes['RoleConnection'] | ResolversParentTypes['SchemaDefinitionConnection'] | ResolversParentTypes['SchemaVersionConnection'] | ResolversParentTypes['UserCollectionAccessGrantConnection'] | ResolversParentTypes['UserCommunityAccessGrantConnection'] | ResolversParentTypes['UserConnection'] | ResolversParentTypes['UserGroupCollectionAccessGrantConnection'] | ResolversParentTypes['UserGroupCommunityAccessGrantConnection'] | ResolversParentTypes['UserGroupItemAccessGrantConnection'] | ResolversParentTypes['UserItemAccessGrantConnection'];
  PermissionGrant: PermissionGrant;
  PersonContributor: PersonContributor;
  PreviewImage: PreviewImage;
  PreviewImageMap: PreviewImageMap;
  Query: {};
  ReparentCollectionInput: ReparentCollectionInput;
  ReparentCollectionPayload: ReparentCollectionPayload;
  ReparentItemInput: ReparentItemInput;
  ReparentItemPayload: ReparentItemPayload;
  ResetOrderingInput: ResetOrderingInput;
  ResetOrderingPayload: ResetOrderingPayload;
  RevokeAccessInput: RevokeAccessInput;
  RevokeAccessPayload: Omit<RevokeAccessPayload, 'entity'> & { entity?: Maybe<ResolversParentTypes['AnyEntity']> };
  Role: Role;
  RoleConnection: RoleConnection;
  RoleEdge: RoleEdge;
  ScalarProperty: ResolversParentTypes['AssetProperty'] | ResolversParentTypes['AssetsProperty'] | ResolversParentTypes['BooleanProperty'] | ResolversParentTypes['ContributorProperty'] | ResolversParentTypes['ContributorsProperty'] | ResolversParentTypes['DateProperty'] | ResolversParentTypes['EmailProperty'] | ResolversParentTypes['FloatProperty'] | ResolversParentTypes['IntegerProperty'] | ResolversParentTypes['MarkdownProperty'] | ResolversParentTypes['MultiselectProperty'] | ResolversParentTypes['SelectProperty'] | ResolversParentTypes['StringProperty'] | ResolversParentTypes['TagsProperty'] | ResolversParentTypes['TimestampProperty'] | ResolversParentTypes['UnknownProperty'];
  SchemaDefinition: SchemaDefinition;
  SchemaDefinitionConnection: SchemaDefinitionConnection;
  SchemaDefinitionEdge: SchemaDefinitionEdge;
  SchemaInstance: ResolversParentTypes['Collection'] | ResolversParentTypes['Community'] | ResolversParentTypes['Item'];
  SchemaInstanceContext: SchemaInstanceContext;
  SchemaInstanceValidation: SchemaInstanceValidation;
  SchemaProperty: ResolversParentTypes['GroupProperty'];
  SchemaValueError: SchemaValueError;
  SchemaVersion: Omit<SchemaVersion, 'schemaProperties'> & { schemaProperties: Array<ResolversParentTypes['AnySchemaProperty']> };
  SchemaVersionConnection: SchemaVersionConnection;
  SchemaVersionEdge: SchemaVersionEdge;
  SchemaVersionOption: SchemaVersionOption;
  SelectOption: SelectOption;
  SelectProperty: SelectProperty;
  Slug: Scalars['Slug'];
  Sluggable: ResolversParentTypes['AssetAudio'] | ResolversParentTypes['AssetDocument'] | ResolversParentTypes['AssetImage'] | ResolversParentTypes['AssetPDF'] | ResolversParentTypes['AssetUnknown'] | ResolversParentTypes['AssetVideo'] | ResolversParentTypes['Collection'] | ResolversParentTypes['CollectionContribution'] | ResolversParentTypes['Community'] | ResolversParentTypes['ContextualPermission'] | ResolversParentTypes['EntityLink'] | ResolversParentTypes['Item'] | ResolversParentTypes['ItemContribution'] | ResolversParentTypes['Ordering'] | ResolversParentTypes['OrderingEntry'] | ResolversParentTypes['OrganizationContributor'] | ResolversParentTypes['PersonContributor'] | ResolversParentTypes['Role'] | ResolversParentTypes['SchemaDefinition'] | ResolversParentTypes['SchemaVersion'] | ResolversParentTypes['User'] | ResolversParentTypes['UserCollectionAccessGrant'] | ResolversParentTypes['UserCommunityAccessGrant'] | ResolversParentTypes['UserGroup'] | ResolversParentTypes['UserGroupCollectionAccessGrant'] | ResolversParentTypes['UserGroupCommunityAccessGrant'] | ResolversParentTypes['UserGroupItemAccessGrant'] | ResolversParentTypes['UserItemAccessGrant'];
  StandardMutationPayload: ResolversParentTypes['AlterSchemaVersionPayload'] | ResolversParentTypes['ApplySchemaPropertiesPayload'] | ResolversParentTypes['CreateAssetPayload'] | ResolversParentTypes['CreateCollectionPayload'] | ResolversParentTypes['CreateCommunityPayload'] | ResolversParentTypes['CreateItemPayload'] | ResolversParentTypes['CreateOrderingPayload'] | ResolversParentTypes['CreateOrganizationContributorPayload'] | ResolversParentTypes['CreatePersonContributorPayload'] | ResolversParentTypes['CreateRolePayload'] | ResolversParentTypes['DestroyCollectionPayload'] | ResolversParentTypes['DestroyCommunityPayload'] | ResolversParentTypes['DestroyContributionPayload'] | ResolversParentTypes['DestroyContributorPayload'] | ResolversParentTypes['DestroyEntityLinkPayload'] | ResolversParentTypes['DestroyItemPayload'] | ResolversParentTypes['DestroyOrderingPayload'] | ResolversParentTypes['GrantAccessPayload'] | ResolversParentTypes['LinkEntityPayload'] | ResolversParentTypes['ReparentCollectionPayload'] | ResolversParentTypes['ReparentItemPayload'] | ResolversParentTypes['ResetOrderingPayload'] | ResolversParentTypes['RevokeAccessPayload'] | ResolversParentTypes['UpdateCollectionPayload'] | ResolversParentTypes['UpdateCommunityPayload'] | ResolversParentTypes['UpdateContributionPayload'] | ResolversParentTypes['UpdateItemPayload'] | ResolversParentTypes['UpdateOrderingPayload'] | ResolversParentTypes['UpdateOrganizationContributorPayload'] | ResolversParentTypes['UpdatePersonContributorPayload'] | ResolversParentTypes['UpdateRolePayload'] | ResolversParentTypes['UpsertContributionPayload'];
  StringProperty: StringProperty;
  TagsProperty: TagsProperty;
  TimestampProperty: TimestampProperty;
  UnknownProperty: UnknownProperty;
  UpdateCollectionInput: UpdateCollectionInput;
  UpdateCollectionPayload: UpdateCollectionPayload;
  UpdateCommunityInput: UpdateCommunityInput;
  UpdateCommunityPayload: UpdateCommunityPayload;
  UpdateContributionInput: UpdateContributionInput;
  UpdateContributionPayload: Omit<UpdateContributionPayload, 'contribution'> & { contribution?: Maybe<ResolversParentTypes['AnyContribution']> };
  UpdateItemInput: UpdateItemInput;
  UpdateItemPayload: UpdateItemPayload;
  UpdateOrderingInput: UpdateOrderingInput;
  UpdateOrderingPayload: UpdateOrderingPayload;
  UpdateOrganizationContributorInput: UpdateOrganizationContributorInput;
  UpdateOrganizationContributorPayload: UpdateOrganizationContributorPayload;
  UpdatePersonContributorInput: UpdatePersonContributorInput;
  UpdatePersonContributorPayload: UpdatePersonContributorPayload;
  UpdateRoleInput: UpdateRoleInput;
  UpdateRolePayload: UpdateRolePayload;
  UploadID: Scalars['UploadID'];
  UploadedFileInput: UploadedFileInput;
  UploadedFileMetadataInput: UploadedFileMetadataInput;
  UpsertContributionInput: UpsertContributionInput;
  UpsertContributionPayload: Omit<UpsertContributionPayload, 'contribution'> & { contribution?: Maybe<ResolversParentTypes['AnyContribution']> };
  User: User;
  UserAccessGrant: ResolversParentTypes['UserCollectionAccessGrant'] | ResolversParentTypes['UserCommunityAccessGrant'] | ResolversParentTypes['UserItemAccessGrant'];
  UserCollectionAccessGrant: Omit<UserCollectionAccessGrant, 'entity'> & { entity: ResolversParentTypes['AnyEntity'] };
  UserCollectionAccessGrantConnection: UserCollectionAccessGrantConnection;
  UserCollectionAccessGrantEdge: UserCollectionAccessGrantEdge;
  UserCommunityAccessGrant: Omit<UserCommunityAccessGrant, 'entity'> & { entity: ResolversParentTypes['AnyEntity'] };
  UserCommunityAccessGrantConnection: UserCommunityAccessGrantConnection;
  UserCommunityAccessGrantEdge: UserCommunityAccessGrantEdge;
  UserConnection: UserConnection;
  UserEdge: UserEdge;
  UserError: UserError;
  UserGroup: UserGroup;
  UserGroupAccessGrant: ResolversParentTypes['UserGroupCollectionAccessGrant'] | ResolversParentTypes['UserGroupCommunityAccessGrant'] | ResolversParentTypes['UserGroupItemAccessGrant'];
  UserGroupCollectionAccessGrant: Omit<UserGroupCollectionAccessGrant, 'entity'> & { entity: ResolversParentTypes['AnyEntity'] };
  UserGroupCollectionAccessGrantConnection: UserGroupCollectionAccessGrantConnection;
  UserGroupCollectionAccessGrantEdge: UserGroupCollectionAccessGrantEdge;
  UserGroupCommunityAccessGrant: Omit<UserGroupCommunityAccessGrant, 'entity'> & { entity: ResolversParentTypes['AnyEntity'] };
  UserGroupCommunityAccessGrantConnection: UserGroupCommunityAccessGrantConnection;
  UserGroupCommunityAccessGrantEdge: UserGroupCommunityAccessGrantEdge;
  UserGroupItemAccessGrant: Omit<UserGroupItemAccessGrant, 'entity'> & { entity: ResolversParentTypes['AnyEntity'] };
  UserGroupItemAccessGrantConnection: UserGroupItemAccessGrantConnection;
  UserGroupItemAccessGrantEdge: UserGroupItemAccessGrantEdge;
  UserItemAccessGrant: Omit<UserItemAccessGrant, 'entity'> & { entity: ResolversParentTypes['AnyEntity'] };
  UserItemAccessGrantConnection: UserItemAccessGrantConnection;
  UserItemAccessGrantEdge: UserItemAccessGrantEdge;
};

export type AccessControlListResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccessControlList'] = ResolversParentTypes['AccessControlList']> = {
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AccessGrantResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccessGrant'] = ResolversParentTypes['AccessGrant']> = {
  __resolveType: TypeResolveFn<'UserCollectionAccessGrant' | 'UserCommunityAccessGrant' | 'UserGroupCollectionAccessGrant' | 'UserGroupCommunityAccessGrant' | 'UserGroupItemAccessGrant' | 'UserItemAccessGrant', ParentType, ContextType>;
  entity?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['Role'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['AccessGrantSubject'], ParentType, ContextType>;
};

export type AccessGrantSubjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccessGrantSubject'] = ResolversParentTypes['AccessGrantSubject']> = {
  __resolveType: TypeResolveFn<'User' | 'UserGroup', ParentType, ContextType>;
  allAccessGrants?: Resolver<ResolversTypes['AnyAccessGrantConnection'], ParentType, ContextType, RequireFields<AccessGrantSubjectAllAccessGrantsArgs, 'entity' | 'order' | 'pageDirection' | 'perPage'>>;
};

export type AccessibleResolvers<ContextType = any, ParentType extends ResolversParentTypes['Accessible'] = ResolversParentTypes['Accessible']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Community' | 'Item', ParentType, ContextType>;
  allAccessGrants?: Resolver<ResolversTypes['AnyAccessGrantConnection'], ParentType, ContextType, RequireFields<AccessibleAllAccessGrantsArgs, 'subject' | 'order' | 'pageDirection' | 'perPage'>>;
};

export type AlterSchemaVersionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['AlterSchemaVersionPayload'] = ResolversParentTypes['AlterSchemaVersionPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  community?: Resolver<Maybe<ResolversTypes['Community']>, ParentType, ContextType>;
  entity?: Resolver<Maybe<ResolversTypes['AnyEntity']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['Item']>, ParentType, ContextType>;
  schemaErrors?: Resolver<Array<ResolversTypes['SchemaValueError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyAccessGrantResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyAccessGrant'] = ResolversParentTypes['AnyAccessGrant']> = {
  __resolveType: TypeResolveFn<'UserCollectionAccessGrant' | 'UserCommunityAccessGrant' | 'UserGroupCollectionAccessGrant' | 'UserGroupCommunityAccessGrant' | 'UserGroupItemAccessGrant' | 'UserItemAccessGrant', ParentType, ContextType>;
};

export type AnyAccessGrantConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyAccessGrantConnection'] = ResolversParentTypes['AnyAccessGrantConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AnyAccessGrantEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['AnyAccessGrant']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyAccessGrantEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyAccessGrantEdge'] = ResolversParentTypes['AnyAccessGrantEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['AnyAccessGrant'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyAssetResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyAsset'] = ResolversParentTypes['AnyAsset']> = {
  __resolveType: TypeResolveFn<'AssetAudio' | 'AssetDocument' | 'AssetImage' | 'AssetPDF' | 'AssetUnknown' | 'AssetVideo', ParentType, ContextType>;
};

export type AnyAssetConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyAssetConnection'] = ResolversParentTypes['AnyAssetConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AnyAssetEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['AnyAsset']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyAssetEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyAssetEdge'] = ResolversParentTypes['AnyAssetEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['AnyAsset'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyAttachableResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyAttachable'] = ResolversParentTypes['AnyAttachable']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Community' | 'Item', ParentType, ContextType>;
};

export type AnyCollectionAccessGrantResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyCollectionAccessGrant'] = ResolversParentTypes['AnyCollectionAccessGrant']> = {
  __resolveType: TypeResolveFn<'UserCollectionAccessGrant' | 'UserGroupCollectionAccessGrant', ParentType, ContextType>;
};

export type AnyCollectionAccessGrantConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyCollectionAccessGrantConnection'] = ResolversParentTypes['AnyCollectionAccessGrantConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AnyCollectionAccessGrantEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['AnyCollectionAccessGrant']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyCollectionAccessGrantEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyCollectionAccessGrantEdge'] = ResolversParentTypes['AnyCollectionAccessGrantEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['AnyCollectionAccessGrant'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyCommunityAccessGrantResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyCommunityAccessGrant'] = ResolversParentTypes['AnyCommunityAccessGrant']> = {
  __resolveType: TypeResolveFn<'UserCommunityAccessGrant' | 'UserGroupCommunityAccessGrant', ParentType, ContextType>;
};

export type AnyCommunityAccessGrantConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyCommunityAccessGrantConnection'] = ResolversParentTypes['AnyCommunityAccessGrantConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AnyCommunityAccessGrantEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['AnyCommunityAccessGrant']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyCommunityAccessGrantEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyCommunityAccessGrantEdge'] = ResolversParentTypes['AnyCommunityAccessGrantEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['AnyCommunityAccessGrant'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyContributionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyContribution'] = ResolversParentTypes['AnyContribution']> = {
  __resolveType: TypeResolveFn<'CollectionContribution' | 'ItemContribution', ParentType, ContextType>;
};

export type AnyContributorResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyContributor'] = ResolversParentTypes['AnyContributor']> = {
  __resolveType: TypeResolveFn<'OrganizationContributor' | 'PersonContributor', ParentType, ContextType>;
};

export type AnyContributorConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyContributorConnection'] = ResolversParentTypes['AnyContributorConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AnyContributorEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['AnyContributor']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyContributorEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyContributorEdge'] = ResolversParentTypes['AnyContributorEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['AnyContributor'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyEntityResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyEntity'] = ResolversParentTypes['AnyEntity']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Community' | 'Item', ParentType, ContextType>;
};

export type AnyOrderingEntryResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyOrderingEntry'] = ResolversParentTypes['AnyOrderingEntry']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Community' | 'EntityLink' | 'Item', ParentType, ContextType>;
};

export type AnyScalarPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyScalarProperty'] = ResolversParentTypes['AnyScalarProperty']> = {
  __resolveType: TypeResolveFn<'AssetProperty' | 'AssetsProperty' | 'BooleanProperty' | 'ContributorProperty' | 'ContributorsProperty' | 'DateProperty' | 'EmailProperty' | 'FloatProperty' | 'IntegerProperty' | 'MarkdownProperty' | 'MultiselectProperty' | 'SelectProperty' | 'StringProperty' | 'TagsProperty' | 'TimestampProperty' | 'UnknownProperty', ParentType, ContextType>;
};

export type AnySchemaPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnySchemaProperty'] = ResolversParentTypes['AnySchemaProperty']> = {
  __resolveType: TypeResolveFn<'AssetProperty' | 'AssetsProperty' | 'BooleanProperty' | 'ContributorProperty' | 'ContributorsProperty' | 'DateProperty' | 'EmailProperty' | 'FloatProperty' | 'GroupProperty' | 'IntegerProperty' | 'MarkdownProperty' | 'MultiselectProperty' | 'SelectProperty' | 'StringProperty' | 'TagsProperty' | 'TimestampProperty' | 'UnknownProperty', ParentType, ContextType>;
};

export type AnyUserAccessGrantResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyUserAccessGrant'] = ResolversParentTypes['AnyUserAccessGrant']> = {
  __resolveType: TypeResolveFn<'UserCollectionAccessGrant' | 'UserCommunityAccessGrant' | 'UserItemAccessGrant', ParentType, ContextType>;
};

export type AnyUserAccessGrantConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyUserAccessGrantConnection'] = ResolversParentTypes['AnyUserAccessGrantConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AnyUserAccessGrantEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['AnyUserAccessGrant']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyUserAccessGrantEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyUserAccessGrantEdge'] = ResolversParentTypes['AnyUserAccessGrantEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['AnyUserAccessGrant'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyUserGroupAccessGrantResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyUserGroupAccessGrant'] = ResolversParentTypes['AnyUserGroupAccessGrant']> = {
  __resolveType: TypeResolveFn<'UserGroupCollectionAccessGrant' | 'UserGroupCommunityAccessGrant' | 'UserGroupItemAccessGrant', ParentType, ContextType>;
};

export type AnyUserGroupAccessGrantConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyUserGroupAccessGrantConnection'] = ResolversParentTypes['AnyUserGroupAccessGrantConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AnyUserGroupAccessGrantEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['AnyUserGroupAccessGrant']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyUserGroupAccessGrantEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyUserGroupAccessGrantEdge'] = ResolversParentTypes['AnyUserGroupAccessGrantEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['AnyUserGroupAccessGrant'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplySchemaPropertiesPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplySchemaPropertiesPayload'] = ResolversParentTypes['ApplySchemaPropertiesPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  community?: Resolver<Maybe<ResolversTypes['Community']>, ParentType, ContextType>;
  entity?: Resolver<Maybe<ResolversTypes['AnyEntity']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['Item']>, ParentType, ContextType>;
  schemaErrors?: Resolver<Array<ResolversTypes['SchemaValueError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetResolvers<ContextType = any, ParentType extends ResolversParentTypes['Asset'] = ResolversParentTypes['Asset']> = {
  __resolveType: TypeResolveFn<'AssetAudio' | 'AssetDocument' | 'AssetImage' | 'AssetPDF' | 'AssetUnknown' | 'AssetVideo', ParentType, ContextType>;
  attachable?: Resolver<ResolversTypes['AnyAttachable'], ParentType, ContextType>;
  caption?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  downloadUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['AssetKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preview?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
};

export type AssetAudioResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetAudio'] = ResolversParentTypes['AssetAudio']> = {
  attachable?: Resolver<ResolversTypes['AnyAttachable'], ParentType, ContextType>;
  caption?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  downloadUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['AssetKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preview?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetDocumentResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetDocument'] = ResolversParentTypes['AssetDocument']> = {
  attachable?: Resolver<ResolversTypes['AnyAttachable'], ParentType, ContextType>;
  caption?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  downloadUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['AssetKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preview?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetImageResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetImage'] = ResolversParentTypes['AssetImage']> = {
  attachable?: Resolver<ResolversTypes['AnyAttachable'], ParentType, ContextType>;
  caption?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  downloadUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['AssetKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preview?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetPdfResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetPDF'] = ResolversParentTypes['AssetPDF']> = {
  attachable?: Resolver<ResolversTypes['AnyAttachable'], ParentType, ContextType>;
  caption?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  downloadUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['AssetKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preview?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetPreviewResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetPreview'] = ResolversParentTypes['AssetPreview']> = {
  alt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  large?: Resolver<ResolversTypes['PreviewImageMap'], ParentType, ContextType>;
  medium?: Resolver<ResolversTypes['PreviewImageMap'], ParentType, ContextType>;
  small?: Resolver<ResolversTypes['PreviewImageMap'], ParentType, ContextType>;
  thumb?: Resolver<ResolversTypes['PreviewImageMap'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetProperty'] = ResolversParentTypes['AssetProperty']> = {
  asset?: Resolver<Maybe<ResolversTypes['AnyAsset']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetSelectOptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetSelectOption'] = ResolversParentTypes['AssetSelectOption']> = {
  kind?: Resolver<ResolversTypes['AssetKind'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetUnknownResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetUnknown'] = ResolversParentTypes['AssetUnknown']> = {
  attachable?: Resolver<ResolversTypes['AnyAttachable'], ParentType, ContextType>;
  caption?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  downloadUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['AssetKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preview?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetVideoResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetVideo'] = ResolversParentTypes['AssetVideo']> = {
  attachable?: Resolver<ResolversTypes['AnyAttachable'], ParentType, ContextType>;
  caption?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  downloadUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['AssetKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preview?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetsPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetsProperty'] = ResolversParentTypes['AssetsProperty']> = {
  assets?: Resolver<Array<ResolversTypes['AnyAsset']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttachableResolvers<ContextType = any, ParentType extends ResolversParentTypes['Attachable'] = ResolversParentTypes['Attachable']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Community' | 'Item', ParentType, ContextType>;
  assets?: Resolver<ResolversTypes['AnyAssetConnection'], ParentType, ContextType, RequireFields<AttachableAssetsArgs, 'order' | 'kind' | 'pageDirection' | 'perPage'>>;
};

export type BooleanPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['BooleanProperty'] = ResolversParentTypes['BooleanProperty']> = {
  checked?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  checkedByDefault?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Collection'] = ResolversParentTypes['Collection']> = {
  accessControlList?: Resolver<Maybe<ResolversTypes['AccessControlList']>, ParentType, ContextType>;
  accessGrants?: Resolver<ResolversTypes['AnyCollectionAccessGrantConnection'], ParentType, ContextType, RequireFields<CollectionAccessGrantsArgs, 'subject' | 'order' | 'pageDirection' | 'perPage'>>;
  allAccessGrants?: Resolver<ResolversTypes['AnyAccessGrantConnection'], ParentType, ContextType, RequireFields<CollectionAllAccessGrantsArgs, 'subject' | 'order' | 'pageDirection' | 'perPage'>>;
  allowedActions?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  applicableRoles?: Resolver<Maybe<Array<ResolversTypes['Role']>>, ParentType, ContextType>;
  assets?: Resolver<ResolversTypes['AnyAssetConnection'], ParentType, ContextType, RequireFields<CollectionAssetsArgs, 'order' | 'kind' | 'pageDirection' | 'perPage'>>;
  assignedUsers?: Resolver<ResolversTypes['ContextualPermissionConnection'], ParentType, ContextType, RequireFields<CollectionAssignedUsersArgs, 'order' | 'pageDirection' | 'perPage'>>;
  breadcrumbs?: Resolver<Array<ResolversTypes['EntityBreadcrumb']>, ParentType, ContextType>;
  children?: Resolver<ResolversTypes['CollectionConnection'], ParentType, ContextType, RequireFields<CollectionChildrenArgs, never>>;
  collections?: Resolver<ResolversTypes['CollectionConnection'], ParentType, ContextType, RequireFields<CollectionCollectionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  community?: Resolver<ResolversTypes['Community'], ParentType, ContextType>;
  contributions?: Resolver<ResolversTypes['CollectionContributionConnection'], ParentType, ContextType, RequireFields<CollectionContributionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  contributors?: Resolver<ResolversTypes['AnyContributorConnection'], ParentType, ContextType, RequireFields<CollectionContributorsArgs, 'order' | 'kind' | 'pageDirection' | 'perPage'>>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  doi?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hidden?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hiddenAt?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
  hierarchicalDepth?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  items?: Resolver<ResolversTypes['ItemConnection'], ParentType, ContextType, RequireFields<CollectionItemsArgs, 'order' | 'nodeFilter' | 'pageDirection' | 'perPage'>>;
  leaf?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  links?: Resolver<ResolversTypes['EntityLinkConnection'], ParentType, ContextType, RequireFields<CollectionLinksArgs, 'order' | 'pageDirection' | 'perPage'>>;
  ordering?: Resolver<Maybe<ResolversTypes['Ordering']>, ParentType, ContextType, RequireFields<CollectionOrderingArgs, 'identifier'>>;
  orderings?: Resolver<ResolversTypes['OrderingConnection'], ParentType, ContextType, RequireFields<CollectionOrderingsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  parent?: Resolver<Maybe<ResolversTypes['CollectionParent']>, ParentType, ContextType>;
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
  publishedOn?: Resolver<Maybe<ResolversTypes['ISO8601Date']>, ParentType, ContextType>;
  root?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  schemaDefinition?: Resolver<ResolversTypes['SchemaDefinition'], ParentType, ContextType>;
  schemaInstanceContext?: Resolver<ResolversTypes['SchemaInstanceContext'], ParentType, ContextType>;
  schemaProperties?: Resolver<Array<ResolversTypes['AnySchemaProperty']>, ParentType, ContextType>;
  schemaVersion?: Resolver<ResolversTypes['SchemaVersion'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  summary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  thumbnail?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  userAccessGrants?: Resolver<ResolversTypes['UserCollectionAccessGrantConnection'], ParentType, ContextType, RequireFields<CollectionUserAccessGrantsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  userGroupAccessGrants?: Resolver<ResolversTypes['UserGroupCollectionAccessGrantConnection'], ParentType, ContextType, RequireFields<CollectionUserGroupAccessGrantsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  visibility?: Resolver<ResolversTypes['EntityVisibility'], ParentType, ContextType>;
  visible?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  visibleAfterAt?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
  visibleUntilAt?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionConnection'] = ResolversParentTypes['CollectionConnection']> = {
  edges?: Resolver<Array<ResolversTypes['CollectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['Collection']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionContributionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionContribution'] = ResolversParentTypes['CollectionContribution']> = {
  affiliation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collection?: Resolver<ResolversTypes['Collection'], ParentType, ContextType>;
  contributor?: Resolver<ResolversTypes['AnyContributor'], ParentType, ContextType>;
  contributorKind?: Resolver<ResolversTypes['ContributorKind'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  displayName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metadata?: Resolver<ResolversTypes['ContributionMetadata'], ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionContributionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionContributionConnection'] = ResolversParentTypes['CollectionContributionConnection']> = {
  edges?: Resolver<Array<ResolversTypes['CollectionContributionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['CollectionContribution']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionContributionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionContributionEdge'] = ResolversParentTypes['CollectionContributionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['CollectionContribution'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionEdge'] = ResolversParentTypes['CollectionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Collection'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionParentResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionParent'] = ResolversParentTypes['CollectionParent']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Community', ParentType, ContextType>;
};

export type CommunityResolvers<ContextType = any, ParentType extends ResolversParentTypes['Community'] = ResolversParentTypes['Community']> = {
  accessControlList?: Resolver<Maybe<ResolversTypes['AccessControlList']>, ParentType, ContextType>;
  accessGrants?: Resolver<ResolversTypes['AnyCommunityAccessGrantConnection'], ParentType, ContextType, RequireFields<CommunityAccessGrantsArgs, 'subject' | 'order' | 'pageDirection' | 'perPage'>>;
  allAccessGrants?: Resolver<ResolversTypes['AnyAccessGrantConnection'], ParentType, ContextType, RequireFields<CommunityAllAccessGrantsArgs, 'subject' | 'order' | 'pageDirection' | 'perPage'>>;
  allowedActions?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  applicableRoles?: Resolver<Maybe<Array<ResolversTypes['Role']>>, ParentType, ContextType>;
  assets?: Resolver<ResolversTypes['AnyAssetConnection'], ParentType, ContextType, RequireFields<CommunityAssetsArgs, 'order' | 'kind' | 'pageDirection' | 'perPage'>>;
  assignedUsers?: Resolver<ResolversTypes['ContextualPermissionConnection'], ParentType, ContextType, RequireFields<CommunityAssignedUsersArgs, 'order' | 'pageDirection' | 'perPage'>>;
  breadcrumbs?: Resolver<Array<ResolversTypes['EntityBreadcrumb']>, ParentType, ContextType>;
  collections?: Resolver<ResolversTypes['CollectionConnection'], ParentType, ContextType, RequireFields<CommunityCollectionsArgs, 'order' | 'nodeFilter' | 'pageDirection' | 'perPage'>>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  hierarchicalDepth?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  links?: Resolver<ResolversTypes['EntityLinkConnection'], ParentType, ContextType, RequireFields<CommunityLinksArgs, 'order' | 'pageDirection' | 'perPage'>>;
  metadata?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  ordering?: Resolver<Maybe<ResolversTypes['Ordering']>, ParentType, ContextType, RequireFields<CommunityOrderingArgs, 'identifier'>>;
  orderings?: Resolver<ResolversTypes['OrderingConnection'], ParentType, ContextType, RequireFields<CommunityOrderingsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  schemaDefinition?: Resolver<ResolversTypes['SchemaDefinition'], ParentType, ContextType>;
  schemaInstanceContext?: Resolver<ResolversTypes['SchemaInstanceContext'], ParentType, ContextType>;
  schemaProperties?: Resolver<Array<ResolversTypes['AnySchemaProperty']>, ParentType, ContextType>;
  schemaVersion?: Resolver<ResolversTypes['SchemaVersion'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  thumbnail?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  userAccessGrants?: Resolver<ResolversTypes['UserCommunityAccessGrantConnection'], ParentType, ContextType, RequireFields<CommunityUserAccessGrantsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  userGroupAccessGrants?: Resolver<ResolversTypes['UserGroupCommunityAccessGrantConnection'], ParentType, ContextType, RequireFields<CommunityUserGroupAccessGrantsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommunityConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CommunityConnection'] = ResolversParentTypes['CommunityConnection']> = {
  edges?: Resolver<Array<ResolversTypes['CommunityEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['Community']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommunityEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CommunityEdge'] = ResolversParentTypes['CommunityEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Community'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContextualPermissionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContextualPermission'] = ResolversParentTypes['ContextualPermission']> = {
  accessControlList?: Resolver<Maybe<ResolversTypes['AccessControlList']>, ParentType, ContextType>;
  accessGrants?: Resolver<Array<ResolversTypes['AnyUserAccessGrant']>, ParentType, ContextType>;
  allowedActions?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
  roles?: Resolver<Array<ResolversTypes['Role']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContextualPermissionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContextualPermissionConnection'] = ResolversParentTypes['ContextualPermissionConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ContextualPermissionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ContextualPermission']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContextualPermissionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContextualPermissionEdge'] = ResolversParentTypes['ContextualPermissionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ContextualPermission'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContributableResolvers<ContextType = any, ParentType extends ResolversParentTypes['Contributable'] = ResolversParentTypes['Contributable']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Item', ParentType, ContextType>;
  contributors?: Resolver<ResolversTypes['AnyContributorConnection'], ParentType, ContextType, RequireFields<ContributableContributorsArgs, 'order' | 'kind' | 'pageDirection' | 'perPage'>>;
};

export type ContributionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Contribution'] = ResolversParentTypes['Contribution']> = {
  __resolveType: TypeResolveFn<'CollectionContribution' | 'ItemContribution', ParentType, ContextType>;
  affiliation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contributor?: Resolver<ResolversTypes['AnyContributor'], ParentType, ContextType>;
  contributorKind?: Resolver<ResolversTypes['ContributorKind'], ParentType, ContextType>;
  displayName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metadata?: Resolver<ResolversTypes['ContributionMetadata'], ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
};

export type ContributionMetadataResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContributionMetadata'] = ResolversParentTypes['ContributionMetadata']> = {
  affiliation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  displayName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContributorResolvers<ContextType = any, ParentType extends ResolversParentTypes['Contributor'] = ResolversParentTypes['Contributor']> = {
  __resolveType: TypeResolveFn<'OrganizationContributor' | 'PersonContributor', ParentType, ContextType>;
  bio?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collectionContributions?: Resolver<ResolversTypes['CollectionContributionConnection'], ParentType, ContextType, RequireFields<ContributorCollectionContributionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  itemContributions?: Resolver<ResolversTypes['ItemContributionConnection'], ParentType, ContextType, RequireFields<ContributorItemContributionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  kind?: Resolver<ResolversTypes['ContributorKind'], ParentType, ContextType>;
  links?: Resolver<Array<ResolversTypes['ContributorLink']>, ParentType, ContextType>;
  prefix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  suffix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
};

export type ContributorLinkResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContributorLink'] = ResolversParentTypes['ContributorLink']> = {
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContributorPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContributorProperty'] = ResolversParentTypes['ContributorProperty']> = {
  contributor?: Resolver<Maybe<ResolversTypes['AnyContributor']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContributorSelectOptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContributorSelectOption'] = ResolversParentTypes['ContributorSelectOption']> = {
  kind?: Resolver<ResolversTypes['ContributorKind'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContributorsPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContributorsProperty'] = ResolversParentTypes['ContributorsProperty']> = {
  contributors?: Resolver<Array<ResolversTypes['AnyContributor']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateAssetPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateAssetPayload'] = ResolversParentTypes['CreateAssetPayload']> = {
  asset?: Resolver<Maybe<ResolversTypes['AnyAsset']>, ParentType, ContextType>;
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateCollectionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateCollectionPayload'] = ResolversParentTypes['CreateCollectionPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateCommunityPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateCommunityPayload'] = ResolversParentTypes['CreateCommunityPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  community?: Resolver<Maybe<ResolversTypes['Community']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateItemPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateItemPayload'] = ResolversParentTypes['CreateItemPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateOrderingPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateOrderingPayload'] = ResolversParentTypes['CreateOrderingPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ordering?: Resolver<Maybe<ResolversTypes['Ordering']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateOrganizationContributorPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateOrganizationContributorPayload'] = ResolversParentTypes['CreateOrganizationContributorPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contributor?: Resolver<Maybe<ResolversTypes['OrganizationContributor']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatePersonContributorPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreatePersonContributorPayload'] = ResolversParentTypes['CreatePersonContributorPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contributor?: Resolver<Maybe<ResolversTypes['PersonContributor']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateRolePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateRolePayload'] = ResolversParentTypes['CreateRolePayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DatePropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['DateProperty'] = ResolversParentTypes['DateProperty']> = {
  date?: Resolver<Maybe<ResolversTypes['ISO8601Date']>, ParentType, ContextType>;
  default?: Resolver<Maybe<ResolversTypes['ISO8601Date']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestroyCollectionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DestroyCollectionPayload'] = ResolversParentTypes['DestroyCollectionPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  destroyed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  destroyedId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestroyCommunityPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DestroyCommunityPayload'] = ResolversParentTypes['DestroyCommunityPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  destroyed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  destroyedId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestroyContributionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DestroyContributionPayload'] = ResolversParentTypes['DestroyContributionPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  destroyed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  destroyedId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestroyContributorPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DestroyContributorPayload'] = ResolversParentTypes['DestroyContributorPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  destroyed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  destroyedId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestroyEntityLinkPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DestroyEntityLinkPayload'] = ResolversParentTypes['DestroyEntityLinkPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  destroyed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  destroyedId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestroyItemPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DestroyItemPayload'] = ResolversParentTypes['DestroyItemPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  destroyed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  destroyedId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestroyMutationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DestroyMutationPayload'] = ResolversParentTypes['DestroyMutationPayload']> = {
  __resolveType: TypeResolveFn<'DestroyCollectionPayload' | 'DestroyCommunityPayload' | 'DestroyContributionPayload' | 'DestroyContributorPayload' | 'DestroyEntityLinkPayload' | 'DestroyItemPayload' | 'DestroyOrderingPayload', ParentType, ContextType>;
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  destroyed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  destroyedId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
};

export type DestroyOrderingPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DestroyOrderingPayload'] = ResolversParentTypes['DestroyOrderingPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  destroyed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  destroyedId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  disabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmailPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmailProperty'] = ResolversParentTypes['EmailProperty']> = {
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EntityResolvers<ContextType = any, ParentType extends ResolversParentTypes['Entity'] = ResolversParentTypes['Entity']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Community' | 'Item', ParentType, ContextType>;
  accessControlList?: Resolver<Maybe<ResolversTypes['AccessControlList']>, ParentType, ContextType>;
  allAccessGrants?: Resolver<ResolversTypes['AnyAccessGrantConnection'], ParentType, ContextType, RequireFields<EntityAllAccessGrantsArgs, 'subject' | 'order' | 'pageDirection' | 'perPage'>>;
  allowedActions?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  applicableRoles?: Resolver<Maybe<Array<ResolversTypes['Role']>>, ParentType, ContextType>;
  assignedUsers?: Resolver<ResolversTypes['ContextualPermissionConnection'], ParentType, ContextType, RequireFields<EntityAssignedUsersArgs, 'order' | 'pageDirection' | 'perPage'>>;
  breadcrumbs?: Resolver<Array<ResolversTypes['EntityBreadcrumb']>, ParentType, ContextType>;
  hierarchicalDepth?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  links?: Resolver<ResolversTypes['EntityLinkConnection'], ParentType, ContextType, RequireFields<EntityLinksArgs, 'order' | 'pageDirection' | 'perPage'>>;
  ordering?: Resolver<Maybe<ResolversTypes['Ordering']>, ParentType, ContextType, RequireFields<EntityOrderingArgs, 'identifier'>>;
  orderings?: Resolver<ResolversTypes['OrderingConnection'], ParentType, ContextType, RequireFields<EntityOrderingsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
  schemaDefinition?: Resolver<ResolversTypes['SchemaDefinition'], ParentType, ContextType>;
  schemaProperties?: Resolver<Array<ResolversTypes['AnySchemaProperty']>, ParentType, ContextType>;
  schemaVersion?: Resolver<ResolversTypes['SchemaVersion'], ParentType, ContextType>;
  thumbnail?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
};

export type EntityBreadcrumbResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntityBreadcrumb'] = ResolversParentTypes['EntityBreadcrumb']> = {
  crumb?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  depth?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['EntityKind'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EntityLinkResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntityLink'] = ResolversParentTypes['EntityLink']> = {
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes['EntityLinkOperator'], ParentType, ContextType>;
  scope?: Resolver<ResolversTypes['EntityLinkScope'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  sourceCollection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  sourceCommunity?: Resolver<Maybe<ResolversTypes['Community']>, ParentType, ContextType>;
  sourceItem?: Resolver<Maybe<ResolversTypes['Item']>, ParentType, ContextType>;
  target?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  targetCollection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  targetCommunity?: Resolver<Maybe<ResolversTypes['Community']>, ParentType, ContextType>;
  targetItem?: Resolver<Maybe<ResolversTypes['Item']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EntityLinkConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntityLinkConnection'] = ResolversParentTypes['EntityLinkConnection']> = {
  edges?: Resolver<Array<ResolversTypes['EntityLinkEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['EntityLink']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EntityLinkEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntityLinkEdge'] = ResolversParentTypes['EntityLinkEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['EntityLink'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExposesPermissionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExposesPermissions'] = ResolversParentTypes['ExposesPermissions']> = {
  __resolveType: TypeResolveFn<'ContextualPermission' | 'User', ParentType, ContextType>;
  allowedActions?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
};

export type FloatPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['FloatProperty'] = ResolversParentTypes['FloatProperty']> = {
  defaultFloat?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  floatValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GrantAccessPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['GrantAccessPayload'] = ResolversParentTypes['GrantAccessPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entity?: Resolver<Maybe<ResolversTypes['AnyEntity']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  granted?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupProperty'] = ResolversParentTypes['GroupProperty']> = {
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  legend?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  properties?: Resolver<Array<ResolversTypes['AnyScalarProperty']>, ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HasSchemaPropertiesResolvers<ContextType = any, ParentType extends ResolversParentTypes['HasSchemaProperties'] = ResolversParentTypes['HasSchemaProperties']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Community' | 'Item' | 'SchemaVersion', ParentType, ContextType>;
  schemaProperties?: Resolver<Array<ResolversTypes['AnySchemaProperty']>, ParentType, ContextType>;
};

export type HierarchicalEntryResolvers<ContextType = any, ParentType extends ResolversParentTypes['HierarchicalEntry'] = ResolversParentTypes['HierarchicalEntry']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Item', ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  doi?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hidden?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hiddenAt?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  leaf?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  publishedOn?: Resolver<Maybe<ResolversTypes['ISO8601Date']>, ParentType, ContextType>;
  root?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  summary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  visibility?: Resolver<ResolversTypes['EntityVisibility'], ParentType, ContextType>;
  visible?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  visibleAfterAt?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
  visibleUntilAt?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
};

export interface Iso8601DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ISO8601Date'], any> {
  name: 'ISO8601Date';
}

export interface Iso8601DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ISO8601DateTime'], any> {
  name: 'ISO8601DateTime';
}

export type IntegerPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['IntegerProperty'] = ResolversParentTypes['IntegerProperty']> = {
  defaultInteger?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  integerValue?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemResolvers<ContextType = any, ParentType extends ResolversParentTypes['Item'] = ResolversParentTypes['Item']> = {
  accessControlList?: Resolver<Maybe<ResolversTypes['AccessControlList']>, ParentType, ContextType>;
  accessGrants?: Resolver<ResolversTypes['AnyCollectionAccessGrantConnection'], ParentType, ContextType, RequireFields<ItemAccessGrantsArgs, 'subject' | 'order' | 'pageDirection' | 'perPage'>>;
  allAccessGrants?: Resolver<ResolversTypes['AnyAccessGrantConnection'], ParentType, ContextType, RequireFields<ItemAllAccessGrantsArgs, 'subject' | 'order' | 'pageDirection' | 'perPage'>>;
  allowedActions?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  applicableRoles?: Resolver<Maybe<Array<ResolversTypes['Role']>>, ParentType, ContextType>;
  assets?: Resolver<ResolversTypes['AnyAssetConnection'], ParentType, ContextType, RequireFields<ItemAssetsArgs, 'order' | 'kind' | 'pageDirection' | 'perPage'>>;
  assignedUsers?: Resolver<ResolversTypes['ContextualPermissionConnection'], ParentType, ContextType, RequireFields<ItemAssignedUsersArgs, 'order' | 'pageDirection' | 'perPage'>>;
  breadcrumbs?: Resolver<Array<ResolversTypes['EntityBreadcrumb']>, ParentType, ContextType>;
  children?: Resolver<ResolversTypes['ItemConnection'], ParentType, ContextType, RequireFields<ItemChildrenArgs, never>>;
  collection?: Resolver<ResolversTypes['Collection'], ParentType, ContextType>;
  community?: Resolver<ResolversTypes['Community'], ParentType, ContextType>;
  contributions?: Resolver<ResolversTypes['ItemContributionConnection'], ParentType, ContextType, RequireFields<ItemContributionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  contributors?: Resolver<ResolversTypes['AnyContributorConnection'], ParentType, ContextType, RequireFields<ItemContributorsArgs, 'order' | 'kind' | 'pageDirection' | 'perPage'>>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  doi?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hidden?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hiddenAt?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
  hierarchicalDepth?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  items?: Resolver<ResolversTypes['ItemConnection'], ParentType, ContextType, RequireFields<ItemItemsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  leaf?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  links?: Resolver<ResolversTypes['EntityLinkConnection'], ParentType, ContextType, RequireFields<ItemLinksArgs, 'order' | 'pageDirection' | 'perPage'>>;
  ordering?: Resolver<Maybe<ResolversTypes['Ordering']>, ParentType, ContextType, RequireFields<ItemOrderingArgs, 'identifier'>>;
  orderings?: Resolver<ResolversTypes['OrderingConnection'], ParentType, ContextType, RequireFields<ItemOrderingsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  parent?: Resolver<Maybe<ResolversTypes['ItemParent']>, ParentType, ContextType>;
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
  publishedOn?: Resolver<Maybe<ResolversTypes['ISO8601Date']>, ParentType, ContextType>;
  root?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  schemaDefinition?: Resolver<ResolversTypes['SchemaDefinition'], ParentType, ContextType>;
  schemaInstanceContext?: Resolver<ResolversTypes['SchemaInstanceContext'], ParentType, ContextType>;
  schemaProperties?: Resolver<Array<ResolversTypes['AnySchemaProperty']>, ParentType, ContextType>;
  schemaVersion?: Resolver<ResolversTypes['SchemaVersion'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  summary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  thumbnail?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  userAccessGrants?: Resolver<ResolversTypes['UserCollectionAccessGrantConnection'], ParentType, ContextType, RequireFields<ItemUserAccessGrantsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  userGroupAccessGrants?: Resolver<ResolversTypes['UserGroupCollectionAccessGrantConnection'], ParentType, ContextType, RequireFields<ItemUserGroupAccessGrantsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  visibility?: Resolver<ResolversTypes['EntityVisibility'], ParentType, ContextType>;
  visible?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  visibleAfterAt?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
  visibleUntilAt?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ItemConnection'] = ResolversParentTypes['ItemConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ItemEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['Item']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemContributionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ItemContribution'] = ResolversParentTypes['ItemContribution']> = {
  affiliation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contributor?: Resolver<ResolversTypes['AnyContributor'], ParentType, ContextType>;
  contributorKind?: Resolver<ResolversTypes['ContributorKind'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  displayName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['Item'], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metadata?: Resolver<ResolversTypes['ContributionMetadata'], ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemContributionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ItemContributionConnection'] = ResolversParentTypes['ItemContributionConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ItemContributionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ItemContribution']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemContributionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ItemContributionEdge'] = ResolversParentTypes['ItemContributionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ItemContribution'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ItemEdge'] = ResolversParentTypes['ItemEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Item'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemParentResolvers<ContextType = any, ParentType extends ResolversParentTypes['ItemParent'] = ResolversParentTypes['ItemParent']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Item', ParentType, ContextType>;
};

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
  name: 'JSON';
}

export type LinkEntityPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['LinkEntityPayload'] = ResolversParentTypes['LinkEntityPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  link?: Resolver<Maybe<ResolversTypes['EntityLink']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarkdownPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['MarkdownProperty'] = ResolversParentTypes['MarkdownProperty']> = {
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  default?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MultiselectPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['MultiselectProperty'] = ResolversParentTypes['MultiselectProperty']> = {
  defaultSelections?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  options?: Resolver<Array<ResolversTypes['SelectOption']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  selections?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {
  alterSchemaVersion?: Resolver<Maybe<ResolversTypes['AlterSchemaVersionPayload']>, ParentType, ContextType, RequireFields<MutationAlterSchemaVersionArgs, 'input'>>;
  applySchemaProperties?: Resolver<Maybe<ResolversTypes['ApplySchemaPropertiesPayload']>, ParentType, ContextType, RequireFields<MutationApplySchemaPropertiesArgs, 'input'>>;
  createAsset?: Resolver<Maybe<ResolversTypes['CreateAssetPayload']>, ParentType, ContextType, RequireFields<MutationCreateAssetArgs, 'input'>>;
  createCollection?: Resolver<Maybe<ResolversTypes['CreateCollectionPayload']>, ParentType, ContextType, RequireFields<MutationCreateCollectionArgs, 'input'>>;
  createCommunity?: Resolver<Maybe<ResolversTypes['CreateCommunityPayload']>, ParentType, ContextType, RequireFields<MutationCreateCommunityArgs, 'input'>>;
  createItem?: Resolver<Maybe<ResolversTypes['CreateItemPayload']>, ParentType, ContextType, RequireFields<MutationCreateItemArgs, 'input'>>;
  createOrdering?: Resolver<Maybe<ResolversTypes['CreateOrderingPayload']>, ParentType, ContextType, RequireFields<MutationCreateOrderingArgs, 'input'>>;
  createOrganizationContributor?: Resolver<Maybe<ResolversTypes['CreateOrganizationContributorPayload']>, ParentType, ContextType, RequireFields<MutationCreateOrganizationContributorArgs, 'input'>>;
  createPersonContributor?: Resolver<Maybe<ResolversTypes['CreatePersonContributorPayload']>, ParentType, ContextType, RequireFields<MutationCreatePersonContributorArgs, 'input'>>;
  createRole?: Resolver<Maybe<ResolversTypes['CreateRolePayload']>, ParentType, ContextType, RequireFields<MutationCreateRoleArgs, 'input'>>;
  destroyCollection?: Resolver<Maybe<ResolversTypes['DestroyCollectionPayload']>, ParentType, ContextType, RequireFields<MutationDestroyCollectionArgs, 'input'>>;
  destroyCommunity?: Resolver<Maybe<ResolversTypes['DestroyCommunityPayload']>, ParentType, ContextType, RequireFields<MutationDestroyCommunityArgs, 'input'>>;
  destroyContribution?: Resolver<Maybe<ResolversTypes['DestroyContributionPayload']>, ParentType, ContextType, RequireFields<MutationDestroyContributionArgs, 'input'>>;
  destroyContributor?: Resolver<Maybe<ResolversTypes['DestroyContributorPayload']>, ParentType, ContextType, RequireFields<MutationDestroyContributorArgs, 'input'>>;
  destroyEntityLink?: Resolver<Maybe<ResolversTypes['DestroyEntityLinkPayload']>, ParentType, ContextType, RequireFields<MutationDestroyEntityLinkArgs, 'input'>>;
  destroyItem?: Resolver<Maybe<ResolversTypes['DestroyItemPayload']>, ParentType, ContextType, RequireFields<MutationDestroyItemArgs, 'input'>>;
  destroyOrdering?: Resolver<Maybe<ResolversTypes['DestroyOrderingPayload']>, ParentType, ContextType, RequireFields<MutationDestroyOrderingArgs, 'input'>>;
  grantAccess?: Resolver<Maybe<ResolversTypes['GrantAccessPayload']>, ParentType, ContextType, RequireFields<MutationGrantAccessArgs, 'input'>>;
  linkEntity?: Resolver<Maybe<ResolversTypes['LinkEntityPayload']>, ParentType, ContextType, RequireFields<MutationLinkEntityArgs, 'input'>>;
  reparentCollection?: Resolver<Maybe<ResolversTypes['ReparentCollectionPayload']>, ParentType, ContextType, RequireFields<MutationReparentCollectionArgs, 'input'>>;
  reparentItem?: Resolver<Maybe<ResolversTypes['ReparentItemPayload']>, ParentType, ContextType, RequireFields<MutationReparentItemArgs, 'input'>>;
  resetOrdering?: Resolver<Maybe<ResolversTypes['ResetOrderingPayload']>, ParentType, ContextType, RequireFields<MutationResetOrderingArgs, 'input'>>;
  revokeAccess?: Resolver<Maybe<ResolversTypes['RevokeAccessPayload']>, ParentType, ContextType, RequireFields<MutationRevokeAccessArgs, 'input'>>;
  updateCollection?: Resolver<Maybe<ResolversTypes['UpdateCollectionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateCollectionArgs, 'input'>>;
  updateCommunity?: Resolver<Maybe<ResolversTypes['UpdateCommunityPayload']>, ParentType, ContextType, RequireFields<MutationUpdateCommunityArgs, 'input'>>;
  updateContribution?: Resolver<Maybe<ResolversTypes['UpdateContributionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateContributionArgs, 'input'>>;
  updateItem?: Resolver<Maybe<ResolversTypes['UpdateItemPayload']>, ParentType, ContextType, RequireFields<MutationUpdateItemArgs, 'input'>>;
  updateOrdering?: Resolver<Maybe<ResolversTypes['UpdateOrderingPayload']>, ParentType, ContextType, RequireFields<MutationUpdateOrderingArgs, 'input'>>;
  updateOrganizationContributor?: Resolver<Maybe<ResolversTypes['UpdateOrganizationContributorPayload']>, ParentType, ContextType, RequireFields<MutationUpdateOrganizationContributorArgs, 'input'>>;
  updatePersonContributor?: Resolver<Maybe<ResolversTypes['UpdatePersonContributorPayload']>, ParentType, ContextType, RequireFields<MutationUpdatePersonContributorArgs, 'input'>>;
  updateRole?: Resolver<Maybe<ResolversTypes['UpdateRolePayload']>, ParentType, ContextType, RequireFields<MutationUpdateRoleArgs, 'input'>>;
  upsertContribution?: Resolver<Maybe<ResolversTypes['UpsertContributionPayload']>, ParentType, ContextType, RequireFields<MutationUpsertContributionArgs, 'input'>>;
};

export type MutationAttributeErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['MutationAttributeError'] = ResolversParentTypes['MutationAttributeError']> = {
  messages?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutationGlobalErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['MutationGlobalError'] = ResolversParentTypes['MutationGlobalError']> = {
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {
  __resolveType: TypeResolveFn<'AssetAudio' | 'AssetDocument' | 'AssetImage' | 'AssetPDF' | 'AssetUnknown' | 'AssetVideo' | 'Collection' | 'CollectionContribution' | 'Community' | 'ContextualPermission' | 'EntityBreadcrumb' | 'EntityLink' | 'Item' | 'ItemContribution' | 'Ordering' | 'OrderingEntry' | 'OrganizationContributor' | 'PersonContributor' | 'Role' | 'SchemaDefinition' | 'SchemaVersion' | 'User' | 'UserCollectionAccessGrant' | 'UserCommunityAccessGrant' | 'UserGroup' | 'UserGroupCollectionAccessGrant' | 'UserGroupCommunityAccessGrant' | 'UserGroupItemAccessGrant' | 'UserItemAccessGrant', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
};

export type OptionablePropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['OptionableProperty'] = ResolversParentTypes['OptionableProperty']> = {
  __resolveType: TypeResolveFn<'MultiselectProperty' | 'SelectProperty', ParentType, ContextType>;
  options?: Resolver<Array<ResolversTypes['SelectOption']>, ParentType, ContextType>;
};

export type OrderingResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ordering'] = ResolversParentTypes['Ordering']> = {
  children?: Resolver<ResolversTypes['OrderingEntryConnection'], ParentType, ContextType, RequireFields<OrderingChildrenArgs, 'order' | 'pageDirection' | 'perPage'>>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  disabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  disabledAt?: Resolver<Maybe<ResolversTypes['ISO8601Date']>, ParentType, ContextType>;
  entity?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  footer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  header?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  inheritedFromSchema?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderingConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderingConnection'] = ResolversParentTypes['OrderingConnection']> = {
  edges?: Resolver<Array<ResolversTypes['OrderingEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['Ordering']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderingEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderingEdge'] = ResolversParentTypes['OrderingEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Ordering'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderingEntryResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderingEntry'] = ResolversParentTypes['OrderingEntry']> = {
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  entry?: Resolver<ResolversTypes['AnyOrderingEntry'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ordering?: Resolver<ResolversTypes['Ordering'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderingEntryConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderingEntryConnection'] = ResolversParentTypes['OrderingEntryConnection']> = {
  edges?: Resolver<Array<ResolversTypes['OrderingEntryEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['OrderingEntry']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderingEntryEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderingEntryEdge'] = ResolversParentTypes['OrderingEntryEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['OrderingEntry'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationContributorResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationContributor'] = ResolversParentTypes['OrganizationContributor']> = {
  bio?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collectionContributions?: Resolver<ResolversTypes['CollectionContributionConnection'], ParentType, ContextType, RequireFields<OrganizationContributorCollectionContributionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  itemContributions?: Resolver<ResolversTypes['ItemContributionConnection'], ParentType, ContextType, RequireFields<OrganizationContributorItemContributionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  kind?: Resolver<ResolversTypes['ContributorKind'], ParentType, ContextType>;
  legalName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  links?: Resolver<Array<ResolversTypes['ContributorLink']>, ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  prefix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  suffix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = {
  endCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  page?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  pageCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  perPage?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  startCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalUnfilteredCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaginatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['Paginated'] = ResolversParentTypes['Paginated']> = {
  __resolveType: TypeResolveFn<'AnyAccessGrantConnection' | 'AnyAssetConnection' | 'AnyCollectionAccessGrantConnection' | 'AnyCommunityAccessGrantConnection' | 'AnyContributorConnection' | 'AnyUserAccessGrantConnection' | 'AnyUserGroupAccessGrantConnection' | 'CollectionConnection' | 'CollectionContributionConnection' | 'CommunityConnection' | 'ContextualPermissionConnection' | 'EntityLinkConnection' | 'ItemConnection' | 'ItemContributionConnection' | 'OrderingConnection' | 'OrderingEntryConnection' | 'RoleConnection' | 'SchemaDefinitionConnection' | 'SchemaVersionConnection' | 'UserCollectionAccessGrantConnection' | 'UserCommunityAccessGrantConnection' | 'UserConnection' | 'UserGroupCollectionAccessGrantConnection' | 'UserGroupCommunityAccessGrantConnection' | 'UserGroupItemAccessGrantConnection' | 'UserItemAccessGrantConnection', ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
};

export type PermissionGrantResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionGrant'] = ResolversParentTypes['PermissionGrant']> = {
  allowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  scope?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PersonContributorResolvers<ContextType = any, ParentType extends ResolversParentTypes['PersonContributor'] = ResolversParentTypes['PersonContributor']> = {
  affiliation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  bio?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collectionContributions?: Resolver<ResolversTypes['CollectionContributionConnection'], ParentType, ContextType, RequireFields<PersonContributorCollectionContributionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  familyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  givenName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  itemContributions?: Resolver<ResolversTypes['ItemContributionConnection'], ParentType, ContextType, RequireFields<PersonContributorItemContributionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  kind?: Resolver<ResolversTypes['ContributorKind'], ParentType, ContextType>;
  links?: Resolver<Array<ResolversTypes['ContributorLink']>, ParentType, ContextType>;
  prefix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  suffix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PreviewImageResolvers<ContextType = any, ParentType extends ResolversParentTypes['PreviewImage'] = ResolversParentTypes['PreviewImage']> = {
  alt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  dimensions?: Resolver<Array<ResolversTypes['Int']>, ParentType, ContextType>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  width?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PreviewImageMapResolvers<ContextType = any, ParentType extends ResolversParentTypes['PreviewImageMap'] = ResolversParentTypes['PreviewImageMap']> = {
  alt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  dimensions?: Resolver<Array<ResolversTypes['Int']>, ParentType, ContextType>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  png?: Resolver<Maybe<ResolversTypes['PreviewImage']>, ParentType, ContextType>;
  webp?: Resolver<Maybe<ResolversTypes['PreviewImage']>, ParentType, ContextType>;
  width?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
  accessGrants?: Resolver<ResolversTypes['AnyAccessGrantConnection'], ParentType, ContextType, RequireFields<QueryAccessGrantsArgs, 'entity' | 'subject' | 'order' | 'pageDirection' | 'perPage'>>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType, RequireFields<QueryCollectionArgs, 'slug'>>;
  collectionContribution?: Resolver<Maybe<ResolversTypes['CollectionContribution']>, ParentType, ContextType, RequireFields<QueryCollectionContributionArgs, 'slug'>>;
  communities?: Resolver<ResolversTypes['CommunityConnection'], ParentType, ContextType, RequireFields<QueryCommunitiesArgs, 'order' | 'pageDirection' | 'perPage'>>;
  community?: Resolver<Maybe<ResolversTypes['Community']>, ParentType, ContextType, RequireFields<QueryCommunityArgs, 'slug'>>;
  contributor?: Resolver<Maybe<ResolversTypes['AnyContributor']>, ParentType, ContextType, RequireFields<QueryContributorArgs, 'slug'>>;
  contributors?: Resolver<ResolversTypes['AnyContributorConnection'], ParentType, ContextType, RequireFields<QueryContributorsArgs, 'order' | 'kind' | 'pageDirection' | 'perPage'>>;
  item?: Resolver<Maybe<ResolversTypes['Item']>, ParentType, ContextType, RequireFields<QueryItemArgs, 'slug'>>;
  itemContribution?: Resolver<Maybe<ResolversTypes['ItemContribution']>, ParentType, ContextType, RequireFields<QueryItemContributionArgs, 'slug'>>;
  node?: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType, RequireFields<QueryNodeArgs, 'id'>>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['Node']>>, ParentType, ContextType, RequireFields<QueryNodesArgs, 'ids'>>;
  roles?: Resolver<ResolversTypes['RoleConnection'], ParentType, ContextType, RequireFields<QueryRolesArgs, 'order'>>;
  schemaDefinition?: Resolver<Maybe<ResolversTypes['SchemaDefinition']>, ParentType, ContextType, RequireFields<QuerySchemaDefinitionArgs, 'slug'>>;
  schemaDefinitions?: Resolver<ResolversTypes['SchemaDefinitionConnection'], ParentType, ContextType, RequireFields<QuerySchemaDefinitionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  schemaVersion?: Resolver<Maybe<ResolversTypes['SchemaVersion']>, ParentType, ContextType, RequireFields<QuerySchemaVersionArgs, 'slug'>>;
  schemaVersionOptions?: Resolver<Array<ResolversTypes['SchemaVersionOption']>, ParentType, ContextType, RequireFields<QuerySchemaVersionOptionsArgs, 'kind'>>;
  schemaVersions?: Resolver<ResolversTypes['SchemaVersionConnection'], ParentType, ContextType, RequireFields<QuerySchemaVersionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<QueryUserArgs, 'slug'>>;
  users?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<QueryUsersArgs, 'order' | 'pageDirection' | 'perPage'>>;
  viewer?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
};

export type ReparentCollectionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReparentCollectionPayload'] = ResolversParentTypes['ReparentCollectionPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReparentItemPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReparentItemPayload'] = ResolversParentTypes['ReparentItemPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ResetOrderingPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResetOrderingPayload'] = ResolversParentTypes['ResetOrderingPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ordering?: Resolver<Maybe<ResolversTypes['Ordering']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RevokeAccessPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['RevokeAccessPayload'] = ResolversParentTypes['RevokeAccessPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entity?: Resolver<Maybe<ResolversTypes['AnyEntity']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  revoked?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleResolvers<ContextType = any, ParentType extends ResolversParentTypes['Role'] = ResolversParentTypes['Role']> = {
  accessControlList?: Resolver<ResolversTypes['AccessControlList'], ParentType, ContextType>;
  allowedActions?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleConnection'] = ResolversParentTypes['RoleConnection']> = {
  edges?: Resolver<Array<ResolversTypes['RoleEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['Role']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleEdge'] = ResolversParentTypes['RoleEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Role'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ScalarPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['ScalarProperty'] = ResolversParentTypes['ScalarProperty']> = {
  __resolveType: TypeResolveFn<'AssetProperty' | 'AssetsProperty' | 'BooleanProperty' | 'ContributorProperty' | 'ContributorsProperty' | 'DateProperty' | 'EmailProperty' | 'FloatProperty' | 'IntegerProperty' | 'MarkdownProperty' | 'MultiselectProperty' | 'SelectProperty' | 'StringProperty' | 'TagsProperty' | 'TimestampProperty' | 'UnknownProperty', ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type SchemaDefinitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaDefinition'] = ResolversParentTypes['SchemaDefinition']> = {
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['SchemaKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  namespace?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaDefinitionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaDefinitionConnection'] = ResolversParentTypes['SchemaDefinitionConnection']> = {
  edges?: Resolver<Array<ResolversTypes['SchemaDefinitionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['SchemaDefinition']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaDefinitionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaDefinitionEdge'] = ResolversParentTypes['SchemaDefinitionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['SchemaDefinition'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaInstanceResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaInstance'] = ResolversParentTypes['SchemaInstance']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Community' | 'Item', ParentType, ContextType>;
  schemaInstanceContext?: Resolver<ResolversTypes['SchemaInstanceContext'], ParentType, ContextType>;
  schemaProperties?: Resolver<Array<ResolversTypes['AnySchemaProperty']>, ParentType, ContextType>;
};

export type SchemaInstanceContextResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaInstanceContext'] = ResolversParentTypes['SchemaInstanceContext']> = {
  assets?: Resolver<Array<ResolversTypes['AssetSelectOption']>, ParentType, ContextType>;
  contributors?: Resolver<Array<ResolversTypes['ContributorSelectOption']>, ParentType, ContextType>;
  defaultValues?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  entityId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  fieldValues?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  schemaVersionSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  validity?: Resolver<Maybe<ResolversTypes['SchemaInstanceValidation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaInstanceValidationResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaInstanceValidation'] = ResolversParentTypes['SchemaInstanceValidation']> = {
  errors?: Resolver<Array<ResolversTypes['SchemaValueError']>, ParentType, ContextType>;
  valid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  validatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaProperty'] = ResolversParentTypes['SchemaProperty']> = {
  __resolveType: TypeResolveFn<'GroupProperty', ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type SchemaValueErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaValueError'] = ResolversParentTypes['SchemaValueError']> = {
  base?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hint?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metadata?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaVersionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaVersion'] = ResolversParentTypes['SchemaVersion']> = {
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['SchemaKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  namespace?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  schemaDefinition?: Resolver<ResolversTypes['SchemaDefinition'], ParentType, ContextType>;
  schemaProperties?: Resolver<Array<ResolversTypes['AnySchemaProperty']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaVersionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaVersionConnection'] = ResolversParentTypes['SchemaVersionConnection']> = {
  edges?: Resolver<Array<ResolversTypes['SchemaVersionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['SchemaVersion']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaVersionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaVersionEdge'] = ResolversParentTypes['SchemaVersionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['SchemaVersion'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaVersionOptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaVersionOption'] = ResolversParentTypes['SchemaVersionOption']> = {
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['SchemaKind'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  namespace?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  schemaDefinition?: Resolver<ResolversTypes['SchemaDefinition'], ParentType, ContextType>;
  schemaVersion?: Resolver<ResolversTypes['SchemaVersion'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SelectOptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SelectOption'] = ResolversParentTypes['SelectOption']> = {
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SelectPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['SelectProperty'] = ResolversParentTypes['SelectProperty']> = {
  defaultSelection?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  options?: Resolver<Array<ResolversTypes['SelectOption']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  selection?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface SlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Slug'], any> {
  name: 'Slug';
}

export type SluggableResolvers<ContextType = any, ParentType extends ResolversParentTypes['Sluggable'] = ResolversParentTypes['Sluggable']> = {
  __resolveType: TypeResolveFn<'AssetAudio' | 'AssetDocument' | 'AssetImage' | 'AssetPDF' | 'AssetUnknown' | 'AssetVideo' | 'Collection' | 'CollectionContribution' | 'Community' | 'ContextualPermission' | 'EntityLink' | 'Item' | 'ItemContribution' | 'Ordering' | 'OrderingEntry' | 'OrganizationContributor' | 'PersonContributor' | 'Role' | 'SchemaDefinition' | 'SchemaVersion' | 'User' | 'UserCollectionAccessGrant' | 'UserCommunityAccessGrant' | 'UserGroup' | 'UserGroupCollectionAccessGrant' | 'UserGroupCommunityAccessGrant' | 'UserGroupItemAccessGrant' | 'UserItemAccessGrant', ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
};

export type StandardMutationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandardMutationPayload'] = ResolversParentTypes['StandardMutationPayload']> = {
  __resolveType: TypeResolveFn<'AlterSchemaVersionPayload' | 'ApplySchemaPropertiesPayload' | 'CreateAssetPayload' | 'CreateCollectionPayload' | 'CreateCommunityPayload' | 'CreateItemPayload' | 'CreateOrderingPayload' | 'CreateOrganizationContributorPayload' | 'CreatePersonContributorPayload' | 'CreateRolePayload' | 'DestroyCollectionPayload' | 'DestroyCommunityPayload' | 'DestroyContributionPayload' | 'DestroyContributorPayload' | 'DestroyEntityLinkPayload' | 'DestroyItemPayload' | 'DestroyOrderingPayload' | 'GrantAccessPayload' | 'LinkEntityPayload' | 'ReparentCollectionPayload' | 'ReparentItemPayload' | 'ResetOrderingPayload' | 'RevokeAccessPayload' | 'UpdateCollectionPayload' | 'UpdateCommunityPayload' | 'UpdateContributionPayload' | 'UpdateItemPayload' | 'UpdateOrderingPayload' | 'UpdateOrganizationContributorPayload' | 'UpdatePersonContributorPayload' | 'UpdateRolePayload' | 'UpsertContributionPayload', ParentType, ContextType>;
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
};

export type StringPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['StringProperty'] = ResolversParentTypes['StringProperty']> = {
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  default?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagsPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['TagsProperty'] = ResolversParentTypes['TagsProperty']> = {
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  tags?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TimestampPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['TimestampProperty'] = ResolversParentTypes['TimestampProperty']> = {
  default?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnknownPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['UnknownProperty'] = ResolversParentTypes['UnknownProperty']> = {
  default?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  unknownValue?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateCollectionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateCollectionPayload'] = ResolversParentTypes['UpdateCollectionPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateCommunityPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateCommunityPayload'] = ResolversParentTypes['UpdateCommunityPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  community?: Resolver<Maybe<ResolversTypes['Community']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateContributionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateContributionPayload'] = ResolversParentTypes['UpdateContributionPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contribution?: Resolver<Maybe<ResolversTypes['AnyContribution']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateItemPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateItemPayload'] = ResolversParentTypes['UpdateItemPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateOrderingPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateOrderingPayload'] = ResolversParentTypes['UpdateOrderingPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ordering?: Resolver<Maybe<ResolversTypes['Ordering']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateOrganizationContributorPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateOrganizationContributorPayload'] = ResolversParentTypes['UpdateOrganizationContributorPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contributor?: Resolver<Maybe<ResolversTypes['OrganizationContributor']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePersonContributorPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdatePersonContributorPayload'] = ResolversParentTypes['UpdatePersonContributorPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contributor?: Resolver<Maybe<ResolversTypes['PersonContributor']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateRolePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateRolePayload'] = ResolversParentTypes['UpdateRolePayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface UploadIdScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['UploadID'], any> {
  name: 'UploadID';
}

export type UpsertContributionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertContributionPayload'] = ResolversParentTypes['UpsertContributionPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contribution?: Resolver<Maybe<ResolversTypes['AnyContribution']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {
  accessGrants?: Resolver<ResolversTypes['AnyUserAccessGrantConnection'], ParentType, ContextType, RequireFields<UserAccessGrantsArgs, 'entity' | 'order' | 'pageDirection' | 'perPage'>>;
  allAccessGrants?: Resolver<ResolversTypes['AnyAccessGrantConnection'], ParentType, ContextType, RequireFields<UserAllAccessGrantsArgs, 'entity' | 'order' | 'pageDirection' | 'perPage'>>;
  allowedActions?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  anonymous?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  collectionAccessGrants?: Resolver<ResolversTypes['UserCollectionAccessGrantConnection'], ParentType, ContextType, RequireFields<UserCollectionAccessGrantsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  collections?: Resolver<ResolversTypes['CollectionConnection'], ParentType, ContextType, RequireFields<UserCollectionsArgs, 'access' | 'order' | 'nodeFilter' | 'pageDirection' | 'perPage'>>;
  communities?: Resolver<ResolversTypes['CommunityConnection'], ParentType, ContextType, RequireFields<UserCommunitiesArgs, 'access' | 'order' | 'nodeFilter' | 'pageDirection' | 'perPage'>>;
  communityAccessGrants?: Resolver<ResolversTypes['UserCommunityAccessGrantConnection'], ParentType, ContextType, RequireFields<UserCommunityAccessGrantsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emailVerified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  globalAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  itemAccessGrants?: Resolver<ResolversTypes['UserItemAccessGrantConnection'], ParentType, ContextType, RequireFields<UserItemAccessGrantsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  items?: Resolver<ResolversTypes['ItemConnection'], ParentType, ContextType, RequireFields<UserItemsArgs, 'access' | 'order' | 'nodeFilter' | 'pageDirection' | 'perPage'>>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  uploadAccess?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  uploadToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserAccessGrantResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserAccessGrant'] = ResolversParentTypes['UserAccessGrant']> = {
  __resolveType: TypeResolveFn<'UserCollectionAccessGrant' | 'UserCommunityAccessGrant' | 'UserItemAccessGrant', ParentType, ContextType>;
  entity?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['Role'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['AccessGrantSubject'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
};

export type UserCollectionAccessGrantResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserCollectionAccessGrant'] = ResolversParentTypes['UserCollectionAccessGrant']> = {
  collection?: Resolver<ResolversTypes['Collection'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  entity?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['Role'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['AccessGrantSubject'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserCollectionAccessGrantConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserCollectionAccessGrantConnection'] = ResolversParentTypes['UserCollectionAccessGrantConnection']> = {
  edges?: Resolver<Array<ResolversTypes['UserCollectionAccessGrantEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['UserCollectionAccessGrant']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserCollectionAccessGrantEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserCollectionAccessGrantEdge'] = ResolversParentTypes['UserCollectionAccessGrantEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['UserCollectionAccessGrant'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserCommunityAccessGrantResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserCommunityAccessGrant'] = ResolversParentTypes['UserCommunityAccessGrant']> = {
  community?: Resolver<ResolversTypes['Community'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  entity?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['Role'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['AccessGrantSubject'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserCommunityAccessGrantConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserCommunityAccessGrantConnection'] = ResolversParentTypes['UserCommunityAccessGrantConnection']> = {
  edges?: Resolver<Array<ResolversTypes['UserCommunityAccessGrantEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['UserCommunityAccessGrant']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserCommunityAccessGrantEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserCommunityAccessGrantEdge'] = ResolversParentTypes['UserCommunityAccessGrantEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['UserCommunityAccessGrant'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserConnection'] = ResolversParentTypes['UserConnection']> = {
  edges?: Resolver<Array<ResolversTypes['UserEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['User']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserEdge'] = ResolversParentTypes['UserEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserError'] = ResolversParentTypes['UserError']> = {
  attributePath?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  scope?: Resolver<ResolversTypes['MutationErrorScope'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserGroupResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserGroup'] = ResolversParentTypes['UserGroup']> = {
  accessGrants?: Resolver<ResolversTypes['AnyUserGroupAccessGrantConnection'], ParentType, ContextType, RequireFields<UserGroupAccessGrantsArgs, 'entity' | 'order' | 'pageDirection' | 'perPage'>>;
  allAccessGrants?: Resolver<ResolversTypes['AnyAccessGrantConnection'], ParentType, ContextType, RequireFields<UserGroupAllAccessGrantsArgs, 'entity' | 'order' | 'pageDirection' | 'perPage'>>;
  collectionAccessGrants?: Resolver<ResolversTypes['UserGroupCollectionAccessGrantConnection'], ParentType, ContextType, RequireFields<UserGroupCollectionAccessGrantsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  communityAccessGrants?: Resolver<ResolversTypes['UserGroupCommunityAccessGrantConnection'], ParentType, ContextType, RequireFields<UserGroupCommunityAccessGrantsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  itemAccessGrants?: Resolver<ResolversTypes['UserGroupItemAccessGrantConnection'], ParentType, ContextType, RequireFields<UserGroupItemAccessGrantsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  users?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<UserGroupUsersArgs, 'order' | 'pageDirection' | 'perPage'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserGroupAccessGrantResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserGroupAccessGrant'] = ResolversParentTypes['UserGroupAccessGrant']> = {
  __resolveType: TypeResolveFn<'UserGroupCollectionAccessGrant' | 'UserGroupCommunityAccessGrant' | 'UserGroupItemAccessGrant', ParentType, ContextType>;
  entity?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['Role'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['AccessGrantSubject'], ParentType, ContextType>;
  userGroup?: Resolver<ResolversTypes['UserGroup'], ParentType, ContextType>;
};

export type UserGroupCollectionAccessGrantResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserGroupCollectionAccessGrant'] = ResolversParentTypes['UserGroupCollectionAccessGrant']> = {
  collection?: Resolver<ResolversTypes['Collection'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  entity?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['Role'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['AccessGrantSubject'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  userGroup?: Resolver<ResolversTypes['UserGroup'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserGroupCollectionAccessGrantConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserGroupCollectionAccessGrantConnection'] = ResolversParentTypes['UserGroupCollectionAccessGrantConnection']> = {
  edges?: Resolver<Array<ResolversTypes['UserGroupCollectionAccessGrantEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['UserGroupCollectionAccessGrant']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserGroupCollectionAccessGrantEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserGroupCollectionAccessGrantEdge'] = ResolversParentTypes['UserGroupCollectionAccessGrantEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['UserGroupCollectionAccessGrant'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserGroupCommunityAccessGrantResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserGroupCommunityAccessGrant'] = ResolversParentTypes['UserGroupCommunityAccessGrant']> = {
  community?: Resolver<ResolversTypes['Community'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  entity?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['Role'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['AccessGrantSubject'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  userGroup?: Resolver<ResolversTypes['UserGroup'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserGroupCommunityAccessGrantConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserGroupCommunityAccessGrantConnection'] = ResolversParentTypes['UserGroupCommunityAccessGrantConnection']> = {
  edges?: Resolver<Array<ResolversTypes['UserGroupCommunityAccessGrantEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['UserGroupCommunityAccessGrant']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserGroupCommunityAccessGrantEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserGroupCommunityAccessGrantEdge'] = ResolversParentTypes['UserGroupCommunityAccessGrantEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['UserGroupCommunityAccessGrant'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserGroupItemAccessGrantResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserGroupItemAccessGrant'] = ResolversParentTypes['UserGroupItemAccessGrant']> = {
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  entity?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['Item'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['Role'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['AccessGrantSubject'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  userGroup?: Resolver<ResolversTypes['UserGroup'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserGroupItemAccessGrantConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserGroupItemAccessGrantConnection'] = ResolversParentTypes['UserGroupItemAccessGrantConnection']> = {
  edges?: Resolver<Array<ResolversTypes['UserGroupItemAccessGrantEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['UserGroupItemAccessGrant']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserGroupItemAccessGrantEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserGroupItemAccessGrantEdge'] = ResolversParentTypes['UserGroupItemAccessGrantEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['UserGroupItemAccessGrant'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserItemAccessGrantResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserItemAccessGrant'] = ResolversParentTypes['UserItemAccessGrant']> = {
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  entity?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['Item'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['Role'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['AccessGrantSubject'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserItemAccessGrantConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserItemAccessGrantConnection'] = ResolversParentTypes['UserItemAccessGrantConnection']> = {
  edges?: Resolver<Array<ResolversTypes['UserItemAccessGrantEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['UserItemAccessGrant']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserItemAccessGrantEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserItemAccessGrantEdge'] = ResolversParentTypes['UserItemAccessGrantEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['UserItemAccessGrant'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
  AccessControlList?: AccessControlListResolvers<ContextType>;
  AccessGrant?: AccessGrantResolvers<ContextType>;
  AccessGrantSubject?: AccessGrantSubjectResolvers<ContextType>;
  Accessible?: AccessibleResolvers<ContextType>;
  AlterSchemaVersionPayload?: AlterSchemaVersionPayloadResolvers<ContextType>;
  AnyAccessGrant?: AnyAccessGrantResolvers<ContextType>;
  AnyAccessGrantConnection?: AnyAccessGrantConnectionResolvers<ContextType>;
  AnyAccessGrantEdge?: AnyAccessGrantEdgeResolvers<ContextType>;
  AnyAsset?: AnyAssetResolvers<ContextType>;
  AnyAssetConnection?: AnyAssetConnectionResolvers<ContextType>;
  AnyAssetEdge?: AnyAssetEdgeResolvers<ContextType>;
  AnyAttachable?: AnyAttachableResolvers<ContextType>;
  AnyCollectionAccessGrant?: AnyCollectionAccessGrantResolvers<ContextType>;
  AnyCollectionAccessGrantConnection?: AnyCollectionAccessGrantConnectionResolvers<ContextType>;
  AnyCollectionAccessGrantEdge?: AnyCollectionAccessGrantEdgeResolvers<ContextType>;
  AnyCommunityAccessGrant?: AnyCommunityAccessGrantResolvers<ContextType>;
  AnyCommunityAccessGrantConnection?: AnyCommunityAccessGrantConnectionResolvers<ContextType>;
  AnyCommunityAccessGrantEdge?: AnyCommunityAccessGrantEdgeResolvers<ContextType>;
  AnyContribution?: AnyContributionResolvers<ContextType>;
  AnyContributor?: AnyContributorResolvers<ContextType>;
  AnyContributorConnection?: AnyContributorConnectionResolvers<ContextType>;
  AnyContributorEdge?: AnyContributorEdgeResolvers<ContextType>;
  AnyEntity?: AnyEntityResolvers<ContextType>;
  AnyOrderingEntry?: AnyOrderingEntryResolvers<ContextType>;
  AnyScalarProperty?: AnyScalarPropertyResolvers<ContextType>;
  AnySchemaProperty?: AnySchemaPropertyResolvers<ContextType>;
  AnyUserAccessGrant?: AnyUserAccessGrantResolvers<ContextType>;
  AnyUserAccessGrantConnection?: AnyUserAccessGrantConnectionResolvers<ContextType>;
  AnyUserAccessGrantEdge?: AnyUserAccessGrantEdgeResolvers<ContextType>;
  AnyUserGroupAccessGrant?: AnyUserGroupAccessGrantResolvers<ContextType>;
  AnyUserGroupAccessGrantConnection?: AnyUserGroupAccessGrantConnectionResolvers<ContextType>;
  AnyUserGroupAccessGrantEdge?: AnyUserGroupAccessGrantEdgeResolvers<ContextType>;
  ApplySchemaPropertiesPayload?: ApplySchemaPropertiesPayloadResolvers<ContextType>;
  Asset?: AssetResolvers<ContextType>;
  AssetAudio?: AssetAudioResolvers<ContextType>;
  AssetDocument?: AssetDocumentResolvers<ContextType>;
  AssetImage?: AssetImageResolvers<ContextType>;
  AssetPDF?: AssetPdfResolvers<ContextType>;
  AssetPreview?: AssetPreviewResolvers<ContextType>;
  AssetProperty?: AssetPropertyResolvers<ContextType>;
  AssetSelectOption?: AssetSelectOptionResolvers<ContextType>;
  AssetUnknown?: AssetUnknownResolvers<ContextType>;
  AssetVideo?: AssetVideoResolvers<ContextType>;
  AssetsProperty?: AssetsPropertyResolvers<ContextType>;
  Attachable?: AttachableResolvers<ContextType>;
  BooleanProperty?: BooleanPropertyResolvers<ContextType>;
  Collection?: CollectionResolvers<ContextType>;
  CollectionConnection?: CollectionConnectionResolvers<ContextType>;
  CollectionContribution?: CollectionContributionResolvers<ContextType>;
  CollectionContributionConnection?: CollectionContributionConnectionResolvers<ContextType>;
  CollectionContributionEdge?: CollectionContributionEdgeResolvers<ContextType>;
  CollectionEdge?: CollectionEdgeResolvers<ContextType>;
  CollectionParent?: CollectionParentResolvers<ContextType>;
  Community?: CommunityResolvers<ContextType>;
  CommunityConnection?: CommunityConnectionResolvers<ContextType>;
  CommunityEdge?: CommunityEdgeResolvers<ContextType>;
  ContextualPermission?: ContextualPermissionResolvers<ContextType>;
  ContextualPermissionConnection?: ContextualPermissionConnectionResolvers<ContextType>;
  ContextualPermissionEdge?: ContextualPermissionEdgeResolvers<ContextType>;
  Contributable?: ContributableResolvers<ContextType>;
  Contribution?: ContributionResolvers<ContextType>;
  ContributionMetadata?: ContributionMetadataResolvers<ContextType>;
  Contributor?: ContributorResolvers<ContextType>;
  ContributorLink?: ContributorLinkResolvers<ContextType>;
  ContributorProperty?: ContributorPropertyResolvers<ContextType>;
  ContributorSelectOption?: ContributorSelectOptionResolvers<ContextType>;
  ContributorsProperty?: ContributorsPropertyResolvers<ContextType>;
  CreateAssetPayload?: CreateAssetPayloadResolvers<ContextType>;
  CreateCollectionPayload?: CreateCollectionPayloadResolvers<ContextType>;
  CreateCommunityPayload?: CreateCommunityPayloadResolvers<ContextType>;
  CreateItemPayload?: CreateItemPayloadResolvers<ContextType>;
  CreateOrderingPayload?: CreateOrderingPayloadResolvers<ContextType>;
  CreateOrganizationContributorPayload?: CreateOrganizationContributorPayloadResolvers<ContextType>;
  CreatePersonContributorPayload?: CreatePersonContributorPayloadResolvers<ContextType>;
  CreateRolePayload?: CreateRolePayloadResolvers<ContextType>;
  DateProperty?: DatePropertyResolvers<ContextType>;
  DestroyCollectionPayload?: DestroyCollectionPayloadResolvers<ContextType>;
  DestroyCommunityPayload?: DestroyCommunityPayloadResolvers<ContextType>;
  DestroyContributionPayload?: DestroyContributionPayloadResolvers<ContextType>;
  DestroyContributorPayload?: DestroyContributorPayloadResolvers<ContextType>;
  DestroyEntityLinkPayload?: DestroyEntityLinkPayloadResolvers<ContextType>;
  DestroyItemPayload?: DestroyItemPayloadResolvers<ContextType>;
  DestroyMutationPayload?: DestroyMutationPayloadResolvers<ContextType>;
  DestroyOrderingPayload?: DestroyOrderingPayloadResolvers<ContextType>;
  EmailProperty?: EmailPropertyResolvers<ContextType>;
  Entity?: EntityResolvers<ContextType>;
  EntityBreadcrumb?: EntityBreadcrumbResolvers<ContextType>;
  EntityLink?: EntityLinkResolvers<ContextType>;
  EntityLinkConnection?: EntityLinkConnectionResolvers<ContextType>;
  EntityLinkEdge?: EntityLinkEdgeResolvers<ContextType>;
  ExposesPermissions?: ExposesPermissionsResolvers<ContextType>;
  FloatProperty?: FloatPropertyResolvers<ContextType>;
  GrantAccessPayload?: GrantAccessPayloadResolvers<ContextType>;
  GroupProperty?: GroupPropertyResolvers<ContextType>;
  HasSchemaProperties?: HasSchemaPropertiesResolvers<ContextType>;
  HierarchicalEntry?: HierarchicalEntryResolvers<ContextType>;
  ISO8601Date?: GraphQLScalarType;
  ISO8601DateTime?: GraphQLScalarType;
  IntegerProperty?: IntegerPropertyResolvers<ContextType>;
  Item?: ItemResolvers<ContextType>;
  ItemConnection?: ItemConnectionResolvers<ContextType>;
  ItemContribution?: ItemContributionResolvers<ContextType>;
  ItemContributionConnection?: ItemContributionConnectionResolvers<ContextType>;
  ItemContributionEdge?: ItemContributionEdgeResolvers<ContextType>;
  ItemEdge?: ItemEdgeResolvers<ContextType>;
  ItemParent?: ItemParentResolvers<ContextType>;
  JSON?: GraphQLScalarType;
  LinkEntityPayload?: LinkEntityPayloadResolvers<ContextType>;
  MarkdownProperty?: MarkdownPropertyResolvers<ContextType>;
  MultiselectProperty?: MultiselectPropertyResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  MutationAttributeError?: MutationAttributeErrorResolvers<ContextType>;
  MutationGlobalError?: MutationGlobalErrorResolvers<ContextType>;
  Node?: NodeResolvers<ContextType>;
  OptionableProperty?: OptionablePropertyResolvers<ContextType>;
  Ordering?: OrderingResolvers<ContextType>;
  OrderingConnection?: OrderingConnectionResolvers<ContextType>;
  OrderingEdge?: OrderingEdgeResolvers<ContextType>;
  OrderingEntry?: OrderingEntryResolvers<ContextType>;
  OrderingEntryConnection?: OrderingEntryConnectionResolvers<ContextType>;
  OrderingEntryEdge?: OrderingEntryEdgeResolvers<ContextType>;
  OrganizationContributor?: OrganizationContributorResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  Paginated?: PaginatedResolvers<ContextType>;
  PermissionGrant?: PermissionGrantResolvers<ContextType>;
  PersonContributor?: PersonContributorResolvers<ContextType>;
  PreviewImage?: PreviewImageResolvers<ContextType>;
  PreviewImageMap?: PreviewImageMapResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  ReparentCollectionPayload?: ReparentCollectionPayloadResolvers<ContextType>;
  ReparentItemPayload?: ReparentItemPayloadResolvers<ContextType>;
  ResetOrderingPayload?: ResetOrderingPayloadResolvers<ContextType>;
  RevokeAccessPayload?: RevokeAccessPayloadResolvers<ContextType>;
  Role?: RoleResolvers<ContextType>;
  RoleConnection?: RoleConnectionResolvers<ContextType>;
  RoleEdge?: RoleEdgeResolvers<ContextType>;
  ScalarProperty?: ScalarPropertyResolvers<ContextType>;
  SchemaDefinition?: SchemaDefinitionResolvers<ContextType>;
  SchemaDefinitionConnection?: SchemaDefinitionConnectionResolvers<ContextType>;
  SchemaDefinitionEdge?: SchemaDefinitionEdgeResolvers<ContextType>;
  SchemaInstance?: SchemaInstanceResolvers<ContextType>;
  SchemaInstanceContext?: SchemaInstanceContextResolvers<ContextType>;
  SchemaInstanceValidation?: SchemaInstanceValidationResolvers<ContextType>;
  SchemaProperty?: SchemaPropertyResolvers<ContextType>;
  SchemaValueError?: SchemaValueErrorResolvers<ContextType>;
  SchemaVersion?: SchemaVersionResolvers<ContextType>;
  SchemaVersionConnection?: SchemaVersionConnectionResolvers<ContextType>;
  SchemaVersionEdge?: SchemaVersionEdgeResolvers<ContextType>;
  SchemaVersionOption?: SchemaVersionOptionResolvers<ContextType>;
  SelectOption?: SelectOptionResolvers<ContextType>;
  SelectProperty?: SelectPropertyResolvers<ContextType>;
  Slug?: GraphQLScalarType;
  Sluggable?: SluggableResolvers<ContextType>;
  StandardMutationPayload?: StandardMutationPayloadResolvers<ContextType>;
  StringProperty?: StringPropertyResolvers<ContextType>;
  TagsProperty?: TagsPropertyResolvers<ContextType>;
  TimestampProperty?: TimestampPropertyResolvers<ContextType>;
  UnknownProperty?: UnknownPropertyResolvers<ContextType>;
  UpdateCollectionPayload?: UpdateCollectionPayloadResolvers<ContextType>;
  UpdateCommunityPayload?: UpdateCommunityPayloadResolvers<ContextType>;
  UpdateContributionPayload?: UpdateContributionPayloadResolvers<ContextType>;
  UpdateItemPayload?: UpdateItemPayloadResolvers<ContextType>;
  UpdateOrderingPayload?: UpdateOrderingPayloadResolvers<ContextType>;
  UpdateOrganizationContributorPayload?: UpdateOrganizationContributorPayloadResolvers<ContextType>;
  UpdatePersonContributorPayload?: UpdatePersonContributorPayloadResolvers<ContextType>;
  UpdateRolePayload?: UpdateRolePayloadResolvers<ContextType>;
  UploadID?: GraphQLScalarType;
  UpsertContributionPayload?: UpsertContributionPayloadResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserAccessGrant?: UserAccessGrantResolvers<ContextType>;
  UserCollectionAccessGrant?: UserCollectionAccessGrantResolvers<ContextType>;
  UserCollectionAccessGrantConnection?: UserCollectionAccessGrantConnectionResolvers<ContextType>;
  UserCollectionAccessGrantEdge?: UserCollectionAccessGrantEdgeResolvers<ContextType>;
  UserCommunityAccessGrant?: UserCommunityAccessGrantResolvers<ContextType>;
  UserCommunityAccessGrantConnection?: UserCommunityAccessGrantConnectionResolvers<ContextType>;
  UserCommunityAccessGrantEdge?: UserCommunityAccessGrantEdgeResolvers<ContextType>;
  UserConnection?: UserConnectionResolvers<ContextType>;
  UserEdge?: UserEdgeResolvers<ContextType>;
  UserError?: UserErrorResolvers<ContextType>;
  UserGroup?: UserGroupResolvers<ContextType>;
  UserGroupAccessGrant?: UserGroupAccessGrantResolvers<ContextType>;
  UserGroupCollectionAccessGrant?: UserGroupCollectionAccessGrantResolvers<ContextType>;
  UserGroupCollectionAccessGrantConnection?: UserGroupCollectionAccessGrantConnectionResolvers<ContextType>;
  UserGroupCollectionAccessGrantEdge?: UserGroupCollectionAccessGrantEdgeResolvers<ContextType>;
  UserGroupCommunityAccessGrant?: UserGroupCommunityAccessGrantResolvers<ContextType>;
  UserGroupCommunityAccessGrantConnection?: UserGroupCommunityAccessGrantConnectionResolvers<ContextType>;
  UserGroupCommunityAccessGrantEdge?: UserGroupCommunityAccessGrantEdgeResolvers<ContextType>;
  UserGroupItemAccessGrant?: UserGroupItemAccessGrantResolvers<ContextType>;
  UserGroupItemAccessGrantConnection?: UserGroupItemAccessGrantConnectionResolvers<ContextType>;
  UserGroupItemAccessGrantEdge?: UserGroupItemAccessGrantEdgeResolvers<ContextType>;
  UserItemAccessGrant?: UserItemAccessGrantResolvers<ContextType>;
  UserItemAccessGrantConnection?: UserItemAccessGrantConnectionResolvers<ContextType>;
  UserItemAccessGrantEdge?: UserItemAccessGrantEdgeResolvers<ContextType>;
};


/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
 */
export type IResolvers<ContextType = any> = Resolvers<ContextType>;
