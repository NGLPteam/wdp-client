import type { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = { [X in Exclude<keyof T, K>]?: T[X] } & { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO 8601-encoded date */
  ISO8601Date: string;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: string;
  /** Represents untyped JSON */
  JSON: any;
  /** A slug that can identify a record in context */
  Slug: string;
  /** An upload ID is used to refer to an upload within the tus infrastructure outside of the GraphQL API */
  UploadID: string;
};

/** An access control list */
export type AccessControlList = {
  __typename?: 'AccessControlList';
  permissions: Array<PermissionGrant>;
};

/** Autogenerated input type of AlterSchemaVersion */
export type AlterSchemaVersionInput = {
  /** The entity that owns the attachment */
  entityId: Scalars['ID'];
  /** The slug for the new schema to apply */
  schemaVersionSlug: Scalars['String'];
  /**
   * An arbitrary set of property values. Owing to the dynamic nature, they do not have a specific GraphQL input type
   * associated with them. Validation will be performed within the application and returned as errors if not valid.
   */
  propertyValues: Scalars['JSON'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of AlterSchemaVersion */
export type AlterSchemaVersionPayload = StandardMutationPayload & {
  __typename?: 'AlterSchemaVersionPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  collection?: Maybe<Collection>;
  community?: Maybe<Community>;
  entity?: Maybe<AnyEntity>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  item?: Maybe<Item>;
  schemaErrors: Array<SchemaValueError>;
};

export type AnyAsset = AssetAudio | AssetDocument | AssetImage | AssetPdf | AssetUnknown | AssetVideo | { __typename?: "%other" };

/** The connection type for AnyAsset. */
export type AnyAssetConnection = Paginated & {
  __typename?: 'AnyAssetConnection';
  /** A list of edges. */
  edges: Array<AnyAssetEdge>;
  /** A list of nodes. */
  nodes: Array<AnyAsset>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AnyAssetEdge = {
  __typename?: 'AnyAssetEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: AnyAsset;
};

/** Something that can be attached to */
export type AnyAttachable = Collection | Community | Item | { __typename?: "%other" };

/** A union of possible contribution types */
export type AnyContribution = CollectionContribution | ItemContribution | { __typename?: "%other" };

export type AnyContributor = OrganizationContributor | PersonContributor | { __typename?: "%other" };

/** The connection type for AnyContributor. */
export type AnyContributorConnection = Paginated & {
  __typename?: 'AnyContributorConnection';
  /** A list of edges. */
  edges: Array<AnyContributorEdge>;
  /** A list of nodes. */
  nodes: Array<AnyContributor>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AnyContributorEdge = {
  __typename?: 'AnyContributorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: AnyContributor;
};

/** A hierarchical entity type */
export type AnyEntity = Collection | Community | Item | { __typename?: "%other" };

/** The various types an OrderingEntry can refer to */
export type AnyOrderingEntry = Collection | Community | EntityLink | Item | { __typename?: "%other" };

export type AnyScalarProperty = AssetProperty | AssetsProperty | BooleanProperty | ContributorProperty | ContributorsProperty | DateProperty | EmailProperty | FloatProperty | IntegerProperty | MarkdownProperty | MultiselectProperty | SelectProperty | StringProperty | TagsProperty | TimestampProperty | UnknownProperty | { __typename?: "%other" };

export type AnySchemaProperty = AssetProperty | AssetsProperty | BooleanProperty | ContributorProperty | ContributorsProperty | DateProperty | EmailProperty | FloatProperty | GroupProperty | IntegerProperty | MarkdownProperty | MultiselectProperty | SelectProperty | StringProperty | TagsProperty | TimestampProperty | UnknownProperty | { __typename?: "%other" };

/** Autogenerated input type of ApplySchemaProperties */
export type ApplySchemaPropertiesInput = {
  /** The entity that owns the attachment */
  entityId: Scalars['ID'];
  /**
   * An arbitrary set of property values. Owing to the dynamic nature, they do not have a specific GraphQL input type
   * associated with them. Validation will be performed within the application and returned as errors if not valid.
   */
  propertyValues: Scalars['JSON'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of ApplySchemaProperties */
export type ApplySchemaPropertiesPayload = StandardMutationPayload & {
  __typename?: 'ApplySchemaPropertiesPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  collection?: Maybe<Collection>;
  community?: Maybe<Community>;
  entity?: Maybe<AnyEntity>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  item?: Maybe<Item>;
  schemaErrors: Array<SchemaValueError>;
};

/** A generic asset type, implemented by all the more specific kinds */
export type Asset = {
  attachable: AnyAttachable;
  caption?: Maybe<Scalars['String']>;
  contentType: Scalars['String'];
  downloadUrl?: Maybe<Scalars['String']>;
  fileSize: Scalars['Int'];
  /** ID of the object. */
  id: Scalars['ID'];
  kind: AssetKind;
  name: Scalars['String'];
  preview?: Maybe<AssetPreview>;
  slug: Scalars['Slug'];
};

export type AssetAudio = Asset & Node & Sluggable & {
  __typename?: 'AssetAudio';
  attachable: AnyAttachable;
  caption?: Maybe<Scalars['String']>;
  contentType: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  downloadUrl?: Maybe<Scalars['String']>;
  fileSize: Scalars['Int'];
  /** ID of the object. */
  id: Scalars['ID'];
  kind: AssetKind;
  name: Scalars['String'];
  preview?: Maybe<AssetPreview>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type AssetDocument = Asset & Node & Sluggable & {
  __typename?: 'AssetDocument';
  attachable: AnyAttachable;
  caption?: Maybe<Scalars['String']>;
  contentType: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  downloadUrl?: Maybe<Scalars['String']>;
  fileSize: Scalars['Int'];
  /** ID of the object. */
  id: Scalars['ID'];
  kind: AssetKind;
  name: Scalars['String'];
  preview?: Maybe<AssetPreview>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type AssetImage = Asset & Node & Sluggable & {
  __typename?: 'AssetImage';
  attachable: AnyAttachable;
  caption?: Maybe<Scalars['String']>;
  contentType: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  downloadUrl?: Maybe<Scalars['String']>;
  fileSize: Scalars['Int'];
  /** ID of the object. */
  id: Scalars['ID'];
  kind: AssetKind;
  name: Scalars['String'];
  preview?: Maybe<AssetPreview>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The supported kinds of assets in the system */
export type AssetKind =
  | 'image'
  | 'video'
  | 'audio'
  | 'pdf'
  | 'document'
  | 'unknown'
  | '%future added value';

/** The type(s) of assets to retrieve */
export type AssetKindFilter =
  | 'ALL'
  /** An image, video, or audio file */
  | 'MEDIA'
  | 'AUDIO'
  | 'IMAGE'
  | 'VIDEO'
  | 'PDF'
  | 'DOCUMENT'
  | 'UNKNOWN'
  | '%future added value';

export type AssetPdf = Asset & Node & Sluggable & {
  __typename?: 'AssetPDF';
  attachable: AnyAttachable;
  caption?: Maybe<Scalars['String']>;
  contentType: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  downloadUrl?: Maybe<Scalars['String']>;
  fileSize: Scalars['Int'];
  /** ID of the object. */
  id: Scalars['ID'];
  kind: AssetKind;
  name: Scalars['String'];
  preview?: Maybe<AssetPreview>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type AssetPreview = {
  __typename?: 'AssetPreview';
  alt: Scalars['String'];
  large: PreviewImageMap;
  medium: PreviewImageMap;
  small: PreviewImageMap;
  thumb: PreviewImageMap;
};

export type AssetProperty = ScalarProperty & {
  __typename?: 'AssetProperty';
  asset?: Maybe<AnyAsset>;
  fullPath: Scalars['String'];
  label?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  type: Scalars['String'];
};

export type AssetUnknown = Asset & Node & Sluggable & {
  __typename?: 'AssetUnknown';
  attachable: AnyAttachable;
  caption?: Maybe<Scalars['String']>;
  contentType: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  downloadUrl?: Maybe<Scalars['String']>;
  fileSize: Scalars['Int'];
  /** ID of the object. */
  id: Scalars['ID'];
  kind: AssetKind;
  name: Scalars['String'];
  preview?: Maybe<AssetPreview>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type AssetVideo = Asset & Node & Sluggable & {
  __typename?: 'AssetVideo';
  attachable: AnyAttachable;
  caption?: Maybe<Scalars['String']>;
  contentType: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  downloadUrl?: Maybe<Scalars['String']>;
  fileSize: Scalars['Int'];
  /** ID of the object. */
  id: Scalars['ID'];
  kind: AssetKind;
  name: Scalars['String'];
  preview?: Maybe<AssetPreview>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

export type AssetsProperty = ScalarProperty & {
  __typename?: 'AssetsProperty';
  assets: Array<AnyAsset>;
  fullPath: Scalars['String'];
  label?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  type: Scalars['String'];
};

/** A model that has attached assets */
export type Attachable = {
  /** Assets owned by this entity */
  assets: AnyAssetConnection;
};


/** A model that has attached assets */
export type AttachableAssetsArgs = {
  order?: Maybe<SimpleOrder>;
  kind?: Maybe<AssetKindFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

export type BooleanProperty = ScalarProperty & {
  __typename?: 'BooleanProperty';
  checked?: Maybe<Scalars['Boolean']>;
  checkedByDefault?: Maybe<Scalars['Boolean']>;
  fullPath: Scalars['String'];
  label?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  type: Scalars['String'];
};

/** A collection of items */
export type Collection = Entity & HierarchicalEntry & Contributable & HasSchemaProperties & Attachable & Node & Sluggable & {
  __typename?: 'Collection';
  /** Derived access control list */
  accessControlList?: Maybe<AccessControlList>;
  /** A list of allowed actions for the given user on this entity (and its descendants). */
  allowedActions: Array<Scalars['String']>;
  /** The role(s) that gave the permissions to access this resource, if any. */
  applicableRoles?: Maybe<Array<Role>>;
  /** Assets owned by this entity */
  assets: AnyAssetConnection;
  /** Previous entries in the hierarchy */
  breadcrumbs: Array<EntityBreadcrumb>;
  /** @deprecated Use Collection.collections */
  children: CollectionConnection;
  collections: CollectionConnection;
  community: Community;
  contributions: CollectionContributionConnection;
  /** Contributors to this element */
  contributors: AnyContributorConnection;
  createdAt: Scalars['ISO8601DateTime'];
  doi?: Maybe<Scalars['String']>;
  /** The depth of the hierarchical entity, taking into account any parent types */
  hierarchicalDepth: Scalars['Int'];
  id: Scalars['ID'];
  identifier: Scalars['String'];
  items: ItemConnection;
  leaf: Scalars['Boolean'];
  links: EntityLinkConnection;
  /** Look up an ordering for this entity by identifier */
  ordering?: Maybe<Ordering>;
  orderings: OrderingConnection;
  parent?: Maybe<CollectionParent>;
  /** An array of hashes that can be requested to load in a context */
  permissions: Array<PermissionGrant>;
  publishedOn?: Maybe<Scalars['ISO8601Date']>;
  root: Scalars['Boolean'];
  schemaDefinition: SchemaDefinition;
  /** A list of schema properties associated with this instance or version. */
  schemaProperties: Array<AnySchemaProperty>;
  schemaVersion: SchemaVersion;
  slug: Scalars['Slug'];
  summary?: Maybe<Scalars['String']>;
  /** A mapping of an entity's preview thumbnail */
  thumbnail?: Maybe<AssetPreview>;
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
  visibleAfterAt?: Maybe<Scalars['ISO8601DateTime']>;
};


/** A collection of items */
export type CollectionAssetsArgs = {
  order?: Maybe<SimpleOrder>;
  kind?: Maybe<AssetKindFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionChildrenArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A collection of items */
export type CollectionCollectionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionContributionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionContributorsArgs = {
  order?: Maybe<SimpleOrder>;
  kind?: Maybe<ContributorFilterKind>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionItemsArgs = {
  order?: Maybe<SimpleOrder>;
  schema?: Maybe<Array<Scalars['String']>>;
  nodeFilter?: Maybe<TreeNodeFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionLinksArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A collection of items */
export type CollectionOrderingArgs = {
  identifier: Scalars['String'];
};


/** A collection of items */
export type CollectionOrderingsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** The connection type for Collection. */
export type CollectionConnection = Paginated & {
  __typename?: 'CollectionConnection';
  /** A list of edges. */
  edges: Array<CollectionEdge>;
  /** A list of nodes. */
  nodes: Array<Collection>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** A contribution to a collection */
export type CollectionContribution = Contribution & Node & Sluggable & {
  __typename?: 'CollectionContribution';
  /** A potentially-overridden value from person contributors */
  affiliation?: Maybe<Scalars['String']>;
  collection: Collection;
  contributor: AnyContributor;
  contributorKind: ContributorKind;
  createdAt: Scalars['ISO8601DateTime'];
  /** A potentially-overridden display name value for all contributor types */
  displayName: Scalars['String'];
  id: Scalars['ID'];
  /** A potentially-overridden value from organization contributors */
  location?: Maybe<Scalars['String']>;
  metadata: ContributionMetadata;
  /** An arbitrary text value describing the role the contributor had */
  role?: Maybe<Scalars['String']>;
  slug: Scalars['Slug'];
  /** A potentially-overridden value from person contributors */
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for CollectionContribution. */
export type CollectionContributionConnection = Paginated & {
  __typename?: 'CollectionContributionConnection';
  /** A list of edges. */
  edges: Array<CollectionContributionEdge>;
  /** A list of nodes. */
  nodes: Array<CollectionContribution>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CollectionContributionEdge = {
  __typename?: 'CollectionContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: CollectionContribution;
};

/** An edge in a connection. */
export type CollectionEdge = {
  __typename?: 'CollectionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Collection;
};

export type CollectionParent = Collection | Community | { __typename?: "%other" };

/** A community of users */
export type Community = Entity & HasSchemaProperties & Attachable & Node & Sluggable & {
  __typename?: 'Community';
  /** Derived access control list */
  accessControlList?: Maybe<AccessControlList>;
  /** A list of allowed actions for the given user on this entity (and its descendants). */
  allowedActions: Array<Scalars['String']>;
  /** The role(s) that gave the permissions to access this resource, if any. */
  applicableRoles?: Maybe<Array<Role>>;
  /** Assets owned by this entity */
  assets: AnyAssetConnection;
  /** Previous entries in the hierarchy */
  breadcrumbs: Array<EntityBreadcrumb>;
  collections: CollectionConnection;
  createdAt: Scalars['ISO8601DateTime'];
  /** The depth of the hierarchical entity, taking into account any parent types */
  hierarchicalDepth: Scalars['Int'];
  id: Scalars['ID'];
  links: EntityLinkConnection;
  metadata?: Maybe<Scalars['JSON']>;
  /** @deprecated Use Community.title */
  name: Scalars['String'];
  /** Look up an ordering for this entity by identifier */
  ordering?: Maybe<Ordering>;
  orderings: OrderingConnection;
  /** An array of hashes that can be requested to load in a context */
  permissions: Array<PermissionGrant>;
  position?: Maybe<Scalars['Int']>;
  schemaDefinition: SchemaDefinition;
  /** A list of schema properties associated with this instance or version. */
  schemaProperties: Array<AnySchemaProperty>;
  schemaVersion: SchemaVersion;
  slug: Scalars['Slug'];
  /** A mapping of an entity's preview thumbnail */
  thumbnail?: Maybe<AssetPreview>;
  title: Scalars['String'];
  updatedAt: Scalars['ISO8601DateTime'];
};


/** A community of users */
export type CommunityAssetsArgs = {
  order?: Maybe<SimpleOrder>;
  kind?: Maybe<AssetKindFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A community of users */
export type CommunityCollectionsArgs = {
  order?: Maybe<SimpleOrder>;
  schema?: Maybe<Array<Scalars['String']>>;
  nodeFilter?: Maybe<TreeNodeFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A community of users */
export type CommunityLinksArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A community of users */
export type CommunityOrderingArgs = {
  identifier: Scalars['String'];
};


/** A community of users */
export type CommunityOrderingsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** The connection type for Community. */
export type CommunityConnection = Paginated & {
  __typename?: 'CommunityConnection';
  /** A list of edges. */
  edges: Array<CommunityEdge>;
  /** A list of nodes. */
  nodes: Array<Community>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CommunityEdge = {
  __typename?: 'CommunityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Community;
};

/** Something that can be contributed to */
export type Contributable = {
  /** Contributors to this element */
  contributors: AnyContributorConnection;
};


/** Something that can be contributed to */
export type ContributableContributorsArgs = {
  order?: Maybe<SimpleOrder>;
  kind?: Maybe<ContributorFilterKind>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** A contribution from a certain contributor */
export type Contribution = {
  /** A potentially-overridden value from person contributors */
  affiliation?: Maybe<Scalars['String']>;
  contributor: AnyContributor;
  contributorKind: ContributorKind;
  /** A potentially-overridden display name value for all contributor types */
  displayName: Scalars['String'];
  /** A potentially-overridden value from organization contributors */
  location?: Maybe<Scalars['String']>;
  metadata: ContributionMetadata;
  /** An arbitrary text value describing the role the contributor had */
  role?: Maybe<Scalars['String']>;
  /** A potentially-overridden value from person contributors */
  title?: Maybe<Scalars['String']>;
};

/** Metadata for a contribution */
export type ContributionMetadata = {
  __typename?: 'ContributionMetadata';
  /** A value that can override a contribution's contributor's affiliation */
  affiliation?: Maybe<Scalars['String']>;
  /** A value that can oerride a contribution's contributor's displayed name */
  displayName?: Maybe<Scalars['String']>;
  /** An arbitrary field describing how the contributor contributed */
  role?: Maybe<Scalars['String']>;
  /** A value that can override a contribution's contributor's title */
  title?: Maybe<Scalars['String']>;
};

/** An input type that builds contribution metadata */
export type ContributionMetadataInput = {
  /** A value that can override a contribution's contributor's title */
  title?: Maybe<Scalars['String']>;
  /** A value that can override a contribution's contributor's affiliation */
  affiliation?: Maybe<Scalars['String']>;
  /** A value that can override a contribution's contributor's displayed name */
  displayName?: Maybe<Scalars['String']>;
  /** A value that can override a contribution's contributor's location */
  location?: Maybe<Scalars['String']>;
};

/** A contributor who has made a contribution */
export type Contributor = {
  bio?: Maybe<Scalars['String']>;
  collectionContributions: CollectionContributionConnection;
  email?: Maybe<Scalars['String']>;
  identifier: Scalars['String'];
  /** An optional image associated with the contributor */
  image?: Maybe<AssetPreview>;
  itemContributions: ItemContributionConnection;
  kind: ContributorKind;
  links: Array<Maybe<ContributorLink>>;
  prefix?: Maybe<Scalars['String']>;
  suffix?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
};


/** A contributor who has made a contribution */
export type ContributorCollectionContributionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A contributor who has made a contribution */
export type ContributorItemContributionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

export type ContributorFilterKind =
  | 'ALL'
  | 'ORGANIZATION'
  | 'PERSON'
  | '%future added value';

export type ContributorKind =
  | 'organization'
  | 'person'
  | '%future added value';

/** A link for a contributor */
export type ContributorLink = {
  __typename?: 'ContributorLink';
  title: Scalars['String'];
  url: Scalars['String'];
};

/** A mapping to build a contributor link */
export type ContributorLinkInput = {
  title: Scalars['String'];
  url: Scalars['String'];
};

export type ContributorProperty = ScalarProperty & {
  __typename?: 'ContributorProperty';
  contributor?: Maybe<AnyContributor>;
  fullPath: Scalars['String'];
  label?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  type: Scalars['String'];
};

export type ContributorsProperty = ScalarProperty & {
  __typename?: 'ContributorsProperty';
  contributors: Array<AnyContributor>;
  fullPath: Scalars['String'];
  label?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  type: Scalars['String'];
};

/** Autogenerated input type of CreateAsset */
export type CreateAssetInput = {
  /** The entity that owns the attachment */
  entityId: Scalars['ID'];
  /** A reference to an upload in Tus. */
  attachment: UploadedFileInput;
  /** A human readable name for the asset */
  name: Scalars['String'];
  /** The position the asset occupies amongst siblings */
  position?: Maybe<Scalars['Int']>;
  /** Alt text to display for the asset (if applicable) */
  altText?: Maybe<Scalars['String']>;
  /** A caption to display below the asset (if applicable) */
  caption?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateAsset */
export type CreateAssetPayload = StandardMutationPayload & {
  __typename?: 'CreateAssetPayload';
  asset?: Maybe<AnyAsset>;
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateCollection */
export type CreateCollectionInput = {
  /** The parent of the new collection. This can be the encoded ID of a community or another collection. */
  parentId: Scalars['ID'];
  title: Scalars['String'];
  identifier: Scalars['String'];
  schemaVersionSlug?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateCollection */
export type CreateCollectionPayload = StandardMutationPayload & {
  __typename?: 'CreateCollectionPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  collection?: Maybe<Collection>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateCommunity */
export type CreateCommunityInput = {
  /** A human readable title for the community */
  title: Scalars['String'];
  /** The position the community occupies in the list */
  position?: Maybe<Scalars['Int']>;
  schemaVersionSlug?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateCommunity */
export type CreateCommunityPayload = StandardMutationPayload & {
  __typename?: 'CreateCommunityPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A representation of a successfully created community */
  community?: Maybe<Community>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateItem */
export type CreateItemInput = {
  /** The parent of the item. This can be the encoded ID of a collection or another item. */
  parentId: Scalars['ID'];
  title: Scalars['String'];
  identifier: Scalars['String'];
  schemaVersionSlug?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateItem */
export type CreateItemPayload = StandardMutationPayload & {
  __typename?: 'CreateItemPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  /** A representation of a successfully created item */
  item?: Maybe<Item>;
};

/** Autogenerated input type of CreateOrdering */
export type CreateOrderingInput = {
  /** The entity to create the ordering for. */
  entityId: Scalars['ID'];
  /** A unique (within the context of the entity) identifier. Cannot be changed */
  identifier: Scalars['String'];
  /** A human readable label for the ordering */
  name?: Maybe<Scalars['String']>;
  /** Optional markdown content to display before the ordering's children */
  header?: Maybe<Scalars['String']>;
  /** Optional markdown content to display after the ordering's children */
  footer?: Maybe<Scalars['String']>;
  filter?: Maybe<OrderingFilterDefinitionInput>;
  select?: Maybe<OrderingSelectDefinitionInput>;
  order: Array<OrderDefinitionInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateOrdering */
export type CreateOrderingPayload = StandardMutationPayload & {
  __typename?: 'CreateOrderingPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  /** The created ordering */
  ordering?: Maybe<Ordering>;
};

/** Autogenerated input type of CreateOrganizationContributor */
export type CreateOrganizationContributorInput = {
  /** An email associated with the contributor */
  email?: Maybe<Scalars['String']>;
  /** A url associated with the contributor */
  url?: Maybe<Scalars['String']>;
  /** A summary of the contributor */
  bio?: Maybe<Scalars['String']>;
  links?: Maybe<Array<ContributorLinkInput>>;
  /** A reference to an upload in Tus. */
  image?: Maybe<UploadedFileInput>;
  /** The legal name of the organization */
  legalName?: Maybe<Scalars['String']>;
  /** Where the organization is located (if applicable) */
  location?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateOrganizationContributor */
export type CreateOrganizationContributorPayload = StandardMutationPayload & {
  __typename?: 'CreateOrganizationContributorPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created organization */
  contributor?: Maybe<OrganizationContributor>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreatePersonContributor */
export type CreatePersonContributorInput = {
  /** An email associated with the contributor */
  email?: Maybe<Scalars['String']>;
  /** A url associated with the contributor */
  url?: Maybe<Scalars['String']>;
  /** A summary of the contributor */
  bio?: Maybe<Scalars['String']>;
  links?: Maybe<Array<ContributorLinkInput>>;
  /** A reference to an upload in Tus. */
  image?: Maybe<UploadedFileInput>;
  givenName?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  affiliation?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreatePersonContributor */
export type CreatePersonContributorPayload = StandardMutationPayload & {
  __typename?: 'CreatePersonContributorPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created person */
  contributor?: Maybe<PersonContributor>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateRole */
export type CreateRoleInput = {
  name: Scalars['String'];
  accessControlList: Scalars['JSON'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateRole */
export type CreateRolePayload = StandardMutationPayload & {
  __typename?: 'CreateRolePayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  role?: Maybe<Role>;
};

export type DateProperty = ScalarProperty & {
  __typename?: 'DateProperty';
  date?: Maybe<Scalars['ISO8601Date']>;
  default?: Maybe<Scalars['ISO8601Date']>;
  fullPath: Scalars['String'];
  label?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  type: Scalars['String'];
};

/** Autogenerated input type of DestroyContribution */
export type DestroyContributionInput = {
  contributionId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of DestroyContribution */
export type DestroyContributionPayload = StandardMutationPayload & {
  __typename?: 'DestroyContributionPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  destroyed?: Maybe<Scalars['Boolean']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DestroyContributor */
export type DestroyContributorInput = {
  contributorId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of DestroyContributor */
export type DestroyContributorPayload = StandardMutationPayload & {
  __typename?: 'DestroyContributorPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  destroyed?: Maybe<Scalars['Boolean']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DestroyOrdering */
export type DestroyOrderingInput = {
  orderingId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of DestroyOrdering */
export type DestroyOrderingPayload = StandardMutationPayload & {
  __typename?: 'DestroyOrderingPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  destroyed?: Maybe<Scalars['Boolean']>;
  disabled?: Maybe<Scalars['Boolean']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

export type Direction =
  | 'ASCENDING'
  | 'DESCENDING'
  | '%future added value';

export type EmailProperty = ScalarProperty & {
  __typename?: 'EmailProperty';
  address?: Maybe<Scalars['String']>;
  defaultAddress?: Maybe<Scalars['String']>;
  fullPath: Scalars['String'];
  label?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  type: Scalars['String'];
};

/** An entity that exists in the hierarchy. */
export type Entity = {
  /** Derived access control list */
  accessControlList?: Maybe<AccessControlList>;
  /** A list of allowed actions for the given user on this entity (and its descendants). */
  allowedActions: Array<Scalars['String']>;
  /** The role(s) that gave the permissions to access this resource, if any. */
  applicableRoles?: Maybe<Array<Role>>;
  /** Previous entries in the hierarchy */
  breadcrumbs: Array<EntityBreadcrumb>;
  /** The depth of the hierarchical entity, taking into account any parent types */
  hierarchicalDepth: Scalars['Int'];
  links: EntityLinkConnection;
  /** Look up an ordering for this entity by identifier */
  ordering?: Maybe<Ordering>;
  orderings: OrderingConnection;
  /** An array of hashes that can be requested to load in a context */
  permissions: Array<PermissionGrant>;
  schemaDefinition: SchemaDefinition;
  /** A list of schema properties associated with this instance or version. */
  schemaProperties: Array<AnySchemaProperty>;
  schemaVersion: SchemaVersion;
  /** A mapping of an entity's preview thumbnail */
  thumbnail?: Maybe<AssetPreview>;
};


/** An entity that exists in the hierarchy. */
export type EntityLinksArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An entity that exists in the hierarchy. */
export type EntityOrderingArgs = {
  identifier: Scalars['String'];
};


/** An entity that exists in the hierarchy. */
export type EntityOrderingsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

export type EntityBreadcrumb = Node & {
  __typename?: 'EntityBreadcrumb';
  crumb: AnyEntity;
  depth: Scalars['Int'];
  id: Scalars['ID'];
  kind: EntityKind;
  label: Scalars['String'];
  slug: Scalars['String'];
};

/** An enumeration of the different kinds of hierarchical entities */
export type EntityKind =
  | 'COMMUNITY'
  | 'COLLECTION'
  | 'ITEM'
  | '%future added value';

/** A link between different entities */
export type EntityLink = Node & Sluggable & {
  __typename?: 'EntityLink';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  operator: EntityLinkOperator;
  scope: EntityLinkScope;
  slug: Scalars['Slug'];
  source: AnyEntity;
  sourceCollection?: Maybe<Collection>;
  sourceCommunity?: Maybe<Community>;
  sourceItem?: Maybe<Item>;
  target: AnyEntity;
  targetCollection?: Maybe<Collection>;
  targetCommunity?: Maybe<Community>;
  targetItem?: Maybe<Item>;
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for EntityLink. */
export type EntityLinkConnection = Paginated & {
  __typename?: 'EntityLinkConnection';
  /** A list of edges. */
  edges: Array<EntityLinkEdge>;
  /** A list of nodes. */
  nodes: Array<EntityLink>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EntityLinkEdge = {
  __typename?: 'EntityLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: EntityLink;
};

/** A link operator describes how a source is linked to its target */
export type EntityLinkOperator =
  | 'CONTAINS'
  | 'REFERENCES'
  | '%future added value';

/** A link scope succinctly describes the source and target types */
export type EntityLinkScope =
  /** A link to a community from another community */
  | 'COMMUNITY_LINKED_COMMUNITY'
  /** A link to a collection not directly owned by a community */
  | 'COMMUNITY_LINKED_COLLECTION'
  /** A link to an item from a community */
  | 'COMMUNITY_LINKED_ITEM'
  /** A link to a community from a collection */
  | 'COLLECTION_LINKED_COMMUNITY'
  /** A link to a collection from another collection */
  | 'COLLECTION_LINKED_COLLECTION'
  /** A link to an item from a community */
  | 'COLLECTION_LINKED_ITEM'
  /** A link to a community from an item */
  | 'ITEM_LINKED_COMMUNITY'
  /** A link to a collection from an item */
  | 'ITEM_LINKED_COLLECTION'
  /** A link to an item from another item */
  | 'ITEM_LINKED_ITEM'
  | '%future added value';

export type EntityPermissionFilter =
  | 'READ_ONLY'
  | 'CRUD'
  | '%future added value';

export type ExposesPermissions = {
  /** A list of allowed actions for the given user on this entity (and its descendants). */
  allowedActions: Array<Scalars['String']>;
  /** An array of hashes that can be requested to load in a context */
  permissions: Array<PermissionGrant>;
};

export type FloatProperty = ScalarProperty & {
  __typename?: 'FloatProperty';
  defaultFloat?: Maybe<Scalars['Float']>;
  floatValue?: Maybe<Scalars['Float']>;
  fullPath: Scalars['String'];
  label?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  type: Scalars['String'];
};

/** Autogenerated input type of GrantAccess */
export type GrantAccessInput = {
  entityId: Scalars['ID'];
  roleId: Scalars['ID'];
  userId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of GrantAccess */
export type GrantAccessPayload = StandardMutationPayload & {
  __typename?: 'GrantAccessPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  entity?: Maybe<AnyEntity>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Whether or not access was granted */
  granted?: Maybe<Scalars['Boolean']>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

export type GroupProperty = SchemaProperty & {
  __typename?: 'GroupProperty';
  fullPath: Scalars['String'];
  legend?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  properties: Array<AnyScalarProperty>;
  required: Scalars['Boolean'];
  type: Scalars['String'];
};

export type HasSchemaProperties = {
  /** A list of schema properties associated with this instance or version. */
  schemaProperties: Array<AnySchemaProperty>;
};

/** A hierarchical entry, like a collection or an item. */
export type HierarchicalEntry = {
  createdAt: Scalars['ISO8601DateTime'];
  doi?: Maybe<Scalars['String']>;
  identifier: Scalars['String'];
  leaf: Scalars['Boolean'];
  publishedOn?: Maybe<Scalars['ISO8601Date']>;
  root: Scalars['Boolean'];
  summary?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
  visibleAfterAt?: Maybe<Scalars['ISO8601DateTime']>;
};



export type IntegerProperty = ScalarProperty & {
  __typename?: 'IntegerProperty';
  defaultInteger?: Maybe<Scalars['Int']>;
  fullPath: Scalars['String'];
  integerValue?: Maybe<Scalars['Int']>;
  label?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  type: Scalars['String'];
};

/** An item that belongs to a collection */
export type Item = Entity & HierarchicalEntry & Contributable & HasSchemaProperties & Attachable & Node & Sluggable & {
  __typename?: 'Item';
  /** Derived access control list */
  accessControlList?: Maybe<AccessControlList>;
  /** A list of allowed actions for the given user on this entity (and its descendants). */
  allowedActions: Array<Scalars['String']>;
  /** The role(s) that gave the permissions to access this resource, if any. */
  applicableRoles?: Maybe<Array<Role>>;
  /** Assets owned by this entity */
  assets: AnyAssetConnection;
  /** Previous entries in the hierarchy */
  breadcrumbs: Array<EntityBreadcrumb>;
  /** @deprecated Use Item.items */
  children: ItemConnection;
  collection: Collection;
  community: Community;
  contributions: ItemContributionConnection;
  /** Contributors to this element */
  contributors: AnyContributorConnection;
  createdAt: Scalars['ISO8601DateTime'];
  doi?: Maybe<Scalars['String']>;
  /** The depth of the hierarchical entity, taking into account any parent types */
  hierarchicalDepth: Scalars['Int'];
  id: Scalars['ID'];
  identifier: Scalars['String'];
  items: ItemConnection;
  leaf: Scalars['Boolean'];
  links: EntityLinkConnection;
  /** Look up an ordering for this entity by identifier */
  ordering?: Maybe<Ordering>;
  orderings: OrderingConnection;
  parent?: Maybe<ItemParent>;
  /** An array of hashes that can be requested to load in a context */
  permissions: Array<PermissionGrant>;
  publishedOn?: Maybe<Scalars['ISO8601Date']>;
  root: Scalars['Boolean'];
  schemaDefinition: SchemaDefinition;
  /** A list of schema properties associated with this instance or version. */
  schemaProperties: Array<AnySchemaProperty>;
  schemaVersion: SchemaVersion;
  slug: Scalars['Slug'];
  summary?: Maybe<Scalars['String']>;
  /** A mapping of an entity's preview thumbnail */
  thumbnail?: Maybe<AssetPreview>;
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
  visibleAfterAt?: Maybe<Scalars['ISO8601DateTime']>;
};


/** An item that belongs to a collection */
export type ItemAssetsArgs = {
  order?: Maybe<SimpleOrder>;
  kind?: Maybe<AssetKindFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An item that belongs to a collection */
export type ItemChildrenArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** An item that belongs to a collection */
export type ItemContributionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An item that belongs to a collection */
export type ItemContributorsArgs = {
  order?: Maybe<SimpleOrder>;
  kind?: Maybe<ContributorFilterKind>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An item that belongs to a collection */
export type ItemItemsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An item that belongs to a collection */
export type ItemLinksArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An item that belongs to a collection */
export type ItemOrderingArgs = {
  identifier: Scalars['String'];
};


/** An item that belongs to a collection */
export type ItemOrderingsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** The connection type for Item. */
export type ItemConnection = Paginated & {
  __typename?: 'ItemConnection';
  /** A list of edges. */
  edges: Array<ItemEdge>;
  /** A list of nodes. */
  nodes: Array<Item>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** A contribution to an item */
export type ItemContribution = Contribution & Node & Sluggable & {
  __typename?: 'ItemContribution';
  /** A potentially-overridden value from person contributors */
  affiliation?: Maybe<Scalars['String']>;
  contributor: AnyContributor;
  contributorKind: ContributorKind;
  createdAt: Scalars['ISO8601DateTime'];
  /** A potentially-overridden display name value for all contributor types */
  displayName: Scalars['String'];
  id: Scalars['ID'];
  item: Item;
  /** A potentially-overridden value from organization contributors */
  location?: Maybe<Scalars['String']>;
  metadata: ContributionMetadata;
  /** An arbitrary text value describing the role the contributor had */
  role?: Maybe<Scalars['String']>;
  slug: Scalars['Slug'];
  /** A potentially-overridden value from person contributors */
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for ItemContribution. */
export type ItemContributionConnection = Paginated & {
  __typename?: 'ItemContributionConnection';
  /** A list of edges. */
  edges: Array<ItemContributionEdge>;
  /** A list of nodes. */
  nodes: Array<ItemContribution>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ItemContributionEdge = {
  __typename?: 'ItemContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ItemContribution;
};

/** An edge in a connection. */
export type ItemEdge = {
  __typename?: 'ItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Item;
};

export type ItemParent = Collection | Item | { __typename?: "%other" };


/** Autogenerated input type of LinkEntity */
export type LinkEntityInput = {
  /** The ID for the source entity */
  sourceId: Scalars['ID'];
  /** The ID for the target entity */
  targetId: Scalars['ID'];
  /** The 'type' of link */
  operator: EntityLinkOperator;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of LinkEntity */
export type LinkEntityPayload = StandardMutationPayload & {
  __typename?: 'LinkEntityPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  /** The created or updated link, if applicable */
  link?: Maybe<EntityLink>;
};

export type MarkdownProperty = ScalarProperty & {
  __typename?: 'MarkdownProperty';
  content?: Maybe<Scalars['String']>;
  default?: Maybe<Scalars['String']>;
  fullPath: Scalars['String'];
  label?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  type: Scalars['String'];
};

export type MultiselectProperty = ScalarProperty & OptionableProperty & {
  __typename?: 'MultiselectProperty';
  defaultSelections?: Maybe<Array<Scalars['String']>>;
  fullPath: Scalars['String'];
  label?: Maybe<Scalars['String']>;
  options: Array<SelectOption>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  selections?: Maybe<Array<Scalars['String']>>;
  type: Scalars['String'];
};

/** The entry point for making changes to the data within the WDP API. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Change a schema version for an entity. */
  alterSchemaVersion?: Maybe<AlterSchemaVersionPayload>;
  applySchemaProperties?: Maybe<ApplySchemaPropertiesPayload>;
  /** Associate an uploaded asset (already present in the Tus cache store) with an entity. */
  createAsset?: Maybe<CreateAssetPayload>;
  createCollection?: Maybe<CreateCollectionPayload>;
  /** Create a community */
  createCommunity?: Maybe<CreateCommunityPayload>;
  /** Create an item */
  createItem?: Maybe<CreateItemPayload>;
  /** Create an ordering for an entity */
  createOrdering?: Maybe<CreateOrderingPayload>;
  /** Create an organization contributor */
  createOrganizationContributor?: Maybe<CreateOrganizationContributorPayload>;
  /** Create a contributor */
  createPersonContributor?: Maybe<CreatePersonContributorPayload>;
  /**
   * Create a global role, with a set of permissions, that can be used to grant access to various parts of the hierarchy
   * in a granular fashion.
   */
  createRole?: Maybe<CreateRolePayload>;
  /** Destroy a Contribution by ID. */
  destroyContribution?: Maybe<DestroyContributionPayload>;
  /** Destroy a contributor by ID. */
  destroyContributor?: Maybe<DestroyContributorPayload>;
  /** Destroy (or disable a schema-inherited) ordering. */
  destroyOrdering?: Maybe<DestroyOrderingPayload>;
  /** Grant access to a specific hierarchical entity */
  grantAccess?: Maybe<GrantAccessPayload>;
  /** Link two entities together */
  linkEntity?: Maybe<LinkEntityPayload>;
  /**
   * Reassign the collection to another point in the hierarchy.
   *
   * This will update all child collections and descended items, if need be.
   */
  reparentCollection?: Maybe<ReparentCollectionPayload>;
  /**
   * Reassign the item to another point in the hierarchy.
   *
   * This will also update any descendant items, if need be.
   */
  reparentItem?: Maybe<ReparentItemPayload>;
  /**
   * Reset an ordering to "factory" settings. For schema-inherited orderings,
   * this will reload its definition from the schema definition. For custom
   * orderings, this will load minimal defaults.
   */
  resetOrdering?: Maybe<ResetOrderingPayload>;
  /** Revoke access from a specific hierarchical entity */
  revokeAccess?: Maybe<RevokeAccessPayload>;
  /** Update a collection */
  updateCollection?: Maybe<UpdateCollectionPayload>;
  /** Update a community */
  updateCommunity?: Maybe<UpdateCommunityPayload>;
  /** Update a Contribution by ID. */
  updateContribution?: Maybe<UpdateContributionPayload>;
  /** Update an item */
  updateItem?: Maybe<UpdateItemPayload>;
  /** Update an ordering by ID */
  updateOrdering?: Maybe<UpdateOrderingPayload>;
  /** Update an organization contributor */
  updateOrganizationContributor?: Maybe<UpdateOrganizationContributorPayload>;
  /** Update a person contributor */
  updatePersonContributor?: Maybe<UpdatePersonContributorPayload>;
  /** Update the name or permissions for a given role. */
  updateRole?: Maybe<UpdateRolePayload>;
  /**
   * Upsert a Contribution by contributable & contributor ID. It will override any
   * existing contributions for the same contributor on the same entity.
   */
  upsertContribution?: Maybe<UpsertContributionPayload>;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationAlterSchemaVersionArgs = {
  input: AlterSchemaVersionInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationApplySchemaPropertiesArgs = {
  input: ApplySchemaPropertiesInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationCreateAssetArgs = {
  input: CreateAssetInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationCreateCollectionArgs = {
  input: CreateCollectionInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationCreateCommunityArgs = {
  input: CreateCommunityInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationCreateItemArgs = {
  input: CreateItemInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationCreateOrderingArgs = {
  input: CreateOrderingInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationCreateOrganizationContributorArgs = {
  input: CreateOrganizationContributorInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationCreatePersonContributorArgs = {
  input: CreatePersonContributorInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationCreateRoleArgs = {
  input: CreateRoleInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationDestroyContributionArgs = {
  input: DestroyContributionInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationDestroyContributorArgs = {
  input: DestroyContributorInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationDestroyOrderingArgs = {
  input: DestroyOrderingInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationGrantAccessArgs = {
  input: GrantAccessInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationLinkEntityArgs = {
  input: LinkEntityInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationReparentCollectionArgs = {
  input: ReparentCollectionInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationReparentItemArgs = {
  input: ReparentItemInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationResetOrderingArgs = {
  input: ResetOrderingInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationRevokeAccessArgs = {
  input: RevokeAccessInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpdateCollectionArgs = {
  input: UpdateCollectionInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpdateCommunityArgs = {
  input: UpdateCommunityInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpdateContributionArgs = {
  input: UpdateContributionInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpdateItemArgs = {
  input: UpdateItemInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpdateOrderingArgs = {
  input: UpdateOrderingInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpdateOrganizationContributorArgs = {
  input: UpdateOrganizationContributorInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpdatePersonContributorArgs = {
  input: UpdatePersonContributorInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpdateRoleArgs = {
  input: UpdateRoleInput;
};


/** The entry point for making changes to the data within the WDP API. */
export type MutationUpsertContributionArgs = {
  input: UpsertContributionInput;
};

/** An error for a specific attribute in a mutationintended for use with react-hook-form and similarly shaped structures */
export type MutationAttributeError = {
  __typename?: 'MutationAttributeError';
  /** The accumulated messages for this combination of path and type */
  messages: Array<Scalars['String']>;
  /** The attribute that should have the error */
  path: Scalars['String'];
  /** A grouping type for the attribute */
  type: Scalars['String'];
};

export type MutationErrorScope =
  | 'GLOBAL'
  | 'ATTRIBUTE'
  | '%future added value';

/** An error that encapsulates the entire mutation input and is not tied to a specific input field. */
export type MutationGlobalError = {
  __typename?: 'MutationGlobalError';
  /** The actual message */
  message: Scalars['String'];
  type: Scalars['String'];
};

/** An object with an ID. */
export type Node = {
  /** ID of the object. */
  id: Scalars['ID'];
};

/** The priority for NULL values when sorting */
export type NullOrderPriority =
  | 'LAST'
  | 'FIRST'
  | '%future added value';

export type OptionableProperty = {
  options: Array<SelectOption>;
};

/** Ordering for a specific column */
export type OrderDefinitionInput = {
  path: Scalars['String'];
  direction?: Maybe<Direction>;
  nulls?: Maybe<NullOrderPriority>;
};

/** An ordering that belongs to an entity and arranges its children in a pre-configured way */
export type Ordering = Node & Sluggable & {
  __typename?: 'Ordering';
  children: OrderingEntryConnection;
  createdAt: Scalars['ISO8601DateTime'];
  /** Whether the ordering has been disabledorderings inherited from schemas will be disabled if deleted. */
  disabled: Scalars['Boolean'];
  /** The time the ordering was disabled, if applicable */
  disabledAt?: Maybe<Scalars['ISO8601Date']>;
  /** The entity that owns the ordering */
  entity: AnyEntity;
  /** Optional markdown content to render after the children */
  footer?: Maybe<Scalars['String']>;
  /** Optional markdown content to render before the children */
  header?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** A unique identifier for the ordering within the context of its parent entity. */
  identifier: Scalars['String'];
  /** Whether the ordering was inherited from its entity's schema definition */
  inheritedFromSchema: Scalars['Boolean'];
  /** An optional, human-readable name for the ordering */
  name?: Maybe<Scalars['String']>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};


/** An ordering that belongs to an entity and arranges its children in a pre-configured way */
export type OrderingChildrenArgs = {
  order?: Maybe<PositionDirection>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** The connection type for Ordering. */
export type OrderingConnection = Paginated & {
  __typename?: 'OrderingConnection';
  /** A list of edges. */
  edges: Array<OrderingEdge>;
  /** A list of nodes. */
  nodes: Array<Ordering>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type OrderingDirectSelection =
  | 'NONE'
  | 'CHILDREN'
  | 'DESCENDANTS'
  | '%future added value';

/** An edge in a connection. */
export type OrderingEdge = {
  __typename?: 'OrderingEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Ordering;
};

/** An entry within an ordering, it can refer to an entity or an entity link */
export type OrderingEntry = Node & Sluggable & {
  __typename?: 'OrderingEntry';
  createdAt: Scalars['ISO8601DateTime'];
  entry: AnyOrderingEntry;
  id: Scalars['ID'];
  /** The parent ordering */
  ordering: Ordering;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for OrderingEntry. */
export type OrderingEntryConnection = Paginated & {
  __typename?: 'OrderingEntryConnection';
  /** A list of edges. */
  edges: Array<OrderingEntryEdge>;
  /** A list of nodes. */
  nodes: Array<OrderingEntry>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type OrderingEntryEdge = {
  __typename?: 'OrderingEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: OrderingEntry;
};

export type OrderingFilterDefinitionInput = {
  schemas?: Maybe<Array<Scalars['String']>>;
};

export type OrderingSelectDefinitionInput = {
  direct?: Maybe<OrderingDirectSelection>;
  links?: Maybe<OrderingSelectLinkDefinitionInput>;
};

export type OrderingSelectLinkDefinitionInput = {
  contains?: Maybe<Scalars['Boolean']>;
  references?: Maybe<Scalars['Boolean']>;
};

/** An organization that has made contributions */
export type OrganizationContributor = Contributor & Node & Sluggable & {
  __typename?: 'OrganizationContributor';
  bio?: Maybe<Scalars['String']>;
  collectionContributions: CollectionContributionConnection;
  createdAt: Scalars['ISO8601DateTime'];
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  identifier: Scalars['String'];
  /** An optional image associated with the contributor */
  image?: Maybe<AssetPreview>;
  itemContributions: ItemContributionConnection;
  kind: ContributorKind;
  legalName?: Maybe<Scalars['String']>;
  links: Array<Maybe<ContributorLink>>;
  location?: Maybe<Scalars['String']>;
  prefix?: Maybe<Scalars['String']>;
  slug: Scalars['Slug'];
  suffix?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
  url?: Maybe<Scalars['String']>;
};


/** An organization that has made contributions */
export type OrganizationContributorCollectionContributionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** An organization that has made contributions */
export type OrganizationContributorItemContributionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** Determines the direction that page-number based pagination should flow */
export type PageDirection =
  | 'FORWARDS'
  | 'BACKWARDS'
  | '%future added value';

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** The page (if page-based pagination is supported and one was provided, does not introspect a value with cursor-based pagination) */
  page?: Maybe<Scalars['Int']>;
  /** The total number of pages available to the connection (if page-based pagination supported and a page was provided) */
  pageCount?: Maybe<Scalars['Int']>;
  /** The number of edges/nodes per page (if page-based pagination supported and a page was provided) */
  perPage?: Maybe<Scalars['Int']>;
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
  /** The total number of nodes available to this connection, constrained by applied filters (if any) */
  totalCount: Scalars['Int'];
  /** The total number of nodes available to this connection, independent of any filters */
  totalUnfilteredCount: Scalars['Int'];
};

/** Connections can be paginated by cursor or number. */
export type Paginated = {
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** A grant of a specific permission within a specific scope */
export type PermissionGrant = {
  __typename?: 'PermissionGrant';
  allowed: Scalars['Boolean'];
  name: Scalars['String'];
  scope?: Maybe<Scalars['String']>;
};

/** A person that has made contributions */
export type PersonContributor = Contributor & Node & Sluggable & {
  __typename?: 'PersonContributor';
  affiliation?: Maybe<Scalars['String']>;
  bio?: Maybe<Scalars['String']>;
  collectionContributions: CollectionContributionConnection;
  createdAt: Scalars['ISO8601DateTime'];
  email?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  givenName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  identifier: Scalars['String'];
  /** An optional image associated with the contributor */
  image?: Maybe<AssetPreview>;
  itemContributions: ItemContributionConnection;
  kind: ContributorKind;
  links: Array<Maybe<ContributorLink>>;
  prefix?: Maybe<Scalars['String']>;
  slug: Scalars['Slug'];
  suffix?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
  url?: Maybe<Scalars['String']>;
};


/** A person that has made contributions */
export type PersonContributorCollectionContributionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A person that has made contributions */
export type PersonContributorItemContributionsArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** An enum that describes sorting nodes by position in ascending or descending order. */
export type PositionDirection =
  | 'ASCENDING'
  | 'DESCENDING'
  | '%future added value';

export type PreviewImage = {
  __typename?: 'PreviewImage';
  alt: Scalars['String'];
  dimensions: Array<Scalars['Int']>;
  height: Scalars['Int'];
  url: Scalars['String'];
  width: Scalars['Int'];
};

export type PreviewImageMap = {
  __typename?: 'PreviewImageMap';
  alt: Scalars['String'];
  dimensions: Array<Scalars['Int']>;
  height: Scalars['Int'];
  png?: Maybe<PreviewImage>;
  webp?: Maybe<PreviewImage>;
  width: Scalars['Int'];
};

/** The entry point for retrieving data from within the WDP API. */
export type Query = {
  __typename?: 'Query';
  /** Look up a collection by slug */
  collection?: Maybe<Collection>;
  /** List all communities */
  communities: CommunityConnection;
  /** Look up a community by slug */
  community?: Maybe<Community>;
  /** Look up a contributor by slug */
  contributor?: Maybe<AnyContributor>;
  /** A list of all contributors in the system */
  contributors: AnyContributorConnection;
  /** Look up an item by slug */
  item?: Maybe<Item>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Fetches a list of objects given a list of IDs. */
  nodes: Array<Maybe<Node>>;
  /** List all roles */
  roles: RoleConnection;
  /** Look up a schema definition by slug */
  schemaDefinition?: Maybe<SchemaDefinition>;
  /** List all schema definitions */
  schemaDefinitions: SchemaDefinitionConnection;
  /** Look up a schema version by slug */
  schemaVersion?: Maybe<SchemaVersion>;
  /** List all schema versions */
  schemaVersions: SchemaVersionConnection;
  /** A list of all users in the system */
  users: UserConnection;
  /** The currently authenticated user. AKA: you */
  viewer: User;
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryCollectionArgs = {
  slug: Scalars['Slug'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryCommunitiesArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryCommunityArgs = {
  slug: Scalars['Slug'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryContributorArgs = {
  slug: Scalars['Slug'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryContributorsArgs = {
  order?: Maybe<SimpleOrder>;
  kind?: Maybe<ContributorFilterKind>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryItemArgs = {
  slug: Scalars['Slug'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryNodeArgs = {
  id: Scalars['ID'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryRolesArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** The entry point for retrieving data from within the WDP API. */
export type QuerySchemaDefinitionArgs = {
  slug: Scalars['Slug'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QuerySchemaDefinitionsArgs = {
  order?: Maybe<SimpleOrder>;
  namespace?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QuerySchemaVersionArgs = {
  slug: Scalars['Slug'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QuerySchemaVersionsArgs = {
  namespace?: Maybe<Scalars['String']>;
  order?: Maybe<SchemaVersionOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** The entry point for retrieving data from within the WDP API. */
export type QueryUsersArgs = {
  order?: Maybe<SimpleOrder>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** Autogenerated input type of ReparentCollection */
export type ReparentCollectionInput = {
  /** The collection in need of a new parent */
  collectionId: Scalars['ID'];
  /** The id for the collection's new parent. This can be a community or another collection. */
  parentId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of ReparentCollection */
export type ReparentCollectionPayload = StandardMutationPayload & {
  __typename?: 'ReparentCollectionPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  collection?: Maybe<Collection>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ReparentItem */
export type ReparentItemInput = {
  /** The collection in need of a new parent */
  itemId: Scalars['ID'];
  /** The id for the item's new parent. This can be a collection or another item. */
  parentId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of ReparentItem */
export type ReparentItemPayload = StandardMutationPayload & {
  __typename?: 'ReparentItemPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  item?: Maybe<Item>;
};

/** Autogenerated input type of ResetOrdering */
export type ResetOrderingInput = {
  orderingId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of ResetOrdering */
export type ResetOrderingPayload = StandardMutationPayload & {
  __typename?: 'ResetOrderingPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  ordering?: Maybe<Ordering>;
};

/** Autogenerated input type of RevokeAccess */
export type RevokeAccessInput = {
  entityId: Scalars['ID'];
  roleId: Scalars['ID'];
  userId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of RevokeAccess */
export type RevokeAccessPayload = StandardMutationPayload & {
  __typename?: 'RevokeAccessPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  entity?: Maybe<AnyEntity>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  /** Whether or not access was revoked */
  revoked?: Maybe<Scalars['Boolean']>;
};

/** A named role in the WDP API */
export type Role = Node & Sluggable & {
  __typename?: 'Role';
  /** The access control list for this specific role */
  accessControlList: AccessControlList;
  /** A list of action names that have been granted to this role */
  allowedActions: Array<Scalars['String']>;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  /** The human readable name of the role within the system */
  name: Scalars['String'];
  /**
   * Surfaced from the accessControlList for convenience, these are returned as
   * an array that allows a user to check for the state of all possible roles
   * without having to specify them explicitly in the GraphQL request
   */
  permissions: Array<PermissionGrant>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for Role. */
export type RoleConnection = Paginated & {
  __typename?: 'RoleConnection';
  /** A list of edges. */
  edges: Array<RoleEdge>;
  /** A list of nodes. */
  nodes: Array<Role>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RoleEdge = {
  __typename?: 'RoleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Role;
};

export type ScalarProperty = {
  fullPath: Scalars['String'];
  label?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  type: Scalars['String'];
};

export type SchemaDefinition = Node & Sluggable & {
  __typename?: 'SchemaDefinition';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  identifier: Scalars['String'];
  kind: SchemaKind;
  name: Scalars['String'];
  namespace: Scalars['String'];
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for SchemaDefinition. */
export type SchemaDefinitionConnection = Paginated & {
  __typename?: 'SchemaDefinitionConnection';
  /** A list of edges. */
  edges: Array<SchemaDefinitionEdge>;
  /** A list of nodes. */
  nodes: Array<SchemaDefinition>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SchemaDefinitionEdge = {
  __typename?: 'SchemaDefinitionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: SchemaDefinition;
};

export type SchemaKind =
  | 'COMMUNITY'
  | 'COLLECTION'
  | 'ITEM'
  /** Presently unused */
  | 'METADATA'
  | '%future added value';

export type SchemaProperty = {
  fullPath: Scalars['String'];
  path: Scalars['String'];
  type: Scalars['String'];
};

/** An error that stems from trying to apply an invalid schema value. */
export type SchemaValueError = {
  __typename?: 'SchemaValueError';
  /** An error with the entire set of values */
  base: Scalars['Boolean'];
  /** Whether this is a hint */
  hint: Scalars['Boolean'];
  /** A human-readable description of the error */
  message: Scalars['String'];
  /** Additional metadata attached to the error */
  metadata?: Maybe<Scalars['JSON']>;
  /** Which input value this error came from */
  path?: Maybe<Scalars['String']>;
};

/** A specific version of a schema definition */
export type SchemaVersion = HasSchemaProperties & Node & Sluggable & {
  __typename?: 'SchemaVersion';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  identifier: Scalars['String'];
  kind: SchemaKind;
  name: Scalars['String'];
  namespace: Scalars['String'];
  number: Scalars['String'];
  schemaDefinition: SchemaDefinition;
  /** A list of schema properties associated with this instance or version. */
  schemaProperties: Array<AnySchemaProperty>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for SchemaVersion. */
export type SchemaVersionConnection = Paginated & {
  __typename?: 'SchemaVersionConnection';
  /** A list of edges. */
  edges: Array<SchemaVersionEdge>;
  /** A list of nodes. */
  nodes: Array<SchemaVersion>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SchemaVersionEdge = {
  __typename?: 'SchemaVersionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: SchemaVersion;
};

/** Order schema versions by various factors */
export type SchemaVersionOrder =
  /** Order with newest versions at the top */
  | 'LATEST'
  /** Order with oldest versions at the top */
  | 'OLDEST'
  | '%future added value';

export type SelectOption = {
  __typename?: 'SelectOption';
  label: Scalars['String'];
  value: Scalars['String'];
};

export type SelectProperty = ScalarProperty & OptionableProperty & {
  __typename?: 'SelectProperty';
  defaultSelection?: Maybe<Scalars['String']>;
  fullPath: Scalars['String'];
  label?: Maybe<Scalars['String']>;
  options: Array<SelectOption>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  selection?: Maybe<Scalars['String']>;
  type: Scalars['String'];
};

export type SimpleOrder =
  | 'RECENT'
  | 'OLDEST'
  | '%future added value';


/** Objects have a serialized slug for looking them up in the system and generating links without UUIDs */
export type Sluggable = {
  slug: Scalars['Slug'];
};

/** Most mutations implement this interface in their payload in order to offer a standardize response value */
export type StandardMutationPayload = {
  attributeErrors: Array<MutationAttributeError>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

export type StringProperty = ScalarProperty & {
  __typename?: 'StringProperty';
  content?: Maybe<Scalars['String']>;
  default?: Maybe<Scalars['String']>;
  fullPath: Scalars['String'];
  label?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  type: Scalars['String'];
};

export type TagsProperty = ScalarProperty & {
  __typename?: 'TagsProperty';
  fullPath: Scalars['String'];
  label?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  tags: Array<Scalars['String']>;
  type: Scalars['String'];
};

export type TimestampProperty = ScalarProperty & {
  __typename?: 'TimestampProperty';
  default?: Maybe<Scalars['ISO8601DateTime']>;
  fullPath: Scalars['String'];
  label?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  timestamp?: Maybe<Scalars['ISO8601DateTime']>;
  type: Scalars['String'];
};

/** When retrieving a paginated connection of tree-like entities, this enum is used to delineate which class of nodes to retrieve. Usually, you only want roots, but two other possibilities are exposed. */
export type TreeNodeFilter =
  /** Fetch only nodes that are "roots": nodes that do not have a parent of the same type */
  | 'ROOTS_ONLY'
  /** Fetch all nodes that match other filters passed to the resolver */
  | 'ROOTS_AND_LEAVES'
  /** Fetch only nodes that are "leaves"; nodes that have a parent of the same type */
  | 'LEAVES_ONLY'
  | '%future added value';

export type UnknownProperty = ScalarProperty & {
  __typename?: 'UnknownProperty';
  default?: Maybe<Scalars['JSON']>;
  fullPath: Scalars['String'];
  label?: Maybe<Scalars['String']>;
  path: Scalars['String'];
  required?: Maybe<Scalars['Boolean']>;
  type: Scalars['String'];
  unknownValue?: Maybe<Scalars['JSON']>;
};

/** Autogenerated input type of UpdateCollection */
export type UpdateCollectionInput = {
  collectionId: Scalars['ID'];
  /** Human readable title for the collection */
  title: Scalars['String'];
  /** Machine readable title for the collection, should be unique within its scope */
  identifier: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateCollection */
export type UpdateCollectionPayload = StandardMutationPayload & {
  __typename?: 'UpdateCollectionPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A new representation of the collection, on a successful update */
  collection?: Maybe<Collection>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateCommunity */
export type UpdateCommunityInput = {
  communityId: Scalars['ID'];
  /** A human readable title for the community */
  title: Scalars['String'];
  /** The position the community occupies in the list */
  position?: Maybe<Scalars['Int']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateCommunity */
export type UpdateCommunityPayload = StandardMutationPayload & {
  __typename?: 'UpdateCommunityPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A new representation of the community, on a succesful update */
  community?: Maybe<Community>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateContribution */
export type UpdateContributionInput = {
  contributionId: Scalars['ID'];
  /** An arbitrary text value that describes the kind of contribution */
  role?: Maybe<Scalars['String']>;
  metadata?: Maybe<ContributionMetadataInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateContribution */
export type UpdateContributionPayload = StandardMutationPayload & {
  __typename?: 'UpdateContributionPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contribution?: Maybe<AnyContribution>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateItem */
export type UpdateItemInput = {
  /** The item to update */
  itemId: Scalars['ID'];
  title: Scalars['String'];
  identifier: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateItem */
export type UpdateItemPayload = StandardMutationPayload & {
  __typename?: 'UpdateItemPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  /** A new representation of the item, on a succesful update */
  item?: Maybe<Item>;
};

/** Autogenerated input type of UpdateOrdering */
export type UpdateOrderingInput = {
  /** The ID for the ordering to update */
  orderingId: Scalars['ID'];
  /** A human readable label for the ordering */
  name?: Maybe<Scalars['String']>;
  /** Optional markdown content to display before the ordering's children */
  header?: Maybe<Scalars['String']>;
  /** Optional markdown content to display after the ordering's children */
  footer?: Maybe<Scalars['String']>;
  filter?: Maybe<OrderingFilterDefinitionInput>;
  select?: Maybe<OrderingSelectDefinitionInput>;
  order: Array<OrderDefinitionInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateOrdering */
export type UpdateOrderingPayload = StandardMutationPayload & {
  __typename?: 'UpdateOrderingPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  /** The updated ordering */
  ordering?: Maybe<Ordering>;
};

/** Autogenerated input type of UpdateOrganizationContributor */
export type UpdateOrganizationContributorInput = {
  /** An email associated with the contributor */
  email?: Maybe<Scalars['String']>;
  /** A url associated with the contributor */
  url?: Maybe<Scalars['String']>;
  /** A summary of the contributor */
  bio?: Maybe<Scalars['String']>;
  links?: Maybe<Array<ContributorLinkInput>>;
  /** A reference to an upload in Tus. */
  image?: Maybe<UploadedFileInput>;
  /** The legal name of the organization */
  legalName?: Maybe<Scalars['String']>;
  /** Where the organization is located (if applicable) */
  location?: Maybe<Scalars['String']>;
  contributorId: Scalars['ID'];
  /** If set to true, this will clear the attachment image on this model. */
  clearImage?: Maybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateOrganizationContributor */
export type UpdateOrganizationContributorPayload = StandardMutationPayload & {
  __typename?: 'UpdateOrganizationContributorPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated organization */
  contributor?: Maybe<OrganizationContributor>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdatePersonContributor */
export type UpdatePersonContributorInput = {
  /** An email associated with the contributor */
  email?: Maybe<Scalars['String']>;
  /** A url associated with the contributor */
  url?: Maybe<Scalars['String']>;
  /** A summary of the contributor */
  bio?: Maybe<Scalars['String']>;
  links?: Maybe<Array<ContributorLinkInput>>;
  /** A reference to an upload in Tus. */
  image?: Maybe<UploadedFileInput>;
  givenName?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  affiliation?: Maybe<Scalars['String']>;
  contributorId: Scalars['ID'];
  /** If set to true, this will clear the attachment image on this model. */
  clearImage?: Maybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdatePersonContributor */
export type UpdatePersonContributorPayload = StandardMutationPayload & {
  __typename?: 'UpdatePersonContributorPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created person */
  contributor?: Maybe<PersonContributor>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateRole */
export type UpdateRoleInput = {
  roleId: Scalars['ID'];
  name: Scalars['String'];
  accessControlList: Scalars['JSON'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateRole */
export type UpdateRolePayload = StandardMutationPayload & {
  __typename?: 'UpdateRolePayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
  role?: Maybe<Role>;
};


/** The name of a storage that can contain user uploads. There's only one option at present. */
export type UploadStorage =
  /** Temporary storage. Cleaned on a regular basis if uploads are not attached anywhere. */
  | 'CACHE'
  | '%future added value';

/** A definition for a file upload */
export type UploadedFileInput = {
  id: Scalars['UploadID'];
  /** The storage that contains the input. */
  storage?: Maybe<UploadStorage>;
  metadata?: Maybe<UploadedFileMetadataInput>;
};

/** File metadata to attach to the upload. */
export type UploadedFileMetadataInput = {
  /** The original filename, since Tus mangles them. */
  filename?: Maybe<Scalars['String']>;
  /**
   * The original content type. WDP will detect a real content type, so this can't be spoofed, but it can be helpful with generating
   * an initial asset with the correct kind.
   */
  mimeType?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpsertContribution */
export type UpsertContributionInput = {
  contributableId: Scalars['ID'];
  contributorId: Scalars['ID'];
  /** An arbitrary text value that describes the kind of contribution */
  role?: Maybe<Scalars['String']>;
  metadata?: Maybe<ContributionMetadataInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpsertContribution */
export type UpsertContributionPayload = StandardMutationPayload & {
  __typename?: 'UpsertContributionPayload';
  attributeErrors: Array<MutationAttributeError>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  contribution?: Maybe<AnyContribution>;
  errors: Array<UserError>;
  globalErrors: Array<MutationGlobalError>;
  /** Not presently used */
  haltCode?: Maybe<Scalars['String']>;
};

/** A known or anonymous user in the system. Registration and management is primarily handled through the WDP Keycloak instance. */
export type User = ExposesPermissions & Node & Sluggable & {
  __typename?: 'User';
  /** A list of allowed actions for the given user on this entity (and its descendants). */
  allowedActions: Array<Scalars['String']>;
  /** Is this an anonymous / unauthenticated user? */
  anonymous: Scalars['Boolean'];
  /** Query the collections this user has access to */
  collections: CollectionConnection;
  /** Query the communities this user has access to */
  communities: CommunityConnection;
  createdAt: Scalars['ISO8601DateTime'];
  /** A user's email. Depending on the upstream provider, this may not be set. */
  email?: Maybe<Scalars['String']>;
  /** Has this user's email been verified to work through Keycloak? */
  emailVerified: Scalars['Boolean'];
  /** Does this user have access to administer the entire instance? */
  globalAdmin: Scalars['Boolean'];
  id: Scalars['ID'];
  /** Query the items this user has access to */
  items: ItemConnection;
  /** The user's full provided name. Depending on the upstream provider, this may not be set. */
  name?: Maybe<Scalars['String']>;
  /** An array of hashes that can be requested to load in a context */
  permissions: Array<PermissionGrant>;
  slug: Scalars['Slug'];
  updatedAt: Scalars['ISO8601DateTime'];
  /** Can this user upload anything at all? */
  uploadAccess: Scalars['Boolean'];
  /** If a user has any upload access, this token will allow them to do so. */
  uploadToken?: Maybe<Scalars['String']>;
  /** A unique username for the user. Depending on the upstream provider, this may not be set. */
  username?: Maybe<Scalars['String']>;
};


/** A known or anonymous user in the system. Registration and management is primarily handled through the WDP Keycloak instance. */
export type UserCollectionsArgs = {
  access?: Maybe<EntityPermissionFilter>;
  order?: Maybe<SimpleOrder>;
  schema?: Maybe<Array<Scalars['String']>>;
  nodeFilter?: Maybe<TreeNodeFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A known or anonymous user in the system. Registration and management is primarily handled through the WDP Keycloak instance. */
export type UserCommunitiesArgs = {
  access?: Maybe<EntityPermissionFilter>;
  order?: Maybe<SimpleOrder>;
  schema?: Maybe<Array<Scalars['String']>>;
  nodeFilter?: Maybe<TreeNodeFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};


/** A known or anonymous user in the system. Registration and management is primarily handled through the WDP Keycloak instance. */
export type UserItemsArgs = {
  access?: Maybe<EntityPermissionFilter>;
  order?: Maybe<SimpleOrder>;
  schema?: Maybe<Array<Scalars['String']>>;
  nodeFilter?: Maybe<TreeNodeFilter>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  page?: Maybe<Scalars['Int']>;
  pageDirection?: PageDirection;
  perPage?: Scalars['Int'];
};

/** The connection type for User. */
export type UserConnection = Paginated & {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges: Array<UserEdge>;
  /** A list of nodes. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: User;
};

/** A user-readable error. Somewhat deprecated now, but may be repurposed */
export type UserError = {
  __typename?: 'UserError';
  /** The attribute path to this error, if applicable */
  attributePath?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  /** A description of the error */
  message: Scalars['String'];
  /** Which input value this error came from */
  path?: Maybe<Array<Scalars['String']>>;
  /** Whether this error applies to a single attribute, or globally to the entire form */
  scope: MutationErrorScope;
};



export type ResolverTypeWrapper<T> = Promise<T> | T;


export type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
  fragment: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
  selectionSet: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  AccessControlList: ResolverTypeWrapper<AccessControlList>;
  AlterSchemaVersionInput: AlterSchemaVersionInput;
  ID: ResolverTypeWrapper<Scalars['ID']>;
  String: ResolverTypeWrapper<Scalars['String']>;
  AlterSchemaVersionPayload: ResolverTypeWrapper<Omit<AlterSchemaVersionPayload, 'entity'> & { entity?: Maybe<ResolversTypes['AnyEntity']> }>;
  AnyAsset: ResolversTypes['AssetAudio'] | ResolversTypes['AssetDocument'] | ResolversTypes['AssetImage'] | ResolversTypes['AssetPDF'] | ResolversTypes['AssetUnknown'] | ResolversTypes['AssetVideo'];
  AnyAssetConnection: ResolverTypeWrapper<Omit<AnyAssetConnection, 'nodes'> & { nodes: Array<ResolversTypes['AnyAsset']> }>;
  AnyAssetEdge: ResolverTypeWrapper<Omit<AnyAssetEdge, 'node'> & { node: ResolversTypes['AnyAsset'] }>;
  AnyAttachable: ResolversTypes['Collection'] | ResolversTypes['Community'] | ResolversTypes['Item'];
  AnyContribution: ResolversTypes['CollectionContribution'] | ResolversTypes['ItemContribution'];
  AnyContributor: ResolversTypes['OrganizationContributor'] | ResolversTypes['PersonContributor'];
  AnyContributorConnection: ResolverTypeWrapper<Omit<AnyContributorConnection, 'nodes'> & { nodes: Array<ResolversTypes['AnyContributor']> }>;
  AnyContributorEdge: ResolverTypeWrapper<Omit<AnyContributorEdge, 'node'> & { node: ResolversTypes['AnyContributor'] }>;
  AnyEntity: ResolversTypes['Collection'] | ResolversTypes['Community'] | ResolversTypes['Item'];
  AnyOrderingEntry: ResolversTypes['Collection'] | ResolversTypes['Community'] | ResolversTypes['EntityLink'] | ResolversTypes['Item'];
  AnyScalarProperty: ResolversTypes['AssetProperty'] | ResolversTypes['AssetsProperty'] | ResolversTypes['BooleanProperty'] | ResolversTypes['ContributorProperty'] | ResolversTypes['ContributorsProperty'] | ResolversTypes['DateProperty'] | ResolversTypes['EmailProperty'] | ResolversTypes['FloatProperty'] | ResolversTypes['IntegerProperty'] | ResolversTypes['MarkdownProperty'] | ResolversTypes['MultiselectProperty'] | ResolversTypes['SelectProperty'] | ResolversTypes['StringProperty'] | ResolversTypes['TagsProperty'] | ResolversTypes['TimestampProperty'] | ResolversTypes['UnknownProperty'];
  AnySchemaProperty: ResolversTypes['AssetProperty'] | ResolversTypes['AssetsProperty'] | ResolversTypes['BooleanProperty'] | ResolversTypes['ContributorProperty'] | ResolversTypes['ContributorsProperty'] | ResolversTypes['DateProperty'] | ResolversTypes['EmailProperty'] | ResolversTypes['FloatProperty'] | ResolversTypes['GroupProperty'] | ResolversTypes['IntegerProperty'] | ResolversTypes['MarkdownProperty'] | ResolversTypes['MultiselectProperty'] | ResolversTypes['SelectProperty'] | ResolversTypes['StringProperty'] | ResolversTypes['TagsProperty'] | ResolversTypes['TimestampProperty'] | ResolversTypes['UnknownProperty'];
  ApplySchemaPropertiesInput: ApplySchemaPropertiesInput;
  ApplySchemaPropertiesPayload: ResolverTypeWrapper<Omit<ApplySchemaPropertiesPayload, 'entity'> & { entity?: Maybe<ResolversTypes['AnyEntity']> }>;
  Asset: ResolversTypes['AssetAudio'] | ResolversTypes['AssetDocument'] | ResolversTypes['AssetImage'] | ResolversTypes['AssetPDF'] | ResolversTypes['AssetUnknown'] | ResolversTypes['AssetVideo'];
  Int: ResolverTypeWrapper<Scalars['Int']>;
  AssetAudio: ResolverTypeWrapper<Omit<AssetAudio, 'attachable'> & { attachable: ResolversTypes['AnyAttachable'] }>;
  AssetDocument: ResolverTypeWrapper<Omit<AssetDocument, 'attachable'> & { attachable: ResolversTypes['AnyAttachable'] }>;
  AssetImage: ResolverTypeWrapper<Omit<AssetImage, 'attachable'> & { attachable: ResolversTypes['AnyAttachable'] }>;
  AssetKind: AssetKind;
  AssetKindFilter: AssetKindFilter;
  AssetPDF: ResolverTypeWrapper<Omit<AssetPdf, 'attachable'> & { attachable: ResolversTypes['AnyAttachable'] }>;
  AssetPreview: ResolverTypeWrapper<AssetPreview>;
  AssetProperty: ResolverTypeWrapper<Omit<AssetProperty, 'asset'> & { asset?: Maybe<ResolversTypes['AnyAsset']> }>;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  AssetUnknown: ResolverTypeWrapper<Omit<AssetUnknown, 'attachable'> & { attachable: ResolversTypes['AnyAttachable'] }>;
  AssetVideo: ResolverTypeWrapper<Omit<AssetVideo, 'attachable'> & { attachable: ResolversTypes['AnyAttachable'] }>;
  AssetsProperty: ResolverTypeWrapper<Omit<AssetsProperty, 'assets'> & { assets: Array<ResolversTypes['AnyAsset']> }>;
  Attachable: ResolversTypes['Collection'] | ResolversTypes['Community'] | ResolversTypes['Item'];
  BooleanProperty: ResolverTypeWrapper<BooleanProperty>;
  Collection: ResolverTypeWrapper<Omit<Collection, 'parent' | 'schemaProperties'> & { parent?: Maybe<ResolversTypes['CollectionParent']>, schemaProperties: Array<ResolversTypes['AnySchemaProperty']> }>;
  CollectionConnection: ResolverTypeWrapper<CollectionConnection>;
  CollectionContribution: ResolverTypeWrapper<Omit<CollectionContribution, 'contributor'> & { contributor: ResolversTypes['AnyContributor'] }>;
  CollectionContributionConnection: ResolverTypeWrapper<CollectionContributionConnection>;
  CollectionContributionEdge: ResolverTypeWrapper<CollectionContributionEdge>;
  CollectionEdge: ResolverTypeWrapper<CollectionEdge>;
  CollectionParent: ResolversTypes['Collection'] | ResolversTypes['Community'];
  Community: ResolverTypeWrapper<Omit<Community, 'schemaProperties'> & { schemaProperties: Array<ResolversTypes['AnySchemaProperty']> }>;
  CommunityConnection: ResolverTypeWrapper<CommunityConnection>;
  CommunityEdge: ResolverTypeWrapper<CommunityEdge>;
  Contributable: ResolversTypes['Collection'] | ResolversTypes['Item'];
  Contribution: ResolversTypes['CollectionContribution'] | ResolversTypes['ItemContribution'];
  ContributionMetadata: ResolverTypeWrapper<ContributionMetadata>;
  ContributionMetadataInput: ContributionMetadataInput;
  Contributor: ResolversTypes['OrganizationContributor'] | ResolversTypes['PersonContributor'];
  ContributorFilterKind: ContributorFilterKind;
  ContributorKind: ContributorKind;
  ContributorLink: ResolverTypeWrapper<ContributorLink>;
  ContributorLinkInput: ContributorLinkInput;
  ContributorProperty: ResolverTypeWrapper<Omit<ContributorProperty, 'contributor'> & { contributor?: Maybe<ResolversTypes['AnyContributor']> }>;
  ContributorsProperty: ResolverTypeWrapper<Omit<ContributorsProperty, 'contributors'> & { contributors: Array<ResolversTypes['AnyContributor']> }>;
  CreateAssetInput: CreateAssetInput;
  CreateAssetPayload: ResolverTypeWrapper<Omit<CreateAssetPayload, 'asset'> & { asset?: Maybe<ResolversTypes['AnyAsset']> }>;
  CreateCollectionInput: CreateCollectionInput;
  CreateCollectionPayload: ResolverTypeWrapper<CreateCollectionPayload>;
  CreateCommunityInput: CreateCommunityInput;
  CreateCommunityPayload: ResolverTypeWrapper<CreateCommunityPayload>;
  CreateItemInput: CreateItemInput;
  CreateItemPayload: ResolverTypeWrapper<CreateItemPayload>;
  CreateOrderingInput: CreateOrderingInput;
  CreateOrderingPayload: ResolverTypeWrapper<CreateOrderingPayload>;
  CreateOrganizationContributorInput: CreateOrganizationContributorInput;
  CreateOrganizationContributorPayload: ResolverTypeWrapper<CreateOrganizationContributorPayload>;
  CreatePersonContributorInput: CreatePersonContributorInput;
  CreatePersonContributorPayload: ResolverTypeWrapper<CreatePersonContributorPayload>;
  CreateRoleInput: CreateRoleInput;
  CreateRolePayload: ResolverTypeWrapper<CreateRolePayload>;
  DateProperty: ResolverTypeWrapper<DateProperty>;
  DestroyContributionInput: DestroyContributionInput;
  DestroyContributionPayload: ResolverTypeWrapper<DestroyContributionPayload>;
  DestroyContributorInput: DestroyContributorInput;
  DestroyContributorPayload: ResolverTypeWrapper<DestroyContributorPayload>;
  DestroyOrderingInput: DestroyOrderingInput;
  DestroyOrderingPayload: ResolverTypeWrapper<DestroyOrderingPayload>;
  Direction: Direction;
  EmailProperty: ResolverTypeWrapper<EmailProperty>;
  Entity: ResolversTypes['Collection'] | ResolversTypes['Community'] | ResolversTypes['Item'];
  EntityBreadcrumb: ResolverTypeWrapper<Omit<EntityBreadcrumb, 'crumb'> & { crumb: ResolversTypes['AnyEntity'] }>;
  EntityKind: EntityKind;
  EntityLink: ResolverTypeWrapper<Omit<EntityLink, 'source' | 'target'> & { source: ResolversTypes['AnyEntity'], target: ResolversTypes['AnyEntity'] }>;
  EntityLinkConnection: ResolverTypeWrapper<EntityLinkConnection>;
  EntityLinkEdge: ResolverTypeWrapper<EntityLinkEdge>;
  EntityLinkOperator: EntityLinkOperator;
  EntityLinkScope: EntityLinkScope;
  EntityPermissionFilter: EntityPermissionFilter;
  ExposesPermissions: ResolversTypes['User'];
  FloatProperty: ResolverTypeWrapper<FloatProperty>;
  Float: ResolverTypeWrapper<Scalars['Float']>;
  GrantAccessInput: GrantAccessInput;
  GrantAccessPayload: ResolverTypeWrapper<Omit<GrantAccessPayload, 'entity'> & { entity?: Maybe<ResolversTypes['AnyEntity']> }>;
  GroupProperty: ResolverTypeWrapper<Omit<GroupProperty, 'properties'> & { properties: Array<ResolversTypes['AnyScalarProperty']> }>;
  HasSchemaProperties: ResolversTypes['Collection'] | ResolversTypes['Community'] | ResolversTypes['Item'] | ResolversTypes['SchemaVersion'];
  HierarchicalEntry: ResolversTypes['Collection'] | ResolversTypes['Item'];
  ISO8601Date: ResolverTypeWrapper<Scalars['ISO8601Date']>;
  ISO8601DateTime: ResolverTypeWrapper<Scalars['ISO8601DateTime']>;
  IntegerProperty: ResolverTypeWrapper<IntegerProperty>;
  Item: ResolverTypeWrapper<Omit<Item, 'parent' | 'schemaProperties'> & { parent?: Maybe<ResolversTypes['ItemParent']>, schemaProperties: Array<ResolversTypes['AnySchemaProperty']> }>;
  ItemConnection: ResolverTypeWrapper<ItemConnection>;
  ItemContribution: ResolverTypeWrapper<Omit<ItemContribution, 'contributor'> & { contributor: ResolversTypes['AnyContributor'] }>;
  ItemContributionConnection: ResolverTypeWrapper<ItemContributionConnection>;
  ItemContributionEdge: ResolverTypeWrapper<ItemContributionEdge>;
  ItemEdge: ResolverTypeWrapper<ItemEdge>;
  ItemParent: ResolversTypes['Collection'] | ResolversTypes['Item'];
  JSON: ResolverTypeWrapper<Scalars['JSON']>;
  LinkEntityInput: LinkEntityInput;
  LinkEntityPayload: ResolverTypeWrapper<LinkEntityPayload>;
  MarkdownProperty: ResolverTypeWrapper<MarkdownProperty>;
  MultiselectProperty: ResolverTypeWrapper<MultiselectProperty>;
  Mutation: ResolverTypeWrapper<{}>;
  MutationAttributeError: ResolverTypeWrapper<MutationAttributeError>;
  MutationErrorScope: MutationErrorScope;
  MutationGlobalError: ResolverTypeWrapper<MutationGlobalError>;
  Node: ResolversTypes['AssetAudio'] | ResolversTypes['AssetDocument'] | ResolversTypes['AssetImage'] | ResolversTypes['AssetPDF'] | ResolversTypes['AssetUnknown'] | ResolversTypes['AssetVideo'] | ResolversTypes['Collection'] | ResolversTypes['CollectionContribution'] | ResolversTypes['Community'] | ResolversTypes['EntityBreadcrumb'] | ResolversTypes['EntityLink'] | ResolversTypes['Item'] | ResolversTypes['ItemContribution'] | ResolversTypes['Ordering'] | ResolversTypes['OrderingEntry'] | ResolversTypes['OrganizationContributor'] | ResolversTypes['PersonContributor'] | ResolversTypes['Role'] | ResolversTypes['SchemaDefinition'] | ResolversTypes['SchemaVersion'] | ResolversTypes['User'];
  NullOrderPriority: NullOrderPriority;
  OptionableProperty: ResolversTypes['MultiselectProperty'] | ResolversTypes['SelectProperty'];
  OrderDefinitionInput: OrderDefinitionInput;
  Ordering: ResolverTypeWrapper<Omit<Ordering, 'entity'> & { entity: ResolversTypes['AnyEntity'] }>;
  OrderingConnection: ResolverTypeWrapper<OrderingConnection>;
  OrderingDirectSelection: OrderingDirectSelection;
  OrderingEdge: ResolverTypeWrapper<OrderingEdge>;
  OrderingEntry: ResolverTypeWrapper<Omit<OrderingEntry, 'entry'> & { entry: ResolversTypes['AnyOrderingEntry'] }>;
  OrderingEntryConnection: ResolverTypeWrapper<OrderingEntryConnection>;
  OrderingEntryEdge: ResolverTypeWrapper<OrderingEntryEdge>;
  OrderingFilterDefinitionInput: OrderingFilterDefinitionInput;
  OrderingSelectDefinitionInput: OrderingSelectDefinitionInput;
  OrderingSelectLinkDefinitionInput: OrderingSelectLinkDefinitionInput;
  OrganizationContributor: ResolverTypeWrapper<OrganizationContributor>;
  PageDirection: PageDirection;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  Paginated: ResolversTypes['AnyAssetConnection'] | ResolversTypes['AnyContributorConnection'] | ResolversTypes['CollectionConnection'] | ResolversTypes['CollectionContributionConnection'] | ResolversTypes['CommunityConnection'] | ResolversTypes['EntityLinkConnection'] | ResolversTypes['ItemConnection'] | ResolversTypes['ItemContributionConnection'] | ResolversTypes['OrderingConnection'] | ResolversTypes['OrderingEntryConnection'] | ResolversTypes['RoleConnection'] | ResolversTypes['SchemaDefinitionConnection'] | ResolversTypes['SchemaVersionConnection'] | ResolversTypes['UserConnection'];
  PermissionGrant: ResolverTypeWrapper<PermissionGrant>;
  PersonContributor: ResolverTypeWrapper<PersonContributor>;
  PositionDirection: PositionDirection;
  PreviewImage: ResolverTypeWrapper<PreviewImage>;
  PreviewImageMap: ResolverTypeWrapper<PreviewImageMap>;
  Query: ResolverTypeWrapper<{}>;
  ReparentCollectionInput: ReparentCollectionInput;
  ReparentCollectionPayload: ResolverTypeWrapper<ReparentCollectionPayload>;
  ReparentItemInput: ReparentItemInput;
  ReparentItemPayload: ResolverTypeWrapper<ReparentItemPayload>;
  ResetOrderingInput: ResetOrderingInput;
  ResetOrderingPayload: ResolverTypeWrapper<ResetOrderingPayload>;
  RevokeAccessInput: RevokeAccessInput;
  RevokeAccessPayload: ResolverTypeWrapper<Omit<RevokeAccessPayload, 'entity'> & { entity?: Maybe<ResolversTypes['AnyEntity']> }>;
  Role: ResolverTypeWrapper<Role>;
  RoleConnection: ResolverTypeWrapper<RoleConnection>;
  RoleEdge: ResolverTypeWrapper<RoleEdge>;
  ScalarProperty: ResolversTypes['AssetProperty'] | ResolversTypes['AssetsProperty'] | ResolversTypes['BooleanProperty'] | ResolversTypes['ContributorProperty'] | ResolversTypes['ContributorsProperty'] | ResolversTypes['DateProperty'] | ResolversTypes['EmailProperty'] | ResolversTypes['FloatProperty'] | ResolversTypes['IntegerProperty'] | ResolversTypes['MarkdownProperty'] | ResolversTypes['MultiselectProperty'] | ResolversTypes['SelectProperty'] | ResolversTypes['StringProperty'] | ResolversTypes['TagsProperty'] | ResolversTypes['TimestampProperty'] | ResolversTypes['UnknownProperty'];
  SchemaDefinition: ResolverTypeWrapper<SchemaDefinition>;
  SchemaDefinitionConnection: ResolverTypeWrapper<SchemaDefinitionConnection>;
  SchemaDefinitionEdge: ResolverTypeWrapper<SchemaDefinitionEdge>;
  SchemaKind: SchemaKind;
  SchemaProperty: ResolversTypes['GroupProperty'];
  SchemaValueError: ResolverTypeWrapper<SchemaValueError>;
  SchemaVersion: ResolverTypeWrapper<Omit<SchemaVersion, 'schemaProperties'> & { schemaProperties: Array<ResolversTypes['AnySchemaProperty']> }>;
  SchemaVersionConnection: ResolverTypeWrapper<SchemaVersionConnection>;
  SchemaVersionEdge: ResolverTypeWrapper<SchemaVersionEdge>;
  SchemaVersionOrder: SchemaVersionOrder;
  SelectOption: ResolverTypeWrapper<SelectOption>;
  SelectProperty: ResolverTypeWrapper<SelectProperty>;
  SimpleOrder: SimpleOrder;
  Slug: ResolverTypeWrapper<Scalars['Slug']>;
  Sluggable: ResolversTypes['AssetAudio'] | ResolversTypes['AssetDocument'] | ResolversTypes['AssetImage'] | ResolversTypes['AssetPDF'] | ResolversTypes['AssetUnknown'] | ResolversTypes['AssetVideo'] | ResolversTypes['Collection'] | ResolversTypes['CollectionContribution'] | ResolversTypes['Community'] | ResolversTypes['EntityLink'] | ResolversTypes['Item'] | ResolversTypes['ItemContribution'] | ResolversTypes['Ordering'] | ResolversTypes['OrderingEntry'] | ResolversTypes['OrganizationContributor'] | ResolversTypes['PersonContributor'] | ResolversTypes['Role'] | ResolversTypes['SchemaDefinition'] | ResolversTypes['SchemaVersion'] | ResolversTypes['User'];
  StandardMutationPayload: ResolversTypes['AlterSchemaVersionPayload'] | ResolversTypes['ApplySchemaPropertiesPayload'] | ResolversTypes['CreateAssetPayload'] | ResolversTypes['CreateCollectionPayload'] | ResolversTypes['CreateCommunityPayload'] | ResolversTypes['CreateItemPayload'] | ResolversTypes['CreateOrderingPayload'] | ResolversTypes['CreateOrganizationContributorPayload'] | ResolversTypes['CreatePersonContributorPayload'] | ResolversTypes['CreateRolePayload'] | ResolversTypes['DestroyContributionPayload'] | ResolversTypes['DestroyContributorPayload'] | ResolversTypes['DestroyOrderingPayload'] | ResolversTypes['GrantAccessPayload'] | ResolversTypes['LinkEntityPayload'] | ResolversTypes['ReparentCollectionPayload'] | ResolversTypes['ReparentItemPayload'] | ResolversTypes['ResetOrderingPayload'] | ResolversTypes['RevokeAccessPayload'] | ResolversTypes['UpdateCollectionPayload'] | ResolversTypes['UpdateCommunityPayload'] | ResolversTypes['UpdateContributionPayload'] | ResolversTypes['UpdateItemPayload'] | ResolversTypes['UpdateOrderingPayload'] | ResolversTypes['UpdateOrganizationContributorPayload'] | ResolversTypes['UpdatePersonContributorPayload'] | ResolversTypes['UpdateRolePayload'] | ResolversTypes['UpsertContributionPayload'];
  StringProperty: ResolverTypeWrapper<StringProperty>;
  TagsProperty: ResolverTypeWrapper<TagsProperty>;
  TimestampProperty: ResolverTypeWrapper<TimestampProperty>;
  TreeNodeFilter: TreeNodeFilter;
  UnknownProperty: ResolverTypeWrapper<UnknownProperty>;
  UpdateCollectionInput: UpdateCollectionInput;
  UpdateCollectionPayload: ResolverTypeWrapper<UpdateCollectionPayload>;
  UpdateCommunityInput: UpdateCommunityInput;
  UpdateCommunityPayload: ResolverTypeWrapper<UpdateCommunityPayload>;
  UpdateContributionInput: UpdateContributionInput;
  UpdateContributionPayload: ResolverTypeWrapper<Omit<UpdateContributionPayload, 'contribution'> & { contribution?: Maybe<ResolversTypes['AnyContribution']> }>;
  UpdateItemInput: UpdateItemInput;
  UpdateItemPayload: ResolverTypeWrapper<UpdateItemPayload>;
  UpdateOrderingInput: UpdateOrderingInput;
  UpdateOrderingPayload: ResolverTypeWrapper<UpdateOrderingPayload>;
  UpdateOrganizationContributorInput: UpdateOrganizationContributorInput;
  UpdateOrganizationContributorPayload: ResolverTypeWrapper<UpdateOrganizationContributorPayload>;
  UpdatePersonContributorInput: UpdatePersonContributorInput;
  UpdatePersonContributorPayload: ResolverTypeWrapper<UpdatePersonContributorPayload>;
  UpdateRoleInput: UpdateRoleInput;
  UpdateRolePayload: ResolverTypeWrapper<UpdateRolePayload>;
  UploadID: ResolverTypeWrapper<Scalars['UploadID']>;
  UploadStorage: UploadStorage;
  UploadedFileInput: UploadedFileInput;
  UploadedFileMetadataInput: UploadedFileMetadataInput;
  UpsertContributionInput: UpsertContributionInput;
  UpsertContributionPayload: ResolverTypeWrapper<Omit<UpsertContributionPayload, 'contribution'> & { contribution?: Maybe<ResolversTypes['AnyContribution']> }>;
  User: ResolverTypeWrapper<User>;
  UserConnection: ResolverTypeWrapper<UserConnection>;
  UserEdge: ResolverTypeWrapper<UserEdge>;
  UserError: ResolverTypeWrapper<UserError>;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  AccessControlList: AccessControlList;
  AlterSchemaVersionInput: AlterSchemaVersionInput;
  ID: Scalars['ID'];
  String: Scalars['String'];
  AlterSchemaVersionPayload: Omit<AlterSchemaVersionPayload, 'entity'> & { entity?: Maybe<ResolversParentTypes['AnyEntity']> };
  AnyAsset: ResolversParentTypes['AssetAudio'] | ResolversParentTypes['AssetDocument'] | ResolversParentTypes['AssetImage'] | ResolversParentTypes['AssetPDF'] | ResolversParentTypes['AssetUnknown'] | ResolversParentTypes['AssetVideo'];
  AnyAssetConnection: Omit<AnyAssetConnection, 'nodes'> & { nodes: Array<ResolversParentTypes['AnyAsset']> };
  AnyAssetEdge: Omit<AnyAssetEdge, 'node'> & { node: ResolversParentTypes['AnyAsset'] };
  AnyAttachable: ResolversParentTypes['Collection'] | ResolversParentTypes['Community'] | ResolversParentTypes['Item'];
  AnyContribution: ResolversParentTypes['CollectionContribution'] | ResolversParentTypes['ItemContribution'];
  AnyContributor: ResolversParentTypes['OrganizationContributor'] | ResolversParentTypes['PersonContributor'];
  AnyContributorConnection: Omit<AnyContributorConnection, 'nodes'> & { nodes: Array<ResolversParentTypes['AnyContributor']> };
  AnyContributorEdge: Omit<AnyContributorEdge, 'node'> & { node: ResolversParentTypes['AnyContributor'] };
  AnyEntity: ResolversParentTypes['Collection'] | ResolversParentTypes['Community'] | ResolversParentTypes['Item'];
  AnyOrderingEntry: ResolversParentTypes['Collection'] | ResolversParentTypes['Community'] | ResolversParentTypes['EntityLink'] | ResolversParentTypes['Item'];
  AnyScalarProperty: ResolversParentTypes['AssetProperty'] | ResolversParentTypes['AssetsProperty'] | ResolversParentTypes['BooleanProperty'] | ResolversParentTypes['ContributorProperty'] | ResolversParentTypes['ContributorsProperty'] | ResolversParentTypes['DateProperty'] | ResolversParentTypes['EmailProperty'] | ResolversParentTypes['FloatProperty'] | ResolversParentTypes['IntegerProperty'] | ResolversParentTypes['MarkdownProperty'] | ResolversParentTypes['MultiselectProperty'] | ResolversParentTypes['SelectProperty'] | ResolversParentTypes['StringProperty'] | ResolversParentTypes['TagsProperty'] | ResolversParentTypes['TimestampProperty'] | ResolversParentTypes['UnknownProperty'];
  AnySchemaProperty: ResolversParentTypes['AssetProperty'] | ResolversParentTypes['AssetsProperty'] | ResolversParentTypes['BooleanProperty'] | ResolversParentTypes['ContributorProperty'] | ResolversParentTypes['ContributorsProperty'] | ResolversParentTypes['DateProperty'] | ResolversParentTypes['EmailProperty'] | ResolversParentTypes['FloatProperty'] | ResolversParentTypes['GroupProperty'] | ResolversParentTypes['IntegerProperty'] | ResolversParentTypes['MarkdownProperty'] | ResolversParentTypes['MultiselectProperty'] | ResolversParentTypes['SelectProperty'] | ResolversParentTypes['StringProperty'] | ResolversParentTypes['TagsProperty'] | ResolversParentTypes['TimestampProperty'] | ResolversParentTypes['UnknownProperty'];
  ApplySchemaPropertiesInput: ApplySchemaPropertiesInput;
  ApplySchemaPropertiesPayload: Omit<ApplySchemaPropertiesPayload, 'entity'> & { entity?: Maybe<ResolversParentTypes['AnyEntity']> };
  Asset: ResolversParentTypes['AssetAudio'] | ResolversParentTypes['AssetDocument'] | ResolversParentTypes['AssetImage'] | ResolversParentTypes['AssetPDF'] | ResolversParentTypes['AssetUnknown'] | ResolversParentTypes['AssetVideo'];
  Int: Scalars['Int'];
  AssetAudio: Omit<AssetAudio, 'attachable'> & { attachable: ResolversParentTypes['AnyAttachable'] };
  AssetDocument: Omit<AssetDocument, 'attachable'> & { attachable: ResolversParentTypes['AnyAttachable'] };
  AssetImage: Omit<AssetImage, 'attachable'> & { attachable: ResolversParentTypes['AnyAttachable'] };
  AssetPDF: Omit<AssetPdf, 'attachable'> & { attachable: ResolversParentTypes['AnyAttachable'] };
  AssetPreview: AssetPreview;
  AssetProperty: Omit<AssetProperty, 'asset'> & { asset?: Maybe<ResolversParentTypes['AnyAsset']> };
  Boolean: Scalars['Boolean'];
  AssetUnknown: Omit<AssetUnknown, 'attachable'> & { attachable: ResolversParentTypes['AnyAttachable'] };
  AssetVideo: Omit<AssetVideo, 'attachable'> & { attachable: ResolversParentTypes['AnyAttachable'] };
  AssetsProperty: Omit<AssetsProperty, 'assets'> & { assets: Array<ResolversParentTypes['AnyAsset']> };
  Attachable: ResolversParentTypes['Collection'] | ResolversParentTypes['Community'] | ResolversParentTypes['Item'];
  BooleanProperty: BooleanProperty;
  Collection: Omit<Collection, 'parent' | 'schemaProperties'> & { parent?: Maybe<ResolversParentTypes['CollectionParent']>, schemaProperties: Array<ResolversParentTypes['AnySchemaProperty']> };
  CollectionConnection: CollectionConnection;
  CollectionContribution: Omit<CollectionContribution, 'contributor'> & { contributor: ResolversParentTypes['AnyContributor'] };
  CollectionContributionConnection: CollectionContributionConnection;
  CollectionContributionEdge: CollectionContributionEdge;
  CollectionEdge: CollectionEdge;
  CollectionParent: ResolversParentTypes['Collection'] | ResolversParentTypes['Community'];
  Community: Omit<Community, 'schemaProperties'> & { schemaProperties: Array<ResolversParentTypes['AnySchemaProperty']> };
  CommunityConnection: CommunityConnection;
  CommunityEdge: CommunityEdge;
  Contributable: ResolversParentTypes['Collection'] | ResolversParentTypes['Item'];
  Contribution: ResolversParentTypes['CollectionContribution'] | ResolversParentTypes['ItemContribution'];
  ContributionMetadata: ContributionMetadata;
  ContributionMetadataInput: ContributionMetadataInput;
  Contributor: ResolversParentTypes['OrganizationContributor'] | ResolversParentTypes['PersonContributor'];
  ContributorLink: ContributorLink;
  ContributorLinkInput: ContributorLinkInput;
  ContributorProperty: Omit<ContributorProperty, 'contributor'> & { contributor?: Maybe<ResolversParentTypes['AnyContributor']> };
  ContributorsProperty: Omit<ContributorsProperty, 'contributors'> & { contributors: Array<ResolversParentTypes['AnyContributor']> };
  CreateAssetInput: CreateAssetInput;
  CreateAssetPayload: Omit<CreateAssetPayload, 'asset'> & { asset?: Maybe<ResolversParentTypes['AnyAsset']> };
  CreateCollectionInput: CreateCollectionInput;
  CreateCollectionPayload: CreateCollectionPayload;
  CreateCommunityInput: CreateCommunityInput;
  CreateCommunityPayload: CreateCommunityPayload;
  CreateItemInput: CreateItemInput;
  CreateItemPayload: CreateItemPayload;
  CreateOrderingInput: CreateOrderingInput;
  CreateOrderingPayload: CreateOrderingPayload;
  CreateOrganizationContributorInput: CreateOrganizationContributorInput;
  CreateOrganizationContributorPayload: CreateOrganizationContributorPayload;
  CreatePersonContributorInput: CreatePersonContributorInput;
  CreatePersonContributorPayload: CreatePersonContributorPayload;
  CreateRoleInput: CreateRoleInput;
  CreateRolePayload: CreateRolePayload;
  DateProperty: DateProperty;
  DestroyContributionInput: DestroyContributionInput;
  DestroyContributionPayload: DestroyContributionPayload;
  DestroyContributorInput: DestroyContributorInput;
  DestroyContributorPayload: DestroyContributorPayload;
  DestroyOrderingInput: DestroyOrderingInput;
  DestroyOrderingPayload: DestroyOrderingPayload;
  EmailProperty: EmailProperty;
  Entity: ResolversParentTypes['Collection'] | ResolversParentTypes['Community'] | ResolversParentTypes['Item'];
  EntityBreadcrumb: Omit<EntityBreadcrumb, 'crumb'> & { crumb: ResolversParentTypes['AnyEntity'] };
  EntityLink: Omit<EntityLink, 'source' | 'target'> & { source: ResolversParentTypes['AnyEntity'], target: ResolversParentTypes['AnyEntity'] };
  EntityLinkConnection: EntityLinkConnection;
  EntityLinkEdge: EntityLinkEdge;
  ExposesPermissions: ResolversParentTypes['User'];
  FloatProperty: FloatProperty;
  Float: Scalars['Float'];
  GrantAccessInput: GrantAccessInput;
  GrantAccessPayload: Omit<GrantAccessPayload, 'entity'> & { entity?: Maybe<ResolversParentTypes['AnyEntity']> };
  GroupProperty: Omit<GroupProperty, 'properties'> & { properties: Array<ResolversParentTypes['AnyScalarProperty']> };
  HasSchemaProperties: ResolversParentTypes['Collection'] | ResolversParentTypes['Community'] | ResolversParentTypes['Item'] | ResolversParentTypes['SchemaVersion'];
  HierarchicalEntry: ResolversParentTypes['Collection'] | ResolversParentTypes['Item'];
  ISO8601Date: Scalars['ISO8601Date'];
  ISO8601DateTime: Scalars['ISO8601DateTime'];
  IntegerProperty: IntegerProperty;
  Item: Omit<Item, 'parent' | 'schemaProperties'> & { parent?: Maybe<ResolversParentTypes['ItemParent']>, schemaProperties: Array<ResolversParentTypes['AnySchemaProperty']> };
  ItemConnection: ItemConnection;
  ItemContribution: Omit<ItemContribution, 'contributor'> & { contributor: ResolversParentTypes['AnyContributor'] };
  ItemContributionConnection: ItemContributionConnection;
  ItemContributionEdge: ItemContributionEdge;
  ItemEdge: ItemEdge;
  ItemParent: ResolversParentTypes['Collection'] | ResolversParentTypes['Item'];
  JSON: Scalars['JSON'];
  LinkEntityInput: LinkEntityInput;
  LinkEntityPayload: LinkEntityPayload;
  MarkdownProperty: MarkdownProperty;
  MultiselectProperty: MultiselectProperty;
  Mutation: {};
  MutationAttributeError: MutationAttributeError;
  MutationGlobalError: MutationGlobalError;
  Node: ResolversParentTypes['AssetAudio'] | ResolversParentTypes['AssetDocument'] | ResolversParentTypes['AssetImage'] | ResolversParentTypes['AssetPDF'] | ResolversParentTypes['AssetUnknown'] | ResolversParentTypes['AssetVideo'] | ResolversParentTypes['Collection'] | ResolversParentTypes['CollectionContribution'] | ResolversParentTypes['Community'] | ResolversParentTypes['EntityBreadcrumb'] | ResolversParentTypes['EntityLink'] | ResolversParentTypes['Item'] | ResolversParentTypes['ItemContribution'] | ResolversParentTypes['Ordering'] | ResolversParentTypes['OrderingEntry'] | ResolversParentTypes['OrganizationContributor'] | ResolversParentTypes['PersonContributor'] | ResolversParentTypes['Role'] | ResolversParentTypes['SchemaDefinition'] | ResolversParentTypes['SchemaVersion'] | ResolversParentTypes['User'];
  OptionableProperty: ResolversParentTypes['MultiselectProperty'] | ResolversParentTypes['SelectProperty'];
  OrderDefinitionInput: OrderDefinitionInput;
  Ordering: Omit<Ordering, 'entity'> & { entity: ResolversParentTypes['AnyEntity'] };
  OrderingConnection: OrderingConnection;
  OrderingEdge: OrderingEdge;
  OrderingEntry: Omit<OrderingEntry, 'entry'> & { entry: ResolversParentTypes['AnyOrderingEntry'] };
  OrderingEntryConnection: OrderingEntryConnection;
  OrderingEntryEdge: OrderingEntryEdge;
  OrderingFilterDefinitionInput: OrderingFilterDefinitionInput;
  OrderingSelectDefinitionInput: OrderingSelectDefinitionInput;
  OrderingSelectLinkDefinitionInput: OrderingSelectLinkDefinitionInput;
  OrganizationContributor: OrganizationContributor;
  PageInfo: PageInfo;
  Paginated: ResolversParentTypes['AnyAssetConnection'] | ResolversParentTypes['AnyContributorConnection'] | ResolversParentTypes['CollectionConnection'] | ResolversParentTypes['CollectionContributionConnection'] | ResolversParentTypes['CommunityConnection'] | ResolversParentTypes['EntityLinkConnection'] | ResolversParentTypes['ItemConnection'] | ResolversParentTypes['ItemContributionConnection'] | ResolversParentTypes['OrderingConnection'] | ResolversParentTypes['OrderingEntryConnection'] | ResolversParentTypes['RoleConnection'] | ResolversParentTypes['SchemaDefinitionConnection'] | ResolversParentTypes['SchemaVersionConnection'] | ResolversParentTypes['UserConnection'];
  PermissionGrant: PermissionGrant;
  PersonContributor: PersonContributor;
  PreviewImage: PreviewImage;
  PreviewImageMap: PreviewImageMap;
  Query: {};
  ReparentCollectionInput: ReparentCollectionInput;
  ReparentCollectionPayload: ReparentCollectionPayload;
  ReparentItemInput: ReparentItemInput;
  ReparentItemPayload: ReparentItemPayload;
  ResetOrderingInput: ResetOrderingInput;
  ResetOrderingPayload: ResetOrderingPayload;
  RevokeAccessInput: RevokeAccessInput;
  RevokeAccessPayload: Omit<RevokeAccessPayload, 'entity'> & { entity?: Maybe<ResolversParentTypes['AnyEntity']> };
  Role: Role;
  RoleConnection: RoleConnection;
  RoleEdge: RoleEdge;
  ScalarProperty: ResolversParentTypes['AssetProperty'] | ResolversParentTypes['AssetsProperty'] | ResolversParentTypes['BooleanProperty'] | ResolversParentTypes['ContributorProperty'] | ResolversParentTypes['ContributorsProperty'] | ResolversParentTypes['DateProperty'] | ResolversParentTypes['EmailProperty'] | ResolversParentTypes['FloatProperty'] | ResolversParentTypes['IntegerProperty'] | ResolversParentTypes['MarkdownProperty'] | ResolversParentTypes['MultiselectProperty'] | ResolversParentTypes['SelectProperty'] | ResolversParentTypes['StringProperty'] | ResolversParentTypes['TagsProperty'] | ResolversParentTypes['TimestampProperty'] | ResolversParentTypes['UnknownProperty'];
  SchemaDefinition: SchemaDefinition;
  SchemaDefinitionConnection: SchemaDefinitionConnection;
  SchemaDefinitionEdge: SchemaDefinitionEdge;
  SchemaProperty: ResolversParentTypes['GroupProperty'];
  SchemaValueError: SchemaValueError;
  SchemaVersion: Omit<SchemaVersion, 'schemaProperties'> & { schemaProperties: Array<ResolversParentTypes['AnySchemaProperty']> };
  SchemaVersionConnection: SchemaVersionConnection;
  SchemaVersionEdge: SchemaVersionEdge;
  SelectOption: SelectOption;
  SelectProperty: SelectProperty;
  Slug: Scalars['Slug'];
  Sluggable: ResolversParentTypes['AssetAudio'] | ResolversParentTypes['AssetDocument'] | ResolversParentTypes['AssetImage'] | ResolversParentTypes['AssetPDF'] | ResolversParentTypes['AssetUnknown'] | ResolversParentTypes['AssetVideo'] | ResolversParentTypes['Collection'] | ResolversParentTypes['CollectionContribution'] | ResolversParentTypes['Community'] | ResolversParentTypes['EntityLink'] | ResolversParentTypes['Item'] | ResolversParentTypes['ItemContribution'] | ResolversParentTypes['Ordering'] | ResolversParentTypes['OrderingEntry'] | ResolversParentTypes['OrganizationContributor'] | ResolversParentTypes['PersonContributor'] | ResolversParentTypes['Role'] | ResolversParentTypes['SchemaDefinition'] | ResolversParentTypes['SchemaVersion'] | ResolversParentTypes['User'];
  StandardMutationPayload: ResolversParentTypes['AlterSchemaVersionPayload'] | ResolversParentTypes['ApplySchemaPropertiesPayload'] | ResolversParentTypes['CreateAssetPayload'] | ResolversParentTypes['CreateCollectionPayload'] | ResolversParentTypes['CreateCommunityPayload'] | ResolversParentTypes['CreateItemPayload'] | ResolversParentTypes['CreateOrderingPayload'] | ResolversParentTypes['CreateOrganizationContributorPayload'] | ResolversParentTypes['CreatePersonContributorPayload'] | ResolversParentTypes['CreateRolePayload'] | ResolversParentTypes['DestroyContributionPayload'] | ResolversParentTypes['DestroyContributorPayload'] | ResolversParentTypes['DestroyOrderingPayload'] | ResolversParentTypes['GrantAccessPayload'] | ResolversParentTypes['LinkEntityPayload'] | ResolversParentTypes['ReparentCollectionPayload'] | ResolversParentTypes['ReparentItemPayload'] | ResolversParentTypes['ResetOrderingPayload'] | ResolversParentTypes['RevokeAccessPayload'] | ResolversParentTypes['UpdateCollectionPayload'] | ResolversParentTypes['UpdateCommunityPayload'] | ResolversParentTypes['UpdateContributionPayload'] | ResolversParentTypes['UpdateItemPayload'] | ResolversParentTypes['UpdateOrderingPayload'] | ResolversParentTypes['UpdateOrganizationContributorPayload'] | ResolversParentTypes['UpdatePersonContributorPayload'] | ResolversParentTypes['UpdateRolePayload'] | ResolversParentTypes['UpsertContributionPayload'];
  StringProperty: StringProperty;
  TagsProperty: TagsProperty;
  TimestampProperty: TimestampProperty;
  UnknownProperty: UnknownProperty;
  UpdateCollectionInput: UpdateCollectionInput;
  UpdateCollectionPayload: UpdateCollectionPayload;
  UpdateCommunityInput: UpdateCommunityInput;
  UpdateCommunityPayload: UpdateCommunityPayload;
  UpdateContributionInput: UpdateContributionInput;
  UpdateContributionPayload: Omit<UpdateContributionPayload, 'contribution'> & { contribution?: Maybe<ResolversParentTypes['AnyContribution']> };
  UpdateItemInput: UpdateItemInput;
  UpdateItemPayload: UpdateItemPayload;
  UpdateOrderingInput: UpdateOrderingInput;
  UpdateOrderingPayload: UpdateOrderingPayload;
  UpdateOrganizationContributorInput: UpdateOrganizationContributorInput;
  UpdateOrganizationContributorPayload: UpdateOrganizationContributorPayload;
  UpdatePersonContributorInput: UpdatePersonContributorInput;
  UpdatePersonContributorPayload: UpdatePersonContributorPayload;
  UpdateRoleInput: UpdateRoleInput;
  UpdateRolePayload: UpdateRolePayload;
  UploadID: Scalars['UploadID'];
  UploadedFileInput: UploadedFileInput;
  UploadedFileMetadataInput: UploadedFileMetadataInput;
  UpsertContributionInput: UpsertContributionInput;
  UpsertContributionPayload: Omit<UpsertContributionPayload, 'contribution'> & { contribution?: Maybe<ResolversParentTypes['AnyContribution']> };
  User: User;
  UserConnection: UserConnection;
  UserEdge: UserEdge;
  UserError: UserError;
};

export type AccessControlListResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccessControlList'] = ResolversParentTypes['AccessControlList']> = {
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AlterSchemaVersionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['AlterSchemaVersionPayload'] = ResolversParentTypes['AlterSchemaVersionPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  community?: Resolver<Maybe<ResolversTypes['Community']>, ParentType, ContextType>;
  entity?: Resolver<Maybe<ResolversTypes['AnyEntity']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['Item']>, ParentType, ContextType>;
  schemaErrors?: Resolver<Array<ResolversTypes['SchemaValueError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyAssetResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyAsset'] = ResolversParentTypes['AnyAsset']> = {
  __resolveType: TypeResolveFn<'AssetAudio' | 'AssetDocument' | 'AssetImage' | 'AssetPDF' | 'AssetUnknown' | 'AssetVideo', ParentType, ContextType>;
};

export type AnyAssetConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyAssetConnection'] = ResolversParentTypes['AnyAssetConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AnyAssetEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['AnyAsset']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyAssetEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyAssetEdge'] = ResolversParentTypes['AnyAssetEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['AnyAsset'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyAttachableResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyAttachable'] = ResolversParentTypes['AnyAttachable']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Community' | 'Item', ParentType, ContextType>;
};

export type AnyContributionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyContribution'] = ResolversParentTypes['AnyContribution']> = {
  __resolveType: TypeResolveFn<'CollectionContribution' | 'ItemContribution', ParentType, ContextType>;
};

export type AnyContributorResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyContributor'] = ResolversParentTypes['AnyContributor']> = {
  __resolveType: TypeResolveFn<'OrganizationContributor' | 'PersonContributor', ParentType, ContextType>;
};

export type AnyContributorConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyContributorConnection'] = ResolversParentTypes['AnyContributorConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AnyContributorEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['AnyContributor']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyContributorEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyContributorEdge'] = ResolversParentTypes['AnyContributorEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['AnyContributor'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AnyEntityResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyEntity'] = ResolversParentTypes['AnyEntity']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Community' | 'Item', ParentType, ContextType>;
};

export type AnyOrderingEntryResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyOrderingEntry'] = ResolversParentTypes['AnyOrderingEntry']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Community' | 'EntityLink' | 'Item', ParentType, ContextType>;
};

export type AnyScalarPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnyScalarProperty'] = ResolversParentTypes['AnyScalarProperty']> = {
  __resolveType: TypeResolveFn<'AssetProperty' | 'AssetsProperty' | 'BooleanProperty' | 'ContributorProperty' | 'ContributorsProperty' | 'DateProperty' | 'EmailProperty' | 'FloatProperty' | 'IntegerProperty' | 'MarkdownProperty' | 'MultiselectProperty' | 'SelectProperty' | 'StringProperty' | 'TagsProperty' | 'TimestampProperty' | 'UnknownProperty', ParentType, ContextType>;
};

export type AnySchemaPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['AnySchemaProperty'] = ResolversParentTypes['AnySchemaProperty']> = {
  __resolveType: TypeResolveFn<'AssetProperty' | 'AssetsProperty' | 'BooleanProperty' | 'ContributorProperty' | 'ContributorsProperty' | 'DateProperty' | 'EmailProperty' | 'FloatProperty' | 'GroupProperty' | 'IntegerProperty' | 'MarkdownProperty' | 'MultiselectProperty' | 'SelectProperty' | 'StringProperty' | 'TagsProperty' | 'TimestampProperty' | 'UnknownProperty', ParentType, ContextType>;
};

export type ApplySchemaPropertiesPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplySchemaPropertiesPayload'] = ResolversParentTypes['ApplySchemaPropertiesPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  community?: Resolver<Maybe<ResolversTypes['Community']>, ParentType, ContextType>;
  entity?: Resolver<Maybe<ResolversTypes['AnyEntity']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['Item']>, ParentType, ContextType>;
  schemaErrors?: Resolver<Array<ResolversTypes['SchemaValueError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetResolvers<ContextType = any, ParentType extends ResolversParentTypes['Asset'] = ResolversParentTypes['Asset']> = {
  __resolveType: TypeResolveFn<'AssetAudio' | 'AssetDocument' | 'AssetImage' | 'AssetPDF' | 'AssetUnknown' | 'AssetVideo', ParentType, ContextType>;
  attachable?: Resolver<ResolversTypes['AnyAttachable'], ParentType, ContextType>;
  caption?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  downloadUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['AssetKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preview?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
};

export type AssetAudioResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetAudio'] = ResolversParentTypes['AssetAudio']> = {
  attachable?: Resolver<ResolversTypes['AnyAttachable'], ParentType, ContextType>;
  caption?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  downloadUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['AssetKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preview?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetDocumentResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetDocument'] = ResolversParentTypes['AssetDocument']> = {
  attachable?: Resolver<ResolversTypes['AnyAttachable'], ParentType, ContextType>;
  caption?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  downloadUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['AssetKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preview?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetImageResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetImage'] = ResolversParentTypes['AssetImage']> = {
  attachable?: Resolver<ResolversTypes['AnyAttachable'], ParentType, ContextType>;
  caption?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  downloadUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['AssetKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preview?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetPdfResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetPDF'] = ResolversParentTypes['AssetPDF']> = {
  attachable?: Resolver<ResolversTypes['AnyAttachable'], ParentType, ContextType>;
  caption?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  downloadUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['AssetKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preview?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetPreviewResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetPreview'] = ResolversParentTypes['AssetPreview']> = {
  alt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  large?: Resolver<ResolversTypes['PreviewImageMap'], ParentType, ContextType>;
  medium?: Resolver<ResolversTypes['PreviewImageMap'], ParentType, ContextType>;
  small?: Resolver<ResolversTypes['PreviewImageMap'], ParentType, ContextType>;
  thumb?: Resolver<ResolversTypes['PreviewImageMap'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetProperty'] = ResolversParentTypes['AssetProperty']> = {
  asset?: Resolver<Maybe<ResolversTypes['AnyAsset']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetUnknownResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetUnknown'] = ResolversParentTypes['AssetUnknown']> = {
  attachable?: Resolver<ResolversTypes['AnyAttachable'], ParentType, ContextType>;
  caption?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  downloadUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['AssetKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preview?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetVideoResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetVideo'] = ResolversParentTypes['AssetVideo']> = {
  attachable?: Resolver<ResolversTypes['AnyAttachable'], ParentType, ContextType>;
  caption?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  downloadUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['AssetKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preview?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetsPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetsProperty'] = ResolversParentTypes['AssetsProperty']> = {
  assets?: Resolver<Array<ResolversTypes['AnyAsset']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttachableResolvers<ContextType = any, ParentType extends ResolversParentTypes['Attachable'] = ResolversParentTypes['Attachable']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Community' | 'Item', ParentType, ContextType>;
  assets?: Resolver<ResolversTypes['AnyAssetConnection'], ParentType, ContextType, RequireFields<AttachableAssetsArgs, 'order' | 'kind' | 'pageDirection' | 'perPage'>>;
};

export type BooleanPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['BooleanProperty'] = ResolversParentTypes['BooleanProperty']> = {
  checked?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  checkedByDefault?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Collection'] = ResolversParentTypes['Collection']> = {
  accessControlList?: Resolver<Maybe<ResolversTypes['AccessControlList']>, ParentType, ContextType>;
  allowedActions?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  applicableRoles?: Resolver<Maybe<Array<ResolversTypes['Role']>>, ParentType, ContextType>;
  assets?: Resolver<ResolversTypes['AnyAssetConnection'], ParentType, ContextType, RequireFields<CollectionAssetsArgs, 'order' | 'kind' | 'pageDirection' | 'perPage'>>;
  breadcrumbs?: Resolver<Array<ResolversTypes['EntityBreadcrumb']>, ParentType, ContextType>;
  children?: Resolver<ResolversTypes['CollectionConnection'], ParentType, ContextType, RequireFields<CollectionChildrenArgs, never>>;
  collections?: Resolver<ResolversTypes['CollectionConnection'], ParentType, ContextType, RequireFields<CollectionCollectionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  community?: Resolver<ResolversTypes['Community'], ParentType, ContextType>;
  contributions?: Resolver<ResolversTypes['CollectionContributionConnection'], ParentType, ContextType, RequireFields<CollectionContributionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  contributors?: Resolver<ResolversTypes['AnyContributorConnection'], ParentType, ContextType, RequireFields<CollectionContributorsArgs, 'order' | 'kind' | 'pageDirection' | 'perPage'>>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  doi?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hierarchicalDepth?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  items?: Resolver<ResolversTypes['ItemConnection'], ParentType, ContextType, RequireFields<CollectionItemsArgs, 'order' | 'nodeFilter' | 'pageDirection' | 'perPage'>>;
  leaf?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  links?: Resolver<ResolversTypes['EntityLinkConnection'], ParentType, ContextType, RequireFields<CollectionLinksArgs, 'order' | 'pageDirection' | 'perPage'>>;
  ordering?: Resolver<Maybe<ResolversTypes['Ordering']>, ParentType, ContextType, RequireFields<CollectionOrderingArgs, 'identifier'>>;
  orderings?: Resolver<ResolversTypes['OrderingConnection'], ParentType, ContextType, RequireFields<CollectionOrderingsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  parent?: Resolver<Maybe<ResolversTypes['CollectionParent']>, ParentType, ContextType>;
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
  publishedOn?: Resolver<Maybe<ResolversTypes['ISO8601Date']>, ParentType, ContextType>;
  root?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  schemaDefinition?: Resolver<ResolversTypes['SchemaDefinition'], ParentType, ContextType>;
  schemaProperties?: Resolver<Array<ResolversTypes['AnySchemaProperty']>, ParentType, ContextType>;
  schemaVersion?: Resolver<ResolversTypes['SchemaVersion'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  summary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  thumbnail?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  visibleAfterAt?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionConnection'] = ResolversParentTypes['CollectionConnection']> = {
  edges?: Resolver<Array<ResolversTypes['CollectionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['Collection']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionContributionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionContribution'] = ResolversParentTypes['CollectionContribution']> = {
  affiliation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collection?: Resolver<ResolversTypes['Collection'], ParentType, ContextType>;
  contributor?: Resolver<ResolversTypes['AnyContributor'], ParentType, ContextType>;
  contributorKind?: Resolver<ResolversTypes['ContributorKind'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  displayName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metadata?: Resolver<ResolversTypes['ContributionMetadata'], ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionContributionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionContributionConnection'] = ResolversParentTypes['CollectionContributionConnection']> = {
  edges?: Resolver<Array<ResolversTypes['CollectionContributionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['CollectionContribution']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionContributionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionContributionEdge'] = ResolversParentTypes['CollectionContributionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['CollectionContribution'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionEdge'] = ResolversParentTypes['CollectionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Collection'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionParentResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionParent'] = ResolversParentTypes['CollectionParent']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Community', ParentType, ContextType>;
};

export type CommunityResolvers<ContextType = any, ParentType extends ResolversParentTypes['Community'] = ResolversParentTypes['Community']> = {
  accessControlList?: Resolver<Maybe<ResolversTypes['AccessControlList']>, ParentType, ContextType>;
  allowedActions?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  applicableRoles?: Resolver<Maybe<Array<ResolversTypes['Role']>>, ParentType, ContextType>;
  assets?: Resolver<ResolversTypes['AnyAssetConnection'], ParentType, ContextType, RequireFields<CommunityAssetsArgs, 'order' | 'kind' | 'pageDirection' | 'perPage'>>;
  breadcrumbs?: Resolver<Array<ResolversTypes['EntityBreadcrumb']>, ParentType, ContextType>;
  collections?: Resolver<ResolversTypes['CollectionConnection'], ParentType, ContextType, RequireFields<CommunityCollectionsArgs, 'order' | 'nodeFilter' | 'pageDirection' | 'perPage'>>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  hierarchicalDepth?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  links?: Resolver<ResolversTypes['EntityLinkConnection'], ParentType, ContextType, RequireFields<CommunityLinksArgs, 'order' | 'pageDirection' | 'perPage'>>;
  metadata?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  ordering?: Resolver<Maybe<ResolversTypes['Ordering']>, ParentType, ContextType, RequireFields<CommunityOrderingArgs, 'identifier'>>;
  orderings?: Resolver<ResolversTypes['OrderingConnection'], ParentType, ContextType, RequireFields<CommunityOrderingsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
  position?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  schemaDefinition?: Resolver<ResolversTypes['SchemaDefinition'], ParentType, ContextType>;
  schemaProperties?: Resolver<Array<ResolversTypes['AnySchemaProperty']>, ParentType, ContextType>;
  schemaVersion?: Resolver<ResolversTypes['SchemaVersion'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  thumbnail?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommunityConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CommunityConnection'] = ResolversParentTypes['CommunityConnection']> = {
  edges?: Resolver<Array<ResolversTypes['CommunityEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['Community']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommunityEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CommunityEdge'] = ResolversParentTypes['CommunityEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Community'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContributableResolvers<ContextType = any, ParentType extends ResolversParentTypes['Contributable'] = ResolversParentTypes['Contributable']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Item', ParentType, ContextType>;
  contributors?: Resolver<ResolversTypes['AnyContributorConnection'], ParentType, ContextType, RequireFields<ContributableContributorsArgs, 'order' | 'kind' | 'pageDirection' | 'perPage'>>;
};

export type ContributionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Contribution'] = ResolversParentTypes['Contribution']> = {
  __resolveType: TypeResolveFn<'CollectionContribution' | 'ItemContribution', ParentType, ContextType>;
  affiliation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contributor?: Resolver<ResolversTypes['AnyContributor'], ParentType, ContextType>;
  contributorKind?: Resolver<ResolversTypes['ContributorKind'], ParentType, ContextType>;
  displayName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metadata?: Resolver<ResolversTypes['ContributionMetadata'], ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
};

export type ContributionMetadataResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContributionMetadata'] = ResolversParentTypes['ContributionMetadata']> = {
  affiliation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  displayName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContributorResolvers<ContextType = any, ParentType extends ResolversParentTypes['Contributor'] = ResolversParentTypes['Contributor']> = {
  __resolveType: TypeResolveFn<'OrganizationContributor' | 'PersonContributor', ParentType, ContextType>;
  bio?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collectionContributions?: Resolver<ResolversTypes['CollectionContributionConnection'], ParentType, ContextType, RequireFields<ContributorCollectionContributionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  itemContributions?: Resolver<ResolversTypes['ItemContributionConnection'], ParentType, ContextType, RequireFields<ContributorItemContributionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  kind?: Resolver<ResolversTypes['ContributorKind'], ParentType, ContextType>;
  links?: Resolver<Array<Maybe<ResolversTypes['ContributorLink']>>, ParentType, ContextType>;
  prefix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  suffix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
};

export type ContributorLinkResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContributorLink'] = ResolversParentTypes['ContributorLink']> = {
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContributorPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContributorProperty'] = ResolversParentTypes['ContributorProperty']> = {
  contributor?: Resolver<Maybe<ResolversTypes['AnyContributor']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContributorsPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContributorsProperty'] = ResolversParentTypes['ContributorsProperty']> = {
  contributors?: Resolver<Array<ResolversTypes['AnyContributor']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateAssetPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateAssetPayload'] = ResolversParentTypes['CreateAssetPayload']> = {
  asset?: Resolver<Maybe<ResolversTypes['AnyAsset']>, ParentType, ContextType>;
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateCollectionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateCollectionPayload'] = ResolversParentTypes['CreateCollectionPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateCommunityPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateCommunityPayload'] = ResolversParentTypes['CreateCommunityPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  community?: Resolver<Maybe<ResolversTypes['Community']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateItemPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateItemPayload'] = ResolversParentTypes['CreateItemPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateOrderingPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateOrderingPayload'] = ResolversParentTypes['CreateOrderingPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ordering?: Resolver<Maybe<ResolversTypes['Ordering']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateOrganizationContributorPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateOrganizationContributorPayload'] = ResolversParentTypes['CreateOrganizationContributorPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contributor?: Resolver<Maybe<ResolversTypes['OrganizationContributor']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatePersonContributorPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreatePersonContributorPayload'] = ResolversParentTypes['CreatePersonContributorPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contributor?: Resolver<Maybe<ResolversTypes['PersonContributor']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateRolePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateRolePayload'] = ResolversParentTypes['CreateRolePayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DatePropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['DateProperty'] = ResolversParentTypes['DateProperty']> = {
  date?: Resolver<Maybe<ResolversTypes['ISO8601Date']>, ParentType, ContextType>;
  default?: Resolver<Maybe<ResolversTypes['ISO8601Date']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestroyContributionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DestroyContributionPayload'] = ResolversParentTypes['DestroyContributionPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  destroyed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestroyContributorPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DestroyContributorPayload'] = ResolversParentTypes['DestroyContributorPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  destroyed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestroyOrderingPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DestroyOrderingPayload'] = ResolversParentTypes['DestroyOrderingPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  destroyed?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  disabled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EmailPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['EmailProperty'] = ResolversParentTypes['EmailProperty']> = {
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EntityResolvers<ContextType = any, ParentType extends ResolversParentTypes['Entity'] = ResolversParentTypes['Entity']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Community' | 'Item', ParentType, ContextType>;
  accessControlList?: Resolver<Maybe<ResolversTypes['AccessControlList']>, ParentType, ContextType>;
  allowedActions?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  applicableRoles?: Resolver<Maybe<Array<ResolversTypes['Role']>>, ParentType, ContextType>;
  breadcrumbs?: Resolver<Array<ResolversTypes['EntityBreadcrumb']>, ParentType, ContextType>;
  hierarchicalDepth?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  links?: Resolver<ResolversTypes['EntityLinkConnection'], ParentType, ContextType, RequireFields<EntityLinksArgs, 'order' | 'pageDirection' | 'perPage'>>;
  ordering?: Resolver<Maybe<ResolversTypes['Ordering']>, ParentType, ContextType, RequireFields<EntityOrderingArgs, 'identifier'>>;
  orderings?: Resolver<ResolversTypes['OrderingConnection'], ParentType, ContextType, RequireFields<EntityOrderingsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
  schemaDefinition?: Resolver<ResolversTypes['SchemaDefinition'], ParentType, ContextType>;
  schemaProperties?: Resolver<Array<ResolversTypes['AnySchemaProperty']>, ParentType, ContextType>;
  schemaVersion?: Resolver<ResolversTypes['SchemaVersion'], ParentType, ContextType>;
  thumbnail?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
};

export type EntityBreadcrumbResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntityBreadcrumb'] = ResolversParentTypes['EntityBreadcrumb']> = {
  crumb?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  depth?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['EntityKind'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EntityLinkResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntityLink'] = ResolversParentTypes['EntityLink']> = {
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  operator?: Resolver<ResolversTypes['EntityLinkOperator'], ParentType, ContextType>;
  scope?: Resolver<ResolversTypes['EntityLinkScope'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  sourceCollection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  sourceCommunity?: Resolver<Maybe<ResolversTypes['Community']>, ParentType, ContextType>;
  sourceItem?: Resolver<Maybe<ResolversTypes['Item']>, ParentType, ContextType>;
  target?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  targetCollection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  targetCommunity?: Resolver<Maybe<ResolversTypes['Community']>, ParentType, ContextType>;
  targetItem?: Resolver<Maybe<ResolversTypes['Item']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EntityLinkConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntityLinkConnection'] = ResolversParentTypes['EntityLinkConnection']> = {
  edges?: Resolver<Array<ResolversTypes['EntityLinkEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['EntityLink']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EntityLinkEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EntityLinkEdge'] = ResolversParentTypes['EntityLinkEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['EntityLink'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExposesPermissionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExposesPermissions'] = ResolversParentTypes['ExposesPermissions']> = {
  __resolveType: TypeResolveFn<'User', ParentType, ContextType>;
  allowedActions?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
};

export type FloatPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['FloatProperty'] = ResolversParentTypes['FloatProperty']> = {
  defaultFloat?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  floatValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GrantAccessPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['GrantAccessPayload'] = ResolversParentTypes['GrantAccessPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entity?: Resolver<Maybe<ResolversTypes['AnyEntity']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  granted?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupProperty'] = ResolversParentTypes['GroupProperty']> = {
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  legend?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  properties?: Resolver<Array<ResolversTypes['AnyScalarProperty']>, ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HasSchemaPropertiesResolvers<ContextType = any, ParentType extends ResolversParentTypes['HasSchemaProperties'] = ResolversParentTypes['HasSchemaProperties']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Community' | 'Item' | 'SchemaVersion', ParentType, ContextType>;
  schemaProperties?: Resolver<Array<ResolversTypes['AnySchemaProperty']>, ParentType, ContextType>;
};

export type HierarchicalEntryResolvers<ContextType = any, ParentType extends ResolversParentTypes['HierarchicalEntry'] = ResolversParentTypes['HierarchicalEntry']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Item', ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  doi?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  leaf?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  publishedOn?: Resolver<Maybe<ResolversTypes['ISO8601Date']>, ParentType, ContextType>;
  root?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  summary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  visibleAfterAt?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
};

export interface Iso8601DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ISO8601Date'], any> {
  name: 'ISO8601Date';
}

export interface Iso8601DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ISO8601DateTime'], any> {
  name: 'ISO8601DateTime';
}

export type IntegerPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['IntegerProperty'] = ResolversParentTypes['IntegerProperty']> = {
  defaultInteger?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  integerValue?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemResolvers<ContextType = any, ParentType extends ResolversParentTypes['Item'] = ResolversParentTypes['Item']> = {
  accessControlList?: Resolver<Maybe<ResolversTypes['AccessControlList']>, ParentType, ContextType>;
  allowedActions?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  applicableRoles?: Resolver<Maybe<Array<ResolversTypes['Role']>>, ParentType, ContextType>;
  assets?: Resolver<ResolversTypes['AnyAssetConnection'], ParentType, ContextType, RequireFields<ItemAssetsArgs, 'order' | 'kind' | 'pageDirection' | 'perPage'>>;
  breadcrumbs?: Resolver<Array<ResolversTypes['EntityBreadcrumb']>, ParentType, ContextType>;
  children?: Resolver<ResolversTypes['ItemConnection'], ParentType, ContextType, RequireFields<ItemChildrenArgs, never>>;
  collection?: Resolver<ResolversTypes['Collection'], ParentType, ContextType>;
  community?: Resolver<ResolversTypes['Community'], ParentType, ContextType>;
  contributions?: Resolver<ResolversTypes['ItemContributionConnection'], ParentType, ContextType, RequireFields<ItemContributionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  contributors?: Resolver<ResolversTypes['AnyContributorConnection'], ParentType, ContextType, RequireFields<ItemContributorsArgs, 'order' | 'kind' | 'pageDirection' | 'perPage'>>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  doi?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hierarchicalDepth?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  items?: Resolver<ResolversTypes['ItemConnection'], ParentType, ContextType, RequireFields<ItemItemsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  leaf?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  links?: Resolver<ResolversTypes['EntityLinkConnection'], ParentType, ContextType, RequireFields<ItemLinksArgs, 'order' | 'pageDirection' | 'perPage'>>;
  ordering?: Resolver<Maybe<ResolversTypes['Ordering']>, ParentType, ContextType, RequireFields<ItemOrderingArgs, 'identifier'>>;
  orderings?: Resolver<ResolversTypes['OrderingConnection'], ParentType, ContextType, RequireFields<ItemOrderingsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  parent?: Resolver<Maybe<ResolversTypes['ItemParent']>, ParentType, ContextType>;
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
  publishedOn?: Resolver<Maybe<ResolversTypes['ISO8601Date']>, ParentType, ContextType>;
  root?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  schemaDefinition?: Resolver<ResolversTypes['SchemaDefinition'], ParentType, ContextType>;
  schemaProperties?: Resolver<Array<ResolversTypes['AnySchemaProperty']>, ParentType, ContextType>;
  schemaVersion?: Resolver<ResolversTypes['SchemaVersion'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  summary?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  thumbnail?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  visibleAfterAt?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ItemConnection'] = ResolversParentTypes['ItemConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ItemEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['Item']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemContributionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ItemContribution'] = ResolversParentTypes['ItemContribution']> = {
  affiliation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contributor?: Resolver<ResolversTypes['AnyContributor'], ParentType, ContextType>;
  contributorKind?: Resolver<ResolversTypes['ContributorKind'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  displayName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  item?: Resolver<ResolversTypes['Item'], ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metadata?: Resolver<ResolversTypes['ContributionMetadata'], ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemContributionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ItemContributionConnection'] = ResolversParentTypes['ItemContributionConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ItemContributionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['ItemContribution']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemContributionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ItemContributionEdge'] = ResolversParentTypes['ItemContributionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ItemContribution'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ItemEdge'] = ResolversParentTypes['ItemEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Item'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemParentResolvers<ContextType = any, ParentType extends ResolversParentTypes['ItemParent'] = ResolversParentTypes['ItemParent']> = {
  __resolveType: TypeResolveFn<'Collection' | 'Item', ParentType, ContextType>;
};

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
  name: 'JSON';
}

export type LinkEntityPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['LinkEntityPayload'] = ResolversParentTypes['LinkEntityPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  link?: Resolver<Maybe<ResolversTypes['EntityLink']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarkdownPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['MarkdownProperty'] = ResolversParentTypes['MarkdownProperty']> = {
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  default?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MultiselectPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['MultiselectProperty'] = ResolversParentTypes['MultiselectProperty']> = {
  defaultSelections?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  options?: Resolver<Array<ResolversTypes['SelectOption']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  selections?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {
  alterSchemaVersion?: Resolver<Maybe<ResolversTypes['AlterSchemaVersionPayload']>, ParentType, ContextType, RequireFields<MutationAlterSchemaVersionArgs, 'input'>>;
  applySchemaProperties?: Resolver<Maybe<ResolversTypes['ApplySchemaPropertiesPayload']>, ParentType, ContextType, RequireFields<MutationApplySchemaPropertiesArgs, 'input'>>;
  createAsset?: Resolver<Maybe<ResolversTypes['CreateAssetPayload']>, ParentType, ContextType, RequireFields<MutationCreateAssetArgs, 'input'>>;
  createCollection?: Resolver<Maybe<ResolversTypes['CreateCollectionPayload']>, ParentType, ContextType, RequireFields<MutationCreateCollectionArgs, 'input'>>;
  createCommunity?: Resolver<Maybe<ResolversTypes['CreateCommunityPayload']>, ParentType, ContextType, RequireFields<MutationCreateCommunityArgs, 'input'>>;
  createItem?: Resolver<Maybe<ResolversTypes['CreateItemPayload']>, ParentType, ContextType, RequireFields<MutationCreateItemArgs, 'input'>>;
  createOrdering?: Resolver<Maybe<ResolversTypes['CreateOrderingPayload']>, ParentType, ContextType, RequireFields<MutationCreateOrderingArgs, 'input'>>;
  createOrganizationContributor?: Resolver<Maybe<ResolversTypes['CreateOrganizationContributorPayload']>, ParentType, ContextType, RequireFields<MutationCreateOrganizationContributorArgs, 'input'>>;
  createPersonContributor?: Resolver<Maybe<ResolversTypes['CreatePersonContributorPayload']>, ParentType, ContextType, RequireFields<MutationCreatePersonContributorArgs, 'input'>>;
  createRole?: Resolver<Maybe<ResolversTypes['CreateRolePayload']>, ParentType, ContextType, RequireFields<MutationCreateRoleArgs, 'input'>>;
  destroyContribution?: Resolver<Maybe<ResolversTypes['DestroyContributionPayload']>, ParentType, ContextType, RequireFields<MutationDestroyContributionArgs, 'input'>>;
  destroyContributor?: Resolver<Maybe<ResolversTypes['DestroyContributorPayload']>, ParentType, ContextType, RequireFields<MutationDestroyContributorArgs, 'input'>>;
  destroyOrdering?: Resolver<Maybe<ResolversTypes['DestroyOrderingPayload']>, ParentType, ContextType, RequireFields<MutationDestroyOrderingArgs, 'input'>>;
  grantAccess?: Resolver<Maybe<ResolversTypes['GrantAccessPayload']>, ParentType, ContextType, RequireFields<MutationGrantAccessArgs, 'input'>>;
  linkEntity?: Resolver<Maybe<ResolversTypes['LinkEntityPayload']>, ParentType, ContextType, RequireFields<MutationLinkEntityArgs, 'input'>>;
  reparentCollection?: Resolver<Maybe<ResolversTypes['ReparentCollectionPayload']>, ParentType, ContextType, RequireFields<MutationReparentCollectionArgs, 'input'>>;
  reparentItem?: Resolver<Maybe<ResolversTypes['ReparentItemPayload']>, ParentType, ContextType, RequireFields<MutationReparentItemArgs, 'input'>>;
  resetOrdering?: Resolver<Maybe<ResolversTypes['ResetOrderingPayload']>, ParentType, ContextType, RequireFields<MutationResetOrderingArgs, 'input'>>;
  revokeAccess?: Resolver<Maybe<ResolversTypes['RevokeAccessPayload']>, ParentType, ContextType, RequireFields<MutationRevokeAccessArgs, 'input'>>;
  updateCollection?: Resolver<Maybe<ResolversTypes['UpdateCollectionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateCollectionArgs, 'input'>>;
  updateCommunity?: Resolver<Maybe<ResolversTypes['UpdateCommunityPayload']>, ParentType, ContextType, RequireFields<MutationUpdateCommunityArgs, 'input'>>;
  updateContribution?: Resolver<Maybe<ResolversTypes['UpdateContributionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateContributionArgs, 'input'>>;
  updateItem?: Resolver<Maybe<ResolversTypes['UpdateItemPayload']>, ParentType, ContextType, RequireFields<MutationUpdateItemArgs, 'input'>>;
  updateOrdering?: Resolver<Maybe<ResolversTypes['UpdateOrderingPayload']>, ParentType, ContextType, RequireFields<MutationUpdateOrderingArgs, 'input'>>;
  updateOrganizationContributor?: Resolver<Maybe<ResolversTypes['UpdateOrganizationContributorPayload']>, ParentType, ContextType, RequireFields<MutationUpdateOrganizationContributorArgs, 'input'>>;
  updatePersonContributor?: Resolver<Maybe<ResolversTypes['UpdatePersonContributorPayload']>, ParentType, ContextType, RequireFields<MutationUpdatePersonContributorArgs, 'input'>>;
  updateRole?: Resolver<Maybe<ResolversTypes['UpdateRolePayload']>, ParentType, ContextType, RequireFields<MutationUpdateRoleArgs, 'input'>>;
  upsertContribution?: Resolver<Maybe<ResolversTypes['UpsertContributionPayload']>, ParentType, ContextType, RequireFields<MutationUpsertContributionArgs, 'input'>>;
};

export type MutationAttributeErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['MutationAttributeError'] = ResolversParentTypes['MutationAttributeError']> = {
  messages?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutationGlobalErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['MutationGlobalError'] = ResolversParentTypes['MutationGlobalError']> = {
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {
  __resolveType: TypeResolveFn<'AssetAudio' | 'AssetDocument' | 'AssetImage' | 'AssetPDF' | 'AssetUnknown' | 'AssetVideo' | 'Collection' | 'CollectionContribution' | 'Community' | 'EntityBreadcrumb' | 'EntityLink' | 'Item' | 'ItemContribution' | 'Ordering' | 'OrderingEntry' | 'OrganizationContributor' | 'PersonContributor' | 'Role' | 'SchemaDefinition' | 'SchemaVersion' | 'User', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
};

export type OptionablePropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['OptionableProperty'] = ResolversParentTypes['OptionableProperty']> = {
  __resolveType: TypeResolveFn<'MultiselectProperty' | 'SelectProperty', ParentType, ContextType>;
  options?: Resolver<Array<ResolversTypes['SelectOption']>, ParentType, ContextType>;
};

export type OrderingResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ordering'] = ResolversParentTypes['Ordering']> = {
  children?: Resolver<ResolversTypes['OrderingEntryConnection'], ParentType, ContextType, RequireFields<OrderingChildrenArgs, 'order' | 'pageDirection' | 'perPage'>>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  disabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  disabledAt?: Resolver<Maybe<ResolversTypes['ISO8601Date']>, ParentType, ContextType>;
  entity?: Resolver<ResolversTypes['AnyEntity'], ParentType, ContextType>;
  footer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  header?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  inheritedFromSchema?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderingConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderingConnection'] = ResolversParentTypes['OrderingConnection']> = {
  edges?: Resolver<Array<ResolversTypes['OrderingEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['Ordering']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderingEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderingEdge'] = ResolversParentTypes['OrderingEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Ordering'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderingEntryResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderingEntry'] = ResolversParentTypes['OrderingEntry']> = {
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  entry?: Resolver<ResolversTypes['AnyOrderingEntry'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ordering?: Resolver<ResolversTypes['Ordering'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderingEntryConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderingEntryConnection'] = ResolversParentTypes['OrderingEntryConnection']> = {
  edges?: Resolver<Array<ResolversTypes['OrderingEntryEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['OrderingEntry']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderingEntryEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderingEntryEdge'] = ResolversParentTypes['OrderingEntryEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['OrderingEntry'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganizationContributorResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganizationContributor'] = ResolversParentTypes['OrganizationContributor']> = {
  bio?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collectionContributions?: Resolver<ResolversTypes['CollectionContributionConnection'], ParentType, ContextType, RequireFields<OrganizationContributorCollectionContributionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  itemContributions?: Resolver<ResolversTypes['ItemContributionConnection'], ParentType, ContextType, RequireFields<OrganizationContributorItemContributionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  kind?: Resolver<ResolversTypes['ContributorKind'], ParentType, ContextType>;
  legalName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  links?: Resolver<Array<Maybe<ResolversTypes['ContributorLink']>>, ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  prefix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  suffix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = {
  endCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  page?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  pageCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  perPage?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  startCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalUnfilteredCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaginatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['Paginated'] = ResolversParentTypes['Paginated']> = {
  __resolveType: TypeResolveFn<'AnyAssetConnection' | 'AnyContributorConnection' | 'CollectionConnection' | 'CollectionContributionConnection' | 'CommunityConnection' | 'EntityLinkConnection' | 'ItemConnection' | 'ItemContributionConnection' | 'OrderingConnection' | 'OrderingEntryConnection' | 'RoleConnection' | 'SchemaDefinitionConnection' | 'SchemaVersionConnection' | 'UserConnection', ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
};

export type PermissionGrantResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionGrant'] = ResolversParentTypes['PermissionGrant']> = {
  allowed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  scope?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PersonContributorResolvers<ContextType = any, ParentType extends ResolversParentTypes['PersonContributor'] = ResolversParentTypes['PersonContributor']> = {
  affiliation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  bio?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collectionContributions?: Resolver<ResolversTypes['CollectionContributionConnection'], ParentType, ContextType, RequireFields<PersonContributorCollectionContributionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  familyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  givenName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  image?: Resolver<Maybe<ResolversTypes['AssetPreview']>, ParentType, ContextType>;
  itemContributions?: Resolver<ResolversTypes['ItemContributionConnection'], ParentType, ContextType, RequireFields<PersonContributorItemContributionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  kind?: Resolver<ResolversTypes['ContributorKind'], ParentType, ContextType>;
  links?: Resolver<Array<Maybe<ResolversTypes['ContributorLink']>>, ParentType, ContextType>;
  prefix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  suffix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PreviewImageResolvers<ContextType = any, ParentType extends ResolversParentTypes['PreviewImage'] = ResolversParentTypes['PreviewImage']> = {
  alt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  dimensions?: Resolver<Array<ResolversTypes['Int']>, ParentType, ContextType>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  width?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PreviewImageMapResolvers<ContextType = any, ParentType extends ResolversParentTypes['PreviewImageMap'] = ResolversParentTypes['PreviewImageMap']> = {
  alt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  dimensions?: Resolver<Array<ResolversTypes['Int']>, ParentType, ContextType>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  png?: Resolver<Maybe<ResolversTypes['PreviewImage']>, ParentType, ContextType>;
  webp?: Resolver<Maybe<ResolversTypes['PreviewImage']>, ParentType, ContextType>;
  width?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType, RequireFields<QueryCollectionArgs, 'slug'>>;
  communities?: Resolver<ResolversTypes['CommunityConnection'], ParentType, ContextType, RequireFields<QueryCommunitiesArgs, 'order' | 'pageDirection' | 'perPage'>>;
  community?: Resolver<Maybe<ResolversTypes['Community']>, ParentType, ContextType, RequireFields<QueryCommunityArgs, 'slug'>>;
  contributor?: Resolver<Maybe<ResolversTypes['AnyContributor']>, ParentType, ContextType, RequireFields<QueryContributorArgs, 'slug'>>;
  contributors?: Resolver<ResolversTypes['AnyContributorConnection'], ParentType, ContextType, RequireFields<QueryContributorsArgs, 'order' | 'kind' | 'pageDirection' | 'perPage'>>;
  item?: Resolver<Maybe<ResolversTypes['Item']>, ParentType, ContextType, RequireFields<QueryItemArgs, 'slug'>>;
  node?: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType, RequireFields<QueryNodeArgs, 'id'>>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['Node']>>, ParentType, ContextType, RequireFields<QueryNodesArgs, 'ids'>>;
  roles?: Resolver<ResolversTypes['RoleConnection'], ParentType, ContextType, RequireFields<QueryRolesArgs, 'order'>>;
  schemaDefinition?: Resolver<Maybe<ResolversTypes['SchemaDefinition']>, ParentType, ContextType, RequireFields<QuerySchemaDefinitionArgs, 'slug'>>;
  schemaDefinitions?: Resolver<ResolversTypes['SchemaDefinitionConnection'], ParentType, ContextType, RequireFields<QuerySchemaDefinitionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  schemaVersion?: Resolver<Maybe<ResolversTypes['SchemaVersion']>, ParentType, ContextType, RequireFields<QuerySchemaVersionArgs, 'slug'>>;
  schemaVersions?: Resolver<ResolversTypes['SchemaVersionConnection'], ParentType, ContextType, RequireFields<QuerySchemaVersionsArgs, 'order' | 'pageDirection' | 'perPage'>>;
  users?: Resolver<ResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<QueryUsersArgs, 'order' | 'pageDirection' | 'perPage'>>;
  viewer?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
};

export type ReparentCollectionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReparentCollectionPayload'] = ResolversParentTypes['ReparentCollectionPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReparentItemPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReparentItemPayload'] = ResolversParentTypes['ReparentItemPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ResetOrderingPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResetOrderingPayload'] = ResolversParentTypes['ResetOrderingPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ordering?: Resolver<Maybe<ResolversTypes['Ordering']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RevokeAccessPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['RevokeAccessPayload'] = ResolversParentTypes['RevokeAccessPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entity?: Resolver<Maybe<ResolversTypes['AnyEntity']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  revoked?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleResolvers<ContextType = any, ParentType extends ResolversParentTypes['Role'] = ResolversParentTypes['Role']> = {
  accessControlList?: Resolver<ResolversTypes['AccessControlList'], ParentType, ContextType>;
  allowedActions?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleConnection'] = ResolversParentTypes['RoleConnection']> = {
  edges?: Resolver<Array<ResolversTypes['RoleEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['Role']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleEdge'] = ResolversParentTypes['RoleEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Role'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ScalarPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['ScalarProperty'] = ResolversParentTypes['ScalarProperty']> = {
  __resolveType: TypeResolveFn<'AssetProperty' | 'AssetsProperty' | 'BooleanProperty' | 'ContributorProperty' | 'ContributorsProperty' | 'DateProperty' | 'EmailProperty' | 'FloatProperty' | 'IntegerProperty' | 'MarkdownProperty' | 'MultiselectProperty' | 'SelectProperty' | 'StringProperty' | 'TagsProperty' | 'TimestampProperty' | 'UnknownProperty', ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type SchemaDefinitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaDefinition'] = ResolversParentTypes['SchemaDefinition']> = {
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['SchemaKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  namespace?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaDefinitionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaDefinitionConnection'] = ResolversParentTypes['SchemaDefinitionConnection']> = {
  edges?: Resolver<Array<ResolversTypes['SchemaDefinitionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['SchemaDefinition']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaDefinitionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaDefinitionEdge'] = ResolversParentTypes['SchemaDefinitionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['SchemaDefinition'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaProperty'] = ResolversParentTypes['SchemaProperty']> = {
  __resolveType: TypeResolveFn<'GroupProperty', ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type SchemaValueErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaValueError'] = ResolversParentTypes['SchemaValueError']> = {
  base?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hint?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metadata?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaVersionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaVersion'] = ResolversParentTypes['SchemaVersion']> = {
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['SchemaKind'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  namespace?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  schemaDefinition?: Resolver<ResolversTypes['SchemaDefinition'], ParentType, ContextType>;
  schemaProperties?: Resolver<Array<ResolversTypes['AnySchemaProperty']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaVersionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaVersionConnection'] = ResolversParentTypes['SchemaVersionConnection']> = {
  edges?: Resolver<Array<ResolversTypes['SchemaVersionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['SchemaVersion']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaVersionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaVersionEdge'] = ResolversParentTypes['SchemaVersionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['SchemaVersion'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SelectOptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SelectOption'] = ResolversParentTypes['SelectOption']> = {
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SelectPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['SelectProperty'] = ResolversParentTypes['SelectProperty']> = {
  defaultSelection?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  options?: Resolver<Array<ResolversTypes['SelectOption']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  selection?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface SlugScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Slug'], any> {
  name: 'Slug';
}

export type SluggableResolvers<ContextType = any, ParentType extends ResolversParentTypes['Sluggable'] = ResolversParentTypes['Sluggable']> = {
  __resolveType: TypeResolveFn<'AssetAudio' | 'AssetDocument' | 'AssetImage' | 'AssetPDF' | 'AssetUnknown' | 'AssetVideo' | 'Collection' | 'CollectionContribution' | 'Community' | 'EntityLink' | 'Item' | 'ItemContribution' | 'Ordering' | 'OrderingEntry' | 'OrganizationContributor' | 'PersonContributor' | 'Role' | 'SchemaDefinition' | 'SchemaVersion' | 'User', ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
};

export type StandardMutationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandardMutationPayload'] = ResolversParentTypes['StandardMutationPayload']> = {
  __resolveType: TypeResolveFn<'AlterSchemaVersionPayload' | 'ApplySchemaPropertiesPayload' | 'CreateAssetPayload' | 'CreateCollectionPayload' | 'CreateCommunityPayload' | 'CreateItemPayload' | 'CreateOrderingPayload' | 'CreateOrganizationContributorPayload' | 'CreatePersonContributorPayload' | 'CreateRolePayload' | 'DestroyContributionPayload' | 'DestroyContributorPayload' | 'DestroyOrderingPayload' | 'GrantAccessPayload' | 'LinkEntityPayload' | 'ReparentCollectionPayload' | 'ReparentItemPayload' | 'ResetOrderingPayload' | 'RevokeAccessPayload' | 'UpdateCollectionPayload' | 'UpdateCommunityPayload' | 'UpdateContributionPayload' | 'UpdateItemPayload' | 'UpdateOrderingPayload' | 'UpdateOrganizationContributorPayload' | 'UpdatePersonContributorPayload' | 'UpdateRolePayload' | 'UpsertContributionPayload', ParentType, ContextType>;
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
};

export type StringPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['StringProperty'] = ResolversParentTypes['StringProperty']> = {
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  default?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TagsPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['TagsProperty'] = ResolversParentTypes['TagsProperty']> = {
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  tags?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TimestampPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['TimestampProperty'] = ResolversParentTypes['TimestampProperty']> = {
  default?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnknownPropertyResolvers<ContextType = any, ParentType extends ResolversParentTypes['UnknownProperty'] = ResolversParentTypes['UnknownProperty']> = {
  default?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  fullPath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  unknownValue?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateCollectionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateCollectionPayload'] = ResolversParentTypes['UpdateCollectionPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateCommunityPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateCommunityPayload'] = ResolversParentTypes['UpdateCommunityPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  community?: Resolver<Maybe<ResolversTypes['Community']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateContributionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateContributionPayload'] = ResolversParentTypes['UpdateContributionPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contribution?: Resolver<Maybe<ResolversTypes['AnyContribution']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateItemPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateItemPayload'] = ResolversParentTypes['UpdateItemPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['Item']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateOrderingPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateOrderingPayload'] = ResolversParentTypes['UpdateOrderingPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ordering?: Resolver<Maybe<ResolversTypes['Ordering']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateOrganizationContributorPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateOrganizationContributorPayload'] = ResolversParentTypes['UpdateOrganizationContributorPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contributor?: Resolver<Maybe<ResolversTypes['OrganizationContributor']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePersonContributorPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdatePersonContributorPayload'] = ResolversParentTypes['UpdatePersonContributorPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contributor?: Resolver<Maybe<ResolversTypes['PersonContributor']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateRolePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateRolePayload'] = ResolversParentTypes['UpdateRolePayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['Role']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface UploadIdScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['UploadID'], any> {
  name: 'UploadID';
}

export type UpsertContributionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpsertContributionPayload'] = ResolversParentTypes['UpsertContributionPayload']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['MutationAttributeError']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contribution?: Resolver<Maybe<ResolversTypes['AnyContribution']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['UserError']>, ParentType, ContextType>;
  globalErrors?: Resolver<Array<ResolversTypes['MutationGlobalError']>, ParentType, ContextType>;
  haltCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {
  allowedActions?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  anonymous?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  collections?: Resolver<ResolversTypes['CollectionConnection'], ParentType, ContextType, RequireFields<UserCollectionsArgs, 'access' | 'order' | 'nodeFilter' | 'pageDirection' | 'perPage'>>;
  communities?: Resolver<ResolversTypes['CommunityConnection'], ParentType, ContextType, RequireFields<UserCommunitiesArgs, 'access' | 'order' | 'nodeFilter' | 'pageDirection' | 'perPage'>>;
  createdAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emailVerified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  globalAdmin?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  items?: Resolver<ResolversTypes['ItemConnection'], ParentType, ContextType, RequireFields<UserItemsArgs, 'access' | 'order' | 'nodeFilter' | 'pageDirection' | 'perPage'>>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissions?: Resolver<Array<ResolversTypes['PermissionGrant']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['Slug'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  uploadAccess?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  uploadToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserConnection'] = ResolversParentTypes['UserConnection']> = {
  edges?: Resolver<Array<ResolversTypes['UserEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<ResolversTypes['User']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserEdge'] = ResolversParentTypes['UserEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserError'] = ResolversParentTypes['UserError']> = {
  attributePath?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  scope?: Resolver<ResolversTypes['MutationErrorScope'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
  AccessControlList?: AccessControlListResolvers<ContextType>;
  AlterSchemaVersionPayload?: AlterSchemaVersionPayloadResolvers<ContextType>;
  AnyAsset?: AnyAssetResolvers<ContextType>;
  AnyAssetConnection?: AnyAssetConnectionResolvers<ContextType>;
  AnyAssetEdge?: AnyAssetEdgeResolvers<ContextType>;
  AnyAttachable?: AnyAttachableResolvers<ContextType>;
  AnyContribution?: AnyContributionResolvers<ContextType>;
  AnyContributor?: AnyContributorResolvers<ContextType>;
  AnyContributorConnection?: AnyContributorConnectionResolvers<ContextType>;
  AnyContributorEdge?: AnyContributorEdgeResolvers<ContextType>;
  AnyEntity?: AnyEntityResolvers<ContextType>;
  AnyOrderingEntry?: AnyOrderingEntryResolvers<ContextType>;
  AnyScalarProperty?: AnyScalarPropertyResolvers<ContextType>;
  AnySchemaProperty?: AnySchemaPropertyResolvers<ContextType>;
  ApplySchemaPropertiesPayload?: ApplySchemaPropertiesPayloadResolvers<ContextType>;
  Asset?: AssetResolvers<ContextType>;
  AssetAudio?: AssetAudioResolvers<ContextType>;
  AssetDocument?: AssetDocumentResolvers<ContextType>;
  AssetImage?: AssetImageResolvers<ContextType>;
  AssetPDF?: AssetPdfResolvers<ContextType>;
  AssetPreview?: AssetPreviewResolvers<ContextType>;
  AssetProperty?: AssetPropertyResolvers<ContextType>;
  AssetUnknown?: AssetUnknownResolvers<ContextType>;
  AssetVideo?: AssetVideoResolvers<ContextType>;
  AssetsProperty?: AssetsPropertyResolvers<ContextType>;
  Attachable?: AttachableResolvers<ContextType>;
  BooleanProperty?: BooleanPropertyResolvers<ContextType>;
  Collection?: CollectionResolvers<ContextType>;
  CollectionConnection?: CollectionConnectionResolvers<ContextType>;
  CollectionContribution?: CollectionContributionResolvers<ContextType>;
  CollectionContributionConnection?: CollectionContributionConnectionResolvers<ContextType>;
  CollectionContributionEdge?: CollectionContributionEdgeResolvers<ContextType>;
  CollectionEdge?: CollectionEdgeResolvers<ContextType>;
  CollectionParent?: CollectionParentResolvers<ContextType>;
  Community?: CommunityResolvers<ContextType>;
  CommunityConnection?: CommunityConnectionResolvers<ContextType>;
  CommunityEdge?: CommunityEdgeResolvers<ContextType>;
  Contributable?: ContributableResolvers<ContextType>;
  Contribution?: ContributionResolvers<ContextType>;
  ContributionMetadata?: ContributionMetadataResolvers<ContextType>;
  Contributor?: ContributorResolvers<ContextType>;
  ContributorLink?: ContributorLinkResolvers<ContextType>;
  ContributorProperty?: ContributorPropertyResolvers<ContextType>;
  ContributorsProperty?: ContributorsPropertyResolvers<ContextType>;
  CreateAssetPayload?: CreateAssetPayloadResolvers<ContextType>;
  CreateCollectionPayload?: CreateCollectionPayloadResolvers<ContextType>;
  CreateCommunityPayload?: CreateCommunityPayloadResolvers<ContextType>;
  CreateItemPayload?: CreateItemPayloadResolvers<ContextType>;
  CreateOrderingPayload?: CreateOrderingPayloadResolvers<ContextType>;
  CreateOrganizationContributorPayload?: CreateOrganizationContributorPayloadResolvers<ContextType>;
  CreatePersonContributorPayload?: CreatePersonContributorPayloadResolvers<ContextType>;
  CreateRolePayload?: CreateRolePayloadResolvers<ContextType>;
  DateProperty?: DatePropertyResolvers<ContextType>;
  DestroyContributionPayload?: DestroyContributionPayloadResolvers<ContextType>;
  DestroyContributorPayload?: DestroyContributorPayloadResolvers<ContextType>;
  DestroyOrderingPayload?: DestroyOrderingPayloadResolvers<ContextType>;
  EmailProperty?: EmailPropertyResolvers<ContextType>;
  Entity?: EntityResolvers<ContextType>;
  EntityBreadcrumb?: EntityBreadcrumbResolvers<ContextType>;
  EntityLink?: EntityLinkResolvers<ContextType>;
  EntityLinkConnection?: EntityLinkConnectionResolvers<ContextType>;
  EntityLinkEdge?: EntityLinkEdgeResolvers<ContextType>;
  ExposesPermissions?: ExposesPermissionsResolvers<ContextType>;
  FloatProperty?: FloatPropertyResolvers<ContextType>;
  GrantAccessPayload?: GrantAccessPayloadResolvers<ContextType>;
  GroupProperty?: GroupPropertyResolvers<ContextType>;
  HasSchemaProperties?: HasSchemaPropertiesResolvers<ContextType>;
  HierarchicalEntry?: HierarchicalEntryResolvers<ContextType>;
  ISO8601Date?: GraphQLScalarType;
  ISO8601DateTime?: GraphQLScalarType;
  IntegerProperty?: IntegerPropertyResolvers<ContextType>;
  Item?: ItemResolvers<ContextType>;
  ItemConnection?: ItemConnectionResolvers<ContextType>;
  ItemContribution?: ItemContributionResolvers<ContextType>;
  ItemContributionConnection?: ItemContributionConnectionResolvers<ContextType>;
  ItemContributionEdge?: ItemContributionEdgeResolvers<ContextType>;
  ItemEdge?: ItemEdgeResolvers<ContextType>;
  ItemParent?: ItemParentResolvers<ContextType>;
  JSON?: GraphQLScalarType;
  LinkEntityPayload?: LinkEntityPayloadResolvers<ContextType>;
  MarkdownProperty?: MarkdownPropertyResolvers<ContextType>;
  MultiselectProperty?: MultiselectPropertyResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  MutationAttributeError?: MutationAttributeErrorResolvers<ContextType>;
  MutationGlobalError?: MutationGlobalErrorResolvers<ContextType>;
  Node?: NodeResolvers<ContextType>;
  OptionableProperty?: OptionablePropertyResolvers<ContextType>;
  Ordering?: OrderingResolvers<ContextType>;
  OrderingConnection?: OrderingConnectionResolvers<ContextType>;
  OrderingEdge?: OrderingEdgeResolvers<ContextType>;
  OrderingEntry?: OrderingEntryResolvers<ContextType>;
  OrderingEntryConnection?: OrderingEntryConnectionResolvers<ContextType>;
  OrderingEntryEdge?: OrderingEntryEdgeResolvers<ContextType>;
  OrganizationContributor?: OrganizationContributorResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  Paginated?: PaginatedResolvers<ContextType>;
  PermissionGrant?: PermissionGrantResolvers<ContextType>;
  PersonContributor?: PersonContributorResolvers<ContextType>;
  PreviewImage?: PreviewImageResolvers<ContextType>;
  PreviewImageMap?: PreviewImageMapResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  ReparentCollectionPayload?: ReparentCollectionPayloadResolvers<ContextType>;
  ReparentItemPayload?: ReparentItemPayloadResolvers<ContextType>;
  ResetOrderingPayload?: ResetOrderingPayloadResolvers<ContextType>;
  RevokeAccessPayload?: RevokeAccessPayloadResolvers<ContextType>;
  Role?: RoleResolvers<ContextType>;
  RoleConnection?: RoleConnectionResolvers<ContextType>;
  RoleEdge?: RoleEdgeResolvers<ContextType>;
  ScalarProperty?: ScalarPropertyResolvers<ContextType>;
  SchemaDefinition?: SchemaDefinitionResolvers<ContextType>;
  SchemaDefinitionConnection?: SchemaDefinitionConnectionResolvers<ContextType>;
  SchemaDefinitionEdge?: SchemaDefinitionEdgeResolvers<ContextType>;
  SchemaProperty?: SchemaPropertyResolvers<ContextType>;
  SchemaValueError?: SchemaValueErrorResolvers<ContextType>;
  SchemaVersion?: SchemaVersionResolvers<ContextType>;
  SchemaVersionConnection?: SchemaVersionConnectionResolvers<ContextType>;
  SchemaVersionEdge?: SchemaVersionEdgeResolvers<ContextType>;
  SelectOption?: SelectOptionResolvers<ContextType>;
  SelectProperty?: SelectPropertyResolvers<ContextType>;
  Slug?: GraphQLScalarType;
  Sluggable?: SluggableResolvers<ContextType>;
  StandardMutationPayload?: StandardMutationPayloadResolvers<ContextType>;
  StringProperty?: StringPropertyResolvers<ContextType>;
  TagsProperty?: TagsPropertyResolvers<ContextType>;
  TimestampProperty?: TimestampPropertyResolvers<ContextType>;
  UnknownProperty?: UnknownPropertyResolvers<ContextType>;
  UpdateCollectionPayload?: UpdateCollectionPayloadResolvers<ContextType>;
  UpdateCommunityPayload?: UpdateCommunityPayloadResolvers<ContextType>;
  UpdateContributionPayload?: UpdateContributionPayloadResolvers<ContextType>;
  UpdateItemPayload?: UpdateItemPayloadResolvers<ContextType>;
  UpdateOrderingPayload?: UpdateOrderingPayloadResolvers<ContextType>;
  UpdateOrganizationContributorPayload?: UpdateOrganizationContributorPayloadResolvers<ContextType>;
  UpdatePersonContributorPayload?: UpdatePersonContributorPayloadResolvers<ContextType>;
  UpdateRolePayload?: UpdateRolePayloadResolvers<ContextType>;
  UploadID?: GraphQLScalarType;
  UpsertContributionPayload?: UpsertContributionPayloadResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserConnection?: UserConnectionResolvers<ContextType>;
  UserEdge?: UserEdgeResolvers<ContextType>;
  UserError?: UserErrorResolvers<ContextType>;
};


/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
 */
export type IResolvers<ContextType = any> = Resolvers<ContextType>;
